diff --git a/Mage.Server.Plugins/Mage.Player.AI.MA/src/mage/player/ai/ComputerPlayer6.java b/Mage.Server.Plugins/Mage.Player.AI.MA/src/mage/player/ai/ComputerPlayer6.java
index d22e381cc8..98d36984fd 100644
--- a/Mage.Server.Plugins/Mage.Player.AI.MA/src/mage/player/ai/ComputerPlayer6.java
+++ b/Mage.Server.Plugins/Mage.Player.AI.MA/src/mage/player/ai/ComputerPlayer6.java
@@ -431,6 +431,7 @@ public class ComputerPlayer6 extends ComputerPlayer {
      */
     protected Integer addActionsTimed() {
         // run new game simulation in parallel thread
+        //assert (threadPoolSimulations != null);
         FutureTask<Integer> task = new FutureTask<>(() -> addActions(root, maxDepth, Integer.MIN_VALUE, Integer.MAX_VALUE));
         threadPoolSimulations.execute(task);
         try {
diff --git a/Mage.Server.Plugins/Mage.Player.AI.MA/src/mage/player/ai/GameStateEvaluator2.java b/Mage.Server.Plugins/Mage.Player.AI.MA/src/mage/player/ai/GameStateEvaluator2.java
index 7adc1cb429..3ec0de6bf9 100644
--- a/Mage.Server.Plugins/Mage.Player.AI.MA/src/mage/player/ai/GameStateEvaluator2.java
+++ b/Mage.Server.Plugins/Mage.Player.AI.MA/src/mage/player/ai/GameStateEvaluator2.java
@@ -154,6 +154,12 @@ public final class GameStateEvaluator2 {
                         + ":" + GameStateEvaluator2.evaluatePermanent(p, game, true))
                 .collect(Collectors.joining("; "));
         sb.append("-> Permanents: [").append(ownPermanentsInfo).append("]");
+        // graveyard
+        sb.setLength(0);
+        String ownGraveInfo = player.getGraveyard().stream()
+                .map(id -> game.getObject(id).getName())
+                .collect(Collectors.joining("; "));
+        sb.append("-> Graveyard: [").append(ownGraveInfo).append("]");
         logger.info(sb.toString());
     }
     public static int evaluatePermanent(Permanent permanent, Game game, boolean useCombatPermanentScore) {
diff --git a/Mage.Server.Plugins/Mage.Player.AI.RL/pom.xml b/Mage.Server.Plugins/Mage.Player.AI.RL/pom.xml
index 3e9a7d0a90..caaa9161cb 100644
--- a/Mage.Server.Plugins/Mage.Player.AI.RL/pom.xml
+++ b/Mage.Server.Plugins/Mage.Player.AI.RL/pom.xml
@@ -39,7 +39,7 @@
         <dependency>
             <groupId>com.microsoft.onnxruntime</groupId>
             <artifactId>onnxruntime</artifactId>
-            <version>1.15.1</version>
+            <version>1.18.0</version>
         </dependency>
     </dependencies>
 
diff --git a/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/ComputerPlayer8.java b/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/ComputerPlayer8.java
index 3e1d9609d6..3e25bb645c 100644
--- a/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/ComputerPlayer8.java
+++ b/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/ComputerPlayer8.java
@@ -11,7 +11,8 @@ import mage.target.Target;
 import java.util.UUID;
 
 public class ComputerPlayer8 extends ComputerPlayer7{
-    private StateEncoder encoder;
+    //public static boolean saveMinimaxScore = true;
+    private transient StateEncoder encoder;
     public ComputerPlayer8(ComputerPlayer7 player) {
         super(player);
     }
diff --git a/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/ComputerPlayerMCTS2.java b/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/ComputerPlayerMCTS2.java
index 54b89f5b82..70abdb3046 100644
--- a/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/ComputerPlayerMCTS2.java
+++ b/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/ComputerPlayerMCTS2.java
@@ -4,6 +4,7 @@ import ai.onnxruntime.OrtException;
 import mage.constants.PhaseStep;
 import mage.constants.RangeOfInfluence;
 import mage.game.Game;
+import mage.game.GameState;
 import mage.player.ai.MCTSPlayer.NextAction;
 import mage.util.RandomUtil;
 import mage.util.ThreadUtils;
@@ -21,31 +22,21 @@ public class ComputerPlayerMCTS2 extends ComputerPlayerMCTS {
 
     private static final Logger logger = Logger.getLogger(ComputerPlayerMCTS2.class);
 
-    private StateEncoder encoder = null;
-    private static final int MAX_MCTS_CYCLES = 2;//number of additional cycles the search is allowed to run
-    private static final int BASE_THREAD_TIMEOUT = 3;//seconds
-    private static final int MIN_TREE_VISITS = 100;
-    private static final int MAX_TREE_VISITS = 200;
+    private transient StateEncoder encoder = null;
+    private transient ReplayBuffer buffer = null;
+    private static final int MAX_MCTS_CYCLES = 6;//number of additional cycles the search is allowed to run
+    private static final int BASE_THREAD_TIMEOUT = 1;//seconds
+    private static final int MIN_TREE_VISITS = 50;//per child per thread
 
     public static boolean SHOW_THREAD_INFO = false;
-    //protected List<UUID> targets = new ArrayList<>();
-    //protected List<String> choices = new ArrayList<>();
-    public NeuralNetEvaluator nn;
+    public transient NeuralNetEvaluator nn;
 
-    public static String PATH_TO_NN = "null";
-    private final Object encoderLock = new Object();
-    private final Object executorLock = new Object();
 
 
 
 
     public ComputerPlayerMCTS2(String name, RangeOfInfluence range, int skill) {
         super(name, range, skill);
-        try {
-            nn = new NeuralNetEvaluator(PATH_TO_NN);
-        } catch (OrtException e) {
-            throw new RuntimeException(e);
-        }
     }
 
     protected ComputerPlayerMCTS2(UUID id) {
@@ -62,62 +53,49 @@ public class ComputerPlayerMCTS2 extends ComputerPlayerMCTS {
         return new ComputerPlayerMCTS2(this);
     }
 
+    /**
+     * Evaluates a node's game state using the neural network.
+     * This method encodes the state into sparse global indices, runs inference,
+     * and updates the node's policy prior.
+     *
+     * @param node The MCTSNode to evaluate.
+     * @return The value of the game state as predicted by the neural network's value head.
+     */
     protected double evaluateState(MCTSNode node) {
-        // 1) Get the active GLOBAL feature indices for the current state.
-        // This replaces the old way of getting a deck-local BitSet and converting it.
+
         int[] activeGlobalIndices;
-        synchronized(encoderLock) { // Keep synchronization if encoder access needs it
-            encoder.processState(node.getGame()); // This should prepare the raw features
-
-            // You need a method in your StateEncoder that returns the
-            // final list of active GLOBAL indices. This method would:
-            //   a. Get the raw features from the current game state.
-            //   b. Map them to global indices (using rawToReduced, assigning new ones if needed).
-            //   c. Apply the ignoreList.
-            // Let's assume such a method exists, e.g., encoder.getActiveGlobalIndices();
-            // For this example, I'll use a placeholder for how you get these.
-            // If encoder.getCompressedVector still returns a Set<Integer> of global indices:
-            Set<Integer> globalIndicesSet = encoder.getCompressedVector(StateEncoder.featureVector);
-            activeGlobalIndices = globalIndicesSet.stream().mapToInt(Integer::intValue).toArray();
-            // Or, if you have a more direct method:
-            // activeGlobalIndices = encoder.getFinalActiveGlobalIndicesArray();
-        }
 
-        // 2) Prepare inputs for the ONNX model (expecting EmbeddingBag style input)
-        //    The exact format depends on how your ONNX runtime library takes tensor inputs.
-        //    Typically, for a single inference, you'd have:
-        //    - indices: A 1D array/tensor of the activeGlobalIndices.
-        //    - offsets: A 1D array/tensor like [0] indicating the start of the single sample.
+        encoder.processState(node.getGame());
+        activeGlobalIndices = encoder.getFinalActiveGlobalIndicesArray();
+
 
-        //    Let's assume your nn.infer() is adapted to take these.
-        //    You might need to convert activeGlobalIndices to a long[] or specific tensor format
-        //    required by your Java ONNX runtime.
-        //    For example, if it needs long[] for indices:
         long[] onnxIndices = new long[activeGlobalIndices.length];
+
         for (int i = 0; i < activeGlobalIndices.length; i++) {
             onnxIndices[i] = activeGlobalIndices[i];
         }
-        long[] onnxOffsets = new long[]{0}; // For a single sample batch
 
-        NeuralNetEvaluator.InferenceResult out;
-        synchronized(encoderLock) { // If nn.infer() also needs sync with encoder or is not thread-safe
-            // 3) Run the ONNX model with the new sparse input format
-            //    The signature of nn.infer() would need to change.
-            out = nn.infer(onnxIndices);
-        }
-
-        // 4) Process outputs (this part remains the same)
+        NeuralNetEvaluator.InferenceResult out = nn.infer(onnxIndices);
         node.policy = out.policy;
+
         return out.value;
     }
+
     public void setEncoder(StateEncoder enc) {
         encoder = enc;
     }
-
-    public StateEncoder getEncoder() {
-        return encoder;
+    public void setBuffer(ReplayBuffer buf) {
+        buffer = buf;
+    }
+    public void initNN(String path) {
+        try {
+            nn = new NeuralNetEvaluator(path);
+        } catch (OrtException e) {
+            throw new RuntimeException(e);
+        }
     }
-    public int diffVisits(List<Integer> children) {
+
+    public double diffVisits(List<Integer> children) {
         int max = -1;
         int max2 = -1;//second highest
         for(int n : children) {
@@ -128,7 +106,7 @@ public class ComputerPlayerMCTS2 extends ComputerPlayerMCTS {
                 max2 = n;
             }
         }
-        return max-max2;
+        return (max*1.0)/max2;
     }
     public int averageVisits(List<Integer> children) {
         int sum = 0;
@@ -156,10 +134,11 @@ public class ComputerPlayerMCTS2 extends ComputerPlayerMCTS {
         int initialVisits = root.getAverageVisits();
         //if(initialVisits > MAX_TREE_VISITS) return;//just keep using tree
         if(SHOW_THREAD_INFO) System.out.printf("STARTING ROOT VISITS: %d\n", initialVisits);
-        int thinkTime = BASE_THREAD_TIMEOUT;//calculateThinkTime(game, action);
+        int thinkTime = BASE_THREAD_TIMEOUT;
 
 
         if (this.threadPoolSimulations == null) {
+            System.out.println(poolSize);
             this.threadPoolSimulations = new ThreadPoolExecutor(
                     poolSize,
                     poolSize,
@@ -174,6 +153,7 @@ public class ComputerPlayerMCTS2 extends ComputerPlayerMCTS {
         for (int i = 0; i < poolSize; i++) {
             Game sim = createMCTSGame(game);
             MCTSPlayer player = (MCTSPlayer) sim.getPlayer(playerId);
+            player.lastToAct = true;
             player.chooseTargetOptions = chooseTargetOptions;
             player.chooseTargetAction = new ArrayList<>(chosenChooseTargetActions);
             player.setNextAction(action);
@@ -193,9 +173,12 @@ public class ComputerPlayerMCTS2 extends ComputerPlayerMCTS {
         int cycleCounter = 0;
         int fullTime = 0;
 
-        while (averageVisits(childVisits)+initialVisits < MIN_TREE_VISITS) {//use max visits of children as indicator
+        while (averageVisits(childVisits)+initialVisits < MIN_TREE_VISITS*poolSize) {//use max visits of children as indicator
+
+            if (cycleCounter > MAX_MCTS_CYCLES) break; //early exit
+
+            if(diffVisits(childVisits) > 2.5 && averageVisits(childVisits) > MIN_TREE_VISITS*poolSize*0.5) break;
 
-            if (cycleCounter > MAX_MCTS_CYCLES) break;
             cycleCounter++;
             try {
                 List<Future<Boolean>> runningTasks = threadPoolSimulations.invokeAll(tasks, thinkTime, TimeUnit.SECONDS);
@@ -222,7 +205,6 @@ public class ComputerPlayerMCTS2 extends ComputerPlayerMCTS {
                 System.out.printf("\nCOMPOSITE CHILDREN: %s\n", childVisits.toString());
             }
             fullTime += thinkTime;
-            thinkTime += 1;
         }
         int simCount = 0;
         for (MCTSExecutor task : tasks) {
@@ -272,7 +254,7 @@ public class ComputerPlayerMCTS2 extends ComputerPlayerMCTS {
             Game sim = createMCTSGame(game);
             MCTSPlayer player = (MCTSPlayer) sim.getPlayer(playerId);
             player.setNextAction(action);
-            player.isRoot = true;
+            player.lastToAct = true;
             root = new MCTSNode(playerId, sim);
             player.chooseTargetOptions = chooseTargetOptions;
             player.chooseTargetAction = new ArrayList<>(chosenChooseTargetActions);
@@ -282,19 +264,19 @@ public class ComputerPlayerMCTS2 extends ComputerPlayerMCTS {
         if (root != null) {
             MCTSNode best = root.bestChild();
             if(best == null) return;
-            synchronized (encoderLock) {
-                encoder.processMacroState(game);
-                encoder.stateScores.add(root.score);
-                ActionEncoder.addAction(getActionVec());
-            }
-            macroState = root.macroState;
-            macroPlayerId = getId();
+
+            encoder.processMacroState(game);
+            ActionEncoder.addAction(getActionVec());
+            Game copiedState = game.copy();
+            buffer.add(copiedState);
+
+            //macroState = root.macroState;
             root = best;
-            lastAction = root.action;
+            //game.setLastAction(root.action);
             root.emancipate();
         }
     }
-    private static List<Integer> getChildVisits(List<MCTSExecutor> tasks) {
+    private List<Integer> getChildVisits(List<MCTSExecutor> tasks) {
         List<Integer> childVisits = new ArrayList<>();
         int min = Integer.MAX_VALUE;
         for(MCTSExecutor task : tasks) {
@@ -303,7 +285,7 @@ public class ComputerPlayerMCTS2 extends ComputerPlayerMCTS {
 
         for(int i = 0; i <  min; i++) {
             int visitSum = 0;
-            for(int j = 0; j < 8; j++) {
+            for(int j = 0; j < poolSize; j++) {
                 visitSum += tasks.get(j).root.children.get(i).visits;
             }
             childVisits.add(visitSum);
diff --git a/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/ComputerPlayerMinimaxOpponent.java b/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/ComputerPlayerMinimaxOpponent.java
index 978c735ba5..d7c56d7862 100644
--- a/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/ComputerPlayerMinimaxOpponent.java
+++ b/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/ComputerPlayerMinimaxOpponent.java
@@ -129,9 +129,9 @@ public class ComputerPlayerMinimaxOpponent extends ComputerPlayer7{
                         }
                     }
                 }
-                ComputerPlayerMCTS.macroState = ComputerPlayerMCTS.createCompleteMCTSGame(game);
-                ComputerPlayerMCTS.macroPlayerId = getId();
-                ComputerPlayerMCTS.lastAction = ability.copy();
+                //ComputerPlayerMCTS.macroState = ComputerPlayerMCTS.createCompleteMCTSGame(game);
+                //ComputerPlayerMCTS.macroPlayerId = getId();
+                //ComputerPlayerMCTS.lastAction = ability.copy();
                 this.activateAbility((ActivatedAbility) ability, game);
                 if (ability.isUsesStack()) {
                     usedStack = true;
diff --git a/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/Features.java b/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/Features.java
index fb4df63757..6e1bb42c50 100644
--- a/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/Features.java
+++ b/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/Features.java
@@ -7,7 +7,7 @@ import java.util.*;
 
 /**
  *this hierarchical structure represents the mapping of every possible relevant feature encountered from a game state to
- * an index on a 200000 dimension binary vector. the reduced form of this vector (4000) will be used as input for both a policy and
+ * an index on a 200000 dimension binary vector. the reduced form of this vector (~6000) will be used as input for both a policy and
  * value neural network. To see how game features are mapped look at StateEncoder.java this data structure only handles and stores the
  * mappings
  * @author willwroble
@@ -75,7 +75,7 @@ public class Features  implements Serializable {
         return getSubFeatures(name, true);
     }
     public Features getSubFeatures(String name, boolean passToParent) {
-        //first add as a normal binary feature
+        //added as normal binary feature
         addFeature(name);
 
         int n = occurrences.get(name);
@@ -149,19 +149,6 @@ public class Features  implements Serializable {
         //usually add feature to parent/categories
         if(parent != null && callParent && passToParent) {
             parent.addNumericFeature(name, num);
-            //keep track of numerical sum for parents
-            /*
-            for(int i = 0; i < num; i++) {
-                parent.addFeature(name + "_SUM", false);
-            }
-            for(Features c : categories) {
-                c.addFeature(name);
-                //keep track of numerical sum for categories
-                for(int i = 0; i < num; i++) {
-                    c.addFeature(name + "_SUM", false);
-                }
-            }
-            */
         }
 
         //also adds copy to number right below this one which will recursively increment the occurrences of each lesser feature
diff --git a/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/NeuralNetEvaluator.java b/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/NeuralNetEvaluator.java
index 317d4e93de..d9f0a8a722 100644
--- a/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/NeuralNetEvaluator.java
+++ b/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/NeuralNetEvaluator.java
@@ -108,7 +108,9 @@ public class NeuralNetEvaluator implements AutoCloseable {
                 throw new RuntimeException("Missing '" + onnxValueOutputName + "' output from ONNX model");
             }
             OnnxTensor valueTensor = (OnnxTensor) optV.get();
-            float value = ((float[][]) valueTensor.getValue())[0][0]; // Assumes value output shape [1, 1]
+            float[] valueArray = (float[]) valueTensor.getValue();
+            // Access the first (and only) element of the 1D array.
+            float value = valueArray[0];
 
             return new InferenceResult(policy, value);
         } catch (OrtException e) {
diff --git a/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/ReplayBuffer.java b/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/ReplayBuffer.java
index 903c6ad879..1b7b322fa7 100644
--- a/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/ReplayBuffer.java
+++ b/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/ReplayBuffer.java
@@ -1,6 +1,8 @@
-package org.mage.test.AI.RL;
+package mage.player.ai;
 
+import mage.game.Game;
 import mage.game.GameState;
+import mage.util.RandomUtil;
 
 import java.io.Serializable;
 import java.util.*;
@@ -13,7 +15,7 @@ import java.util.concurrent.ConcurrentLinkedDeque;
  */
 public class ReplayBuffer implements Serializable {
     private static final long serialVersionUID = 1L; // For serialization
-    private final Deque<GameState> buffer;
+    private final Deque<Game> buffer;
     private final int capacity;
     private final Random random = new Random();
 
@@ -29,7 +31,7 @@ public class ReplayBuffer implements Serializable {
      *
      * @param state The GameState to add.
      */
-    public synchronized void add(GameState state) {
+    public synchronized void add(Game state) {
         if (buffer.size() >= capacity) {
             buffer.pollFirst(); // Remove the oldest element
         }
@@ -41,8 +43,8 @@ public class ReplayBuffer implements Serializable {
      *
      * @param states The collection of states from a completed game.
      */
-    public void addAll(Collection<GameState> states) {
-        for (GameState state : states) {
+    public void addAll(Collection<Game> states) {
+        for (Game state : states) {
             add(state); // Use the synchronized add method
         }
     }
@@ -53,16 +55,16 @@ public class ReplayBuffer implements Serializable {
      * @param batchSize The number of states to sample.
      * @return A list containing the sampled GameStates. Returns an empty list if the buffer is empty.
      */
-    public List<GameState> sample(int batchSize) {
+    public List<Game> sample(int batchSize) {
         // Create a temporary list for random access, as Deque doesn't support get(index)
-        List<GameState> tempList = new ArrayList<>(buffer);
+        List<Game> tempList = new ArrayList<>(buffer);
         if (tempList.isEmpty()) {
             return new ArrayList<>();
         }
 
-        List<GameState> sampleBatch = new ArrayList<>();
+        List<Game> sampleBatch = new ArrayList<>();
         for (int i = 0; i < batchSize; i++) {
-            int randomIndex = random.nextInt(tempList.size());
+            int randomIndex = RandomUtil.nextInt(tempList.size());
             sampleBatch.add(tempList.get(randomIndex));
         }
         return sampleBatch;
diff --git a/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/StateEncoder.java b/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/StateEncoder.java
index 1446d7f5d0..d96351032d 100644
--- a/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/StateEncoder.java
+++ b/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/StateEncoder.java
@@ -36,7 +36,6 @@ import java.util.*;
 public class StateEncoder {
     public static int indexCount;
     public static int reducedIndexCount;
-    private int originalVectorSize;
     private Features features;
     public static Set<Integer> featureVector = new HashSet<>();
     public UUID opponentID;
@@ -47,9 +46,6 @@ public class StateEncoder {
     public List<Boolean> activeStates = new ArrayList<>();
 
     public List<Double> stateScores = new ArrayList<>();
-    public static final int COMPRESSED_VECTOR_SIZE = 4000;
-    public static final int GLOBAL_FEATURE_COUNT = 100000;
-    public int initialSize = 0;
     public int initialRawSize = 0;//original max index
     public int mappingVersion = 0;
 
@@ -58,8 +54,7 @@ public class StateEncoder {
     public StateEncoder() {
         //using statics for convenience for now
         indexCount = 0;
-        reducedIndexCount = 1; //pending features map to zero
-        originalVectorSize = 0;
+        reducedIndexCount = 1;
         features = new Features();
         ignoreList = new HashSet<>();
     }
@@ -300,8 +295,14 @@ public class StateEncoder {
 
         //now do hand (cards are face down so only keep count of number of cards
         // TODO: keep track of face up cards and exile
-        Cards hand = myPlayer.getHand();
-        features.addNumericFeature("OpponentCardsInHand", hand.size());
+        if(opponentID==game.getPriorityPlayerId()) { //invert perspective
+            Cards hand = myPlayer.getHand();
+            Features handFeatures = features.getSubFeatures("Hand");
+            processHand(hand, game, handFeatures);
+        } else {
+            Cards hand = myPlayer.getHand();
+            features.addNumericFeature("OpponentCardsInHand", hand.size());
+        }
 
     }
     public void processManaPool(ManaPool mp, Game game,  Features f) {
@@ -313,7 +314,35 @@ public class StateEncoder {
         f.addNumericFeature("ColorlessMana", mp.getColorless());
         //TODO: deal with conditional mana
     }
-    public void processState(Game game) {
+    public void processPhase(Game game) {
+        switch (game.getTurnStepType()) {
+            case UPKEEP:
+                features.addFeature("Upkeep");
+            case DRAW:
+                features.addFeature("Draw");
+            case PRECOMBAT_MAIN:
+                features.addFeature("PreCombatMain");
+            case BEGIN_COMBAT:
+                features.addFeature("BeginCombat");
+            case DECLARE_ATTACKERS:
+                features.addFeature("DeclareAttackers");
+            case DECLARE_BLOCKERS:
+                features.addFeature("DeclareBlockers");
+            case FIRST_COMBAT_DAMAGE:
+                features.addFeature("FirstCombatDamage");
+            case COMBAT_DAMAGE:
+                features.addFeature("CombatDamage");
+            case END_COMBAT:
+                features.addFeature("EndCombat");
+            case POSTCOMBAT_MAIN:
+                features.addFeature("PostCombatMain");
+            case END_TURN:
+                features.addFeature("EndTurn");
+            case CLEANUP:
+               features.addFeature("Cleanup");
+        }
+    }
+    public synchronized void processState(Game game) {
         features.stateRefresh();
         featureVector.clear();
 
@@ -323,6 +352,8 @@ public class StateEncoder {
         features.addFeature(game.getPhase().getType().name());
         if(game.isActivePlayer(myPlayerID)) features.addFeature("IsActivePlayer");
         if(game.getPriorityPlayerId()==myPlayerID) features.addFeature("IsPriorityPlayer");
+        //TODO: *IMPORTANT* ADD PHASE INFO
+        processPhase(game);
         features.addNumericFeature("LifeTotal", myPlayer.getLife());
         if(myPlayer.canPlayLand()) features.addFeature("CanPlayLand"); //use features.addFeature(myPlayer.canPlayLand())
 
@@ -345,10 +376,14 @@ public class StateEncoder {
         processGraveyard(gy, game, gyFeatures);
 
         //now do hand
-        Cards hand = myPlayer.getHand();
-        Features handFeatures = features.getSubFeatures("Hand");
-        processHand(hand, game, handFeatures);
-
+        if(opponentID==game.getPriorityPlayerId()) { //invert perspective
+            Cards hand = myPlayer.getHand();
+            features.addNumericFeature("OpponentCardsInHand", hand.size());
+        } else {
+            Cards hand = myPlayer.getHand();
+            Features handFeatures = features.getSubFeatures("Hand");
+            processHand(hand, game, handFeatures);
+        }
         //TODO: add exile
 
         //lastly do opponent
@@ -370,56 +405,6 @@ public class StateEncoder {
         macroStateVectors.add(new HashSet<>(featureVector));
         //activeStates.add(game.getActivePlayerId() == myPlayerID);
     }
-
-    /*
-    public void updateReducedVector() {
-        //map normal features
-        for(int i = 0; i < originalVectorSize; i++) {
-            if(!featureVector[i]) continue;
-            int reducedIndex = rawToReduced[i]; //pending features map to zero
-            reducedFeatureVector[reducedIndex] = true;
-        }
-        //update matrix for each pending feature
-        for (int f : pendingFeatures.keySet()) {
-            boolean[][] m = pendingFeatures.get(f);
-            boolean allIndependent = true;
-            for(int i = 1; i < m.length; i++) {
-                if(rawToReduced[i+f] != 0) continue;//only care to check un finalized features
-                boolean isIndependent = true;
-                for(int j = 0; j < m.length; j++) {
-                    m[i][j] = (featureVector[i+f] != featureVector[j+f]) || m[i][j]; //don't change if true
-                    if(rawToReduced[j+f] != 0 && !m[i][j]) {//compared to feature is finalized and they aren't independent
-                        isIndependent = false;
-                    }
-                }
-                if(isIndependent) {
-                    //finalize feature if independent (and hasn't been finalized)
-                    System.out.printf("pending feature at raw index %d has been finalized at reduced index %d\n", i+f, reducedIndexCount);
-                    rawToReduced[i+f] = reducedIndexCount;
-                    reducedFeatureVector[reducedIndexCount++] = featureVector[i+f]; //can be added silently (feature itself didn't fire)
-                } else {
-                    allIndependent = false;
-                }
-            }
-            if(allIndependent) {
-                pendingFeatures.remove(f);
-                System.out.printf("entire pending batch from %d has been successfully finalized\n", f);
-            }
-        }
-        //matrix for batch of new features
-        int batchSize = indexCount - originalVectorSize;
-        boolean[][] occurrenceMatrix = new boolean[batchSize][batchSize]; //maps if 2 features occurred independently for each pair
-        if(batchSize > 0) {
-            //add first new feature to reduced vector
-            System.out.printf("new reduced feature at raw index %d has been finalized at reduced index %d representing a batch of %d new features\n", originalVectorSize, reducedIndexCount, batchSize);
-            rawToReduced[originalVectorSize] = reducedIndexCount;
-            reducedFeatureVector[reducedIndexCount++] = true;
-            pendingFeatures.put(originalVectorSize, occurrenceMatrix); //pending features are stored in by their first feature in batch
-
-        }
-        //lastly update original size
-        originalVectorSize = indexCount;
-    }
     /**
      * Takes an array of raw indices, filters out those present in the ignoreList,
      * and returns a new array of the remaining indices.
@@ -452,7 +437,11 @@ public class StateEncoder {
         }
         return filteredIndicesSet;
     }
+    public synchronized int[] getFinalActiveGlobalIndicesArray() {
+        Set<Integer> out1 = getCompressedVector(featureVector);
+        return out1.stream().mapToInt(Integer::intValue).toArray();
 
+    }
     // Persist the persistent feature mapping
     public void persistMapping(String filename) throws IOException {
         features.globalIndexCount = indexCount;
@@ -469,7 +458,6 @@ public class StateEncoder {
         ignoreList = new HashSet<>(features.ignoreList);
         rawToReduced = new HashMap<>(features.rawToReduced);
         mappingVersion = features.version+1;
-        initialSize = indexCount - ignoreList.size();
         initialRawSize = indexCount;
     }
 }
diff --git a/Mage.Server.Plugins/Mage.Player.AI/src/main/java/mage/player/ai/ComputerPlayer.java b/Mage.Server.Plugins/Mage.Player.AI/src/main/java/mage/player/ai/ComputerPlayer.java
index 7c8b9e0e33..0ed2eac0a1 100644
--- a/Mage.Server.Plugins/Mage.Player.AI/src/main/java/mage/player/ai/ComputerPlayer.java
+++ b/Mage.Server.Plugins/Mage.Player.AI/src/main/java/mage/player/ai/ComputerPlayer.java
@@ -143,7 +143,7 @@ public class ComputerPlayer extends PlayerImpl {
 
     @Override
     public boolean choose(Outcome outcome, Target target, Ability source, Game game, Map<String, Serializable> options) {
-        if(PRINT_DECISION_FALLBACKS && name.equals("PlayerA")) System.out.println("choose: " + source.toString());
+        if(PRINT_DECISION_FALLBACKS && name.equals("PlayerA")) System.out.println("choose: ");
         if (log.isDebugEnabled()) {
             log.debug("choose: " + outcome.toString() + ':' + target.toString());
         }
@@ -2156,15 +2156,18 @@ public class ComputerPlayer extends PlayerImpl {
         // spell modes simulated by AI, see addModeOptions
         // trigger modes chooses here
         // TODO: add AI support to select best modes, current code uses first valid mode
+        List<Mode> allModes = modes.getAvailableModes(source, game);
+        //Collections.shuffle(allModes);
         AvailableMode:
-        for (Mode mode : modes.getAvailableModes(source, game)) {
+        for (Mode mode : allModes) {
             for (UUID selectedModeId : modes.getSelectedModes()) {
                 Mode selectedMode = modes.get(selectedModeId);
                 if (selectedMode.getId().equals(mode.getId())) {
                     continue AvailableMode;
                 }
             }
-            if (mode.getTargets().canChoose(source.getControllerId(), source, game)) { // and where targets are available
+            if (mode.getTargets().canChoose(source.getControllerId(), source, game)) {
+                // and where targets are available
                 return mode;
             }
         }
diff --git a/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/ChooseTargetNextAction.java b/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/ChooseTargetNextAction.java
index dcc2fbcf0b..8a38280322 100644
--- a/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/ChooseTargetNextAction.java
+++ b/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/ChooseTargetNextAction.java
@@ -12,23 +12,26 @@ public class ChooseTargetNextAction implements MCTSNodeNextAction {
     @Override
     public List<MCTSNode> performNextAction(MCTSNode node, MCTSPlayer player, Game game, String fullStateValue) {
         List<MCTSNode> children = new ArrayList<>();
-
         // Get targets for the current ability
         for (Set<UUID> targets: player.chooseTargetOptions) {
             //create node to add option to
-            Game sim = node.macroState.createSimulationForAI();
+            Game sim = game.getLastPriority().createSimulationForAI();
             MCTSPlayer simPlayer2 = (MCTSPlayer) sim.getPlayer(player.getId());
-            MCTSPlayer simPlayer1 = (MCTSPlayer) sim.getPlayer(node.macroPlayerId);
-            simPlayer2.chooseTargetAction = new ArrayList<>(node.chooseTargetAction);
+            MCTSPlayer simPlayer1 = (MCTSPlayer) sim.getPlayer(game.getLastPriorityPlayerId());
+            simPlayer2.copyDialogues(player); //copy previous micro decisions
             simPlayer2.chooseTargetAction.add(targets);
-            simPlayer1.activateAbility((ActivatedAbility) node.getAction(), sim);
+            simPlayer1.activateAbility((ActivatedAbility) node.getAction().copy(), sim);
             sim.resume();
-            MCTSNode newNode = new MCTSNode(node, sim, node.getAction());
-            newNode.combat = node.combat;
+            MCTSNode newNode = new MCTSNode(node, sim, node.getAction().copy());
             newNode.chooseTargetAction = new ArrayList<>(node.chooseTargetAction);
             newNode.chooseTargetAction.add(targets);
             children.add(newNode);
         }
         return children;
     }
+
+    @Override
+    public void applyAction(MCTSNode node, MCTSPlayer player, Game game) {
+        //do nothing for now
+    }
 }
diff --git a/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/ChooseTriggeredAbilityNextAction.java b/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/ChooseTriggeredAbilityNextAction.java
index 7ce7689978..e873388c6c 100644
--- a/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/ChooseTriggeredAbilityNextAction.java
+++ b/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/ChooseTriggeredAbilityNextAction.java
@@ -1,32 +1,32 @@
 package mage.player.ai;
 
-import mage.abilities.Ability;
 import mage.abilities.ActivatedAbility;
 import mage.game.Game;
-import mage.target.Target;
 
-import java.util.*;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Set;
+import java.util.UUID;
 
-public class ChooseTargetNextAction implements MCTSNodeNextAction {
+public class ChooseTriggeredAbilityNextAction implements MCTSNodeNextAction {
 
     @Override
     public List<MCTSNode> performNextAction(MCTSNode node, MCTSPlayer player, Game game, String fullStateValue) {
         List<MCTSNode> children = new ArrayList<>();
         // Get targets for the current ability
-        for (Set<UUID> targets: player.chooseTargetOptions) {
+        for (Set<UUID> targets: player.chooseTriggeredOptions) {
             //create node to add option to
-            Game sim = node.macroState.createSimulationForAI();
+            Game sim = game.getLastPriority().createSimulationForAI();
             MCTSPlayer simPlayer2 = (MCTSPlayer) sim.getPlayer(player.getId());
-            MCTSPlayer simPlayer1 = (MCTSPlayer) sim.getPlayer(node.macroPlayerId);
-            simPlayer2.chooseTargetAction = new ArrayList<>(node.chooseTargetAction);
-            simPlayer2.chooseTargetAction.add(targets);
+            MCTSPlayer simPlayer1 = (MCTSPlayer) sim.getPlayer(game.getLastPriorityPlayerId());
+            simPlayer2.copyDialogues(player);
+            simPlayer2.chooseTriggeredAction.add(targets);
             simPlayer1.activateAbility((ActivatedAbility) node.getAction().copy(), sim);
-            //MCTSNextActionFactory.strategyMap.get(simPlayer1.getNextAction()).applyAction(node,  simPlayer1, sim);
             sim.resume();
             MCTSNode newNode = new MCTSNode(node, sim, node.getAction().copy());
             newNode.combat = node.combat;
-            newNode.chooseTargetAction = new ArrayList<>(node.chooseTargetAction);
-            newNode.chooseTargetAction.add(targets);
+            newNode.chooseTriggeredAction = new ArrayList<>(node.chooseTriggeredAction);
+            newNode.chooseTriggeredAction.add(targets);
             children.add(newNode);
         }
         return children;
diff --git a/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/ComputerPlayerMCTS.java b/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/ComputerPlayerMCTS.java
index 5e697d29f4..10d439bfc4 100644
--- a/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/ComputerPlayerMCTS.java
+++ b/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/ComputerPlayerMCTS.java
@@ -18,6 +18,7 @@ import mage.util.ThreadUtils;
 import mage.util.XmageThreadFactory;
 import org.apache.log4j.Logger;
 
+import java.io.Serializable;
 import java.util.*;
 import java.util.concurrent.*;
 
@@ -31,21 +32,21 @@ public class ComputerPlayerMCTS extends ComputerPlayer {
     protected static final double THINK_TIME_MULTIPLIER = 1.0;
     protected static final boolean USE_MULTIPLE_THREADS = true;
 
-    protected transient MCTSNode root;
+    public transient MCTSNode root;
     protected int maxThinkTime;
     protected static final Logger logger = Logger.getLogger(ComputerPlayerMCTS.class);
-    protected int poolSize;
+    public int poolSize = 8;
     public Set<Set<UUID>> chooseTargetOptions = new HashSet<>();
     public ArrayList<Set<UUID>> chosenChooseTargetActions = new ArrayList<>();
-    protected ExecutorService threadPoolSimulations = null;
-    public static Game macroState;
-    public static UUID macroPlayerId;
-    public static Ability lastAction;
+    protected transient ExecutorService threadPoolSimulations = null;
+    //public static Game macroState;
+    //public static UUID macroPlayerId;
+    //public static Ability lastAction;
     public ComputerPlayerMCTS(String name, RangeOfInfluence range, int skill) {
         super(name, range);
         human = false;
         maxThinkTime = (int) (skill * THINK_TIME_MULTIPLIER);
-        poolSize = Runtime.getRuntime().availableProcessors();
+        //poolSize = 64;//Runtime.getRuntime().availableProcessors();
     }
 
     protected ComputerPlayerMCTS(UUID id) {
@@ -88,8 +89,6 @@ public class ComputerPlayerMCTS extends ComputerPlayer {
             return false;
         logLife(game);
         logger.info(game.getTurn().getValue(game.getTurnNum())+"choose action:" + root.getAction() + " success ratio: " + root.getWinRatio());
-        macroState = createCompleteMCTSGame(game);
-        macroPlayerId = getId();
         return true;
     }
 
@@ -98,7 +97,6 @@ public class ComputerPlayerMCTS extends ComputerPlayer {
             Game sim = createMCTSGame(game);
             MCTSPlayer player = (MCTSPlayer) sim.getPlayer(playerId);
             player.setNextAction(action);
-            player.isRoot = true;
             root = new MCTSNode(playerId, sim);
             player.chooseTargetOptions = chooseTargetOptions;
             player.chooseTargetAction = new ArrayList<>(chosenChooseTargetActions);
@@ -108,7 +106,6 @@ public class ComputerPlayerMCTS extends ComputerPlayer {
         applyMCTS(game, action);
         if (root != null && root.bestChild() != null) {
             root = root.bestChild();
-            lastAction = root.action;
             root.emancipate();
         }
     }
@@ -172,11 +169,6 @@ public class ComputerPlayerMCTS extends ComputerPlayer {
     }
     @Override
     public boolean chooseTarget(Outcome outcome, Target target, Ability source, Game game) {
-        if(false) return super.chooseTarget(outcome, target, source, game);
-//        if(root == null || root.children.isEmpty()) {
-//            System.out.println("chooseTarget: falling back");
-//            return super.chooseTarget(outcome, target, source, game);
-//        }
         Set<UUID> possible = target.possibleTargets(getId(), game);
         chooseTargetOptions.clear();
         MCTSPlayer.getAllPossible(chooseTargetOptions, possible, target.copy(), source, game, getId());
@@ -193,7 +185,16 @@ public class ComputerPlayerMCTS extends ComputerPlayer {
         }
         return target.isChosen(game);
     }
-
+    @Override
+    public boolean choose(Outcome outcome, Target target, Ability source, Game game, Map<String, Serializable> options) {
+        if(game.getTurnNum() > 1) {
+            //reroute to mcts simulator
+            return chooseTarget(outcome, target, source, game);
+        } else {
+            //reroute to default
+            return super.choose(outcome, target, source, game, options);
+        }
+    }
     protected long totalThinkTime = 0;
     protected long totalSimulations = 0;
 
@@ -356,6 +357,8 @@ public class ComputerPlayerMCTS extends ComputerPlayer {
                 newPlayer.getLibrary().shuffle();
                 for (int i = 0; i < handSize; i++) {
                     Card card = newPlayer.getLibrary().drawFromTop(mcts);
+                    assert (newPlayer.getLibrary().size() != 0);
+                    assert (card != null);
                     card.setZone(Zone.HAND, mcts);
                     newPlayer.getHand().add(card);
                 }
@@ -364,6 +367,7 @@ public class ComputerPlayerMCTS extends ComputerPlayer {
             }
             mcts.getState().getPlayers().put(copyPlayer.getId(), newPlayer);
         }
+        //mcts.setLastPriority(createCompleteMCTSGame(game.getLastPriority()));
         mcts.resume();
         return mcts;
     }
diff --git a/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/MCTSNextActionFactory.java b/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/MCTSNextActionFactory.java
index be0730154d..db4c83c8b3 100644
--- a/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/MCTSNextActionFactory.java
+++ b/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/MCTSNextActionFactory.java
@@ -3,13 +3,14 @@ package mage.player.ai;
 import java.util.HashMap;
 
 public class MCTSNextActionFactory {
-    private static final HashMap<MCTSPlayer.NextAction, MCTSNodeNextAction> strategyMap = new HashMap<>();
+    public static final HashMap<MCTSPlayer.NextAction, MCTSNodeNextAction> strategyMap = new HashMap<>();
 
     static {
         strategyMap.put(MCTSPlayer.NextAction.PRIORITY, new PriorityNextAction());
         strategyMap.put(MCTSPlayer.NextAction.SELECT_BLOCKERS, new SelectBlockersNextAction());
         strategyMap.put(MCTSPlayer.NextAction.SELECT_ATTACKERS, new SelectAttackersNextAction());
         strategyMap.put(MCTSPlayer.NextAction.CHOOSE_TARGET, new ChooseTargetNextAction());
+        strategyMap.put(MCTSPlayer.NextAction.CHOOSE_TRIGGERED_ABILITY, new ChooseTriggeredAbilityNextAction());
     }
 
     public static MCTSNodeNextAction createNextAction(MCTSPlayer.NextAction nextAction) {
diff --git a/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/MCTSNode.java b/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/MCTSNode.java
index aa4f867d67..78c22e965b 100644
--- a/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/MCTSNode.java
+++ b/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/MCTSNode.java
@@ -12,6 +12,7 @@ import mage.abilities.PlayLandAbility;
 import mage.abilities.common.PassAbility;
 import mage.cards.Card;
 import mage.game.Game;
+import mage.game.GameState;
 import mage.game.combat.Combat;
 import mage.game.turn.Step.StepPart;
 import mage.players.Player;
@@ -45,13 +46,13 @@ public class MCTSNode {
     public final List<MCTSNode> children = new ArrayList<>();
     public Ability action;
     public List<Set<UUID>> chooseTargetAction = new ArrayList<>();
-    private Game game;
-    public Game macroState;
+    public List<Set<UUID>> chooseTriggeredAction = new ArrayList<>();
+    private Game game;//only contains shared game
+
     public Combat combat;
     private final String stateValue;
     private final String fullStateValue;
     public UUID playerId;
-    public UUID macroPlayerId;
     private boolean terminal = false;
     public UUID targetPlayer;
     public int depth = 1;
@@ -67,9 +68,7 @@ public class MCTSNode {
         this.fullStateValue = game.getState().getValue(true, game);
         this.stackIsEmpty = game.getStack().isEmpty();
         this.terminal = game.checkIfGameIsOver();
-        this.macroState = ComputerPlayerMCTS.macroState;
-        this.macroPlayerId = ComputerPlayerMCTS.macroPlayerId;
-        this.action = ComputerPlayerMCTS.lastAction;
+        this.action = game.getLastPriorityAction();
         setPlayer();
         nodeCount = 1;
 //        logger.info(this.stateValue);
@@ -84,8 +83,6 @@ public class MCTSNode {
         this.terminal = game.checkIfGameIsOver();
         this.parent = parent;
         this.action = action;
-        this.macroState = parent.macroState;
-        this.macroPlayerId = parent.playerId;
 
         setPlayer();
         nodeCount++;
@@ -95,19 +92,19 @@ public class MCTSNode {
     protected MCTSNode(MCTSNode parent, Game game, Combat combat) {
         this.targetPlayer = parent.targetPlayer;
         this.game = game;
+        //this.gameState = game.getState().copy();
         this.combat = combat;
         this.stateValue = game.getState().getValue(game, targetPlayer);
         this.fullStateValue = game.getState().getValue(true, game);
         this.stackIsEmpty = game.getStack().isEmpty();
         this.terminal = game.checkIfGameIsOver();
         this.parent = parent;
-        this.macroState = parent.macroState;
-        this.macroPlayerId = parent.playerId;
 
         setPlayer();
         nodeCount++;
 //        logger.info(this.stateValue);
     }
+    //dont use
     protected MCTSNode(MCTSNode node) {
         combat = null; action = null; game = null;
         if(node.combat != null) combat = node.combat.copy();
@@ -135,15 +132,22 @@ public class MCTSNode {
 
     }
     private void setPlayer() {
-        if (game.getStep().getStepPart() == StepPart.PRIORITY) {
-            playerId = game.getPriorityPlayerId();
-        } else {
-            if (game.getTurnStepType() == PhaseStep.DECLARE_BLOCKERS) {
-                playerId = game.getCombat().getDefenders().iterator().next();
-            } else {
-                playerId = game.getActivePlayerId();
-            }
+        //System.out.println("this happening");
+        for (Player p : game.getPlayers().values()) {
+            MCTSPlayer mctsP = (MCTSPlayer) p;
+            if(mctsP.lastToAct) playerId = p.getId();
+            return;
         }
+        assert (false);
+//        if (game.getStep().getStepPart() == StepPart.PRIORITY) {
+//            playerId = game.getPriorityPlayerId();
+//        } else {
+//            if (game.getTurnStepType() == PhaseStep.DECLARE_BLOCKERS) {
+//                playerId = game.getCombat().getDefenders().iterator().next();
+//            } else {
+//                playerId = game.getActivePlayerId();
+//            }
+//        }
     }
     public MCTSNode select(UUID targetPlayerId) {
         // Single‚Äêchild shortcut
@@ -247,7 +251,6 @@ public class MCTSNode {
             }
             if (!children.isEmpty()) {
                 game = null;
-                macroState = null;
             }
         }
     }
@@ -436,6 +439,7 @@ public class MCTSNode {
             MCTSNode current = queue.remove();
             if (current.stateValue.equals(state) && current.chooseTargetAction.equals(chosen))
                 return current;
+            //System.out.printf("MISMATCH: %s\n %s\n",current.stateValue, state);
             for (MCTSNode child: current.children) {
                 queue.add(child);
             }
@@ -474,7 +478,7 @@ public class MCTSNode {
                 for (MCTSNode child : tempChildren) {
                     if (mergeChild.action != null && child.action != null) {
                         if (mergeChild.action.toString().equals(child.action.toString())) {
-                            if (!mergeChild.stateValue.equals(child.stateValue) || !merge.chooseTargetAction.equals(chooseTargetAction)) {
+                            if (!mergeChild.stateValue.equals(child.stateValue) || !mergeChild.chooseTargetAction.equals(child.chooseTargetAction)) {
                                 // Record mismatch if needed; skip merge.
                             } else {
                                 // Recursively merge the matching child.
@@ -485,8 +489,9 @@ public class MCTSNode {
                         }
                     } else if (mergeChild.combat != null && child.combat != null &&
                             mergeChild.combat.getValue().equals(child.combat.getValue())) {
-                        if (!mergeChild.stateValue.equals(child.stateValue) || !merge.chooseTargetAction.equals(chooseTargetAction)) {
+                        if (!mergeChild.stateValue.equals(child.stateValue) || !mergeChild.chooseTargetAction.equals(child.chooseTargetAction)) {
                             // Record mismatch if needed.
+
                         } else {
                             child.merge(mergeChild);
                             merged = true;
@@ -625,32 +630,10 @@ public class MCTSNode {
         if(children.isEmpty()) return 0;
         return visits/children.size();
     }
-    public int maxVisits() {
-        int max = -1;
-        for(MCTSNode n : children) {
-            if(n.visits > max) {
-                max = n.visits;
-            }
-        }
-        return max;
-    }
-    public int diffVisits() {
-        int max = -1;
-        int max2 = -1;//second highest
-        for(MCTSNode n : children) {
-            if(n.visits > max) {
-                max2 = max;
-                max = n.visits;
-            } else if(n.visits > max2) {
-                max2 = n.visits;
-            }
-        }
-        return max-max2;
-    }
     public Game getGame() {
+        //game.getState().restore(gameState);
         return game;
     }
-
     public static void logHitMiss() {
         if (USE_ACTION_CACHE) {
             StringBuilder sb = new StringBuilder();
diff --git a/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/MCTSNodeNextAction.java b/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/MCTSNodeNextAction.java
index befa16c515..494912df8a 100644
--- a/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/MCTSNodeNextAction.java
+++ b/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/MCTSNodeNextAction.java
@@ -6,4 +6,5 @@ import java.util.List;
 
 public interface MCTSNodeNextAction {
     List<MCTSNode> performNextAction(MCTSNode node, MCTSPlayer player, Game game, String fullStateValue);
+    void applyAction(MCTSNode node, MCTSPlayer player, Game game);
 }
diff --git a/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/MCTSPlayer.java b/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/MCTSPlayer.java
index 8d3f1dc232..a2a7bce9aa 100644
--- a/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/MCTSPlayer.java
+++ b/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/MCTSPlayer.java
@@ -6,6 +6,7 @@ import mage.Mana;
 import mage.abilities.Ability;
 import mage.abilities.ActivatedAbility;
 import mage.abilities.SpellAbility;
+import mage.abilities.TriggeredAbility;
 import mage.abilities.common.PassAbility;
 import mage.abilities.costs.Costs;
 import mage.abilities.costs.mana.GenericManaCost;
@@ -24,6 +25,7 @@ import mage.target.Target;
 import mage.target.TargetCard;
 import org.apache.log4j.Logger;
 
+import java.io.Serializable;
 import java.util.*;
 import java.util.concurrent.ConcurrentLinkedQueue;
 
@@ -37,19 +39,20 @@ import java.util.concurrent.ConcurrentLinkedQueue;
  */
 public class MCTSPlayer extends ComputerPlayer {
 
-
+    public boolean lastToAct =  false;
     private NextAction nextAction;
-    public boolean isRoot = false;
     public long dirichletSeed = 0;
     public Set<Set<UUID>> chooseTargetOptions = new HashSet<>();
     public List<Set<UUID>> chooseTargetAction = new ArrayList<>();
+    public Set<Set<UUID>> chooseTriggeredOptions = new HashSet<>();
+    public List<Set<UUID>> chooseTriggeredAction = new ArrayList<>();
 
     private int chooseTargetCount = 0;
 
 
 
     public enum NextAction {
-                PRIORITY, SELECT_ATTACKERS, SELECT_BLOCKERS, CHOOSE_TARGET
+                PRIORITY, SELECT_ATTACKERS, SELECT_BLOCKERS, CHOOSE_TARGET, CHOOSE_TRIGGERED_ABILITY
     }
 
     public MCTSPlayer(UUID id) {
@@ -59,6 +62,7 @@ public class MCTSPlayer extends ComputerPlayer {
     public MCTSPlayer(final MCTSPlayer player) {
         super(player);
         this.nextAction = player.nextAction;
+        this.lastToAct = player.lastToAct;
     }
 
     @Override
@@ -66,6 +70,11 @@ public class MCTSPlayer extends ComputerPlayer {
         return new MCTSPlayer(this);
     }
 
+    public void copyDialogues(MCTSPlayer player) {
+        this.chooseTargetAction = new ArrayList<>(player.chooseTargetAction);
+        this.chooseTriggeredAction = new ArrayList<>(player.chooseTriggeredAction);
+    }
+
     protected List<ActivatedAbility> getPlayableAbilities(Game game) {
         List<ActivatedAbility> playables = getPlayable(game, true);
         ManaOptions availableMana = getManaAvailable(game);
@@ -208,6 +217,11 @@ public class MCTSPlayer extends ComputerPlayer {
     @Override
     public boolean priority(Game game) {
         game.pause();
+        for(Player p : game.getPlayers().values()) {//if either player already acted, respect that.
+            MCTSPlayer mctsP = (MCTSPlayer) p;
+            if(mctsP.lastToAct) return false;
+        }
+        lastToAct = true;
         nextAction = NextAction.PRIORITY;
         return false;
     }
@@ -215,12 +229,14 @@ public class MCTSPlayer extends ComputerPlayer {
     @Override
     public void selectAttackers(Game game, UUID attackingPlayerId) {
         game.pause();
+        lastToAct = true;
         nextAction = NextAction.SELECT_ATTACKERS;
     }
 
     @Override
     public void selectBlockers(Ability source, Game game, UUID defendingPlayerId) {
         game.pause();
+        lastToAct = true;
         nextAction = NextAction.SELECT_BLOCKERS;
     }
     public static void getAllPossible(Set<Set<UUID>> out, Set<UUID> possible, Target target, Ability source, Game game, UUID myID) {
@@ -240,10 +256,9 @@ public class MCTSPlayer extends ComputerPlayer {
     }
     @Override
     public boolean chooseTarget(Outcome outcome, Target target, Ability source, Game game) {
-        if(false) return super.chooseTarget(outcome, target, source, game);
-        System.out.println("CALLING CHOOSE TARGET");
+        //System.out.println("chooseTarget: " + source.toString());
+        System.out.println("CALLING CHOOSE TARGET: " + (source == null ? "null" : source.toString()));
         if(chooseTargetCount < chooseTargetAction.size()) {
-            System.out.println("is this happening");
             for(UUID id : chooseTargetAction.get(chooseTargetCount)) {
                 if(!target.canTarget(getId(), id, source, game)) continue;
                 target.addTarget(id, source, game);
@@ -256,7 +271,17 @@ public class MCTSPlayer extends ComputerPlayer {
         Set<UUID> possible = target.possibleTargets(getId(), game);
         getAllPossible(chooseTargetOptions, possible, target.copy(), source, game, getId());
         game.pause();
+        for(Player p : game.getPlayers().values()) {//if either player already acted, respect that.
+            MCTSPlayer mctsP = (MCTSPlayer) p;
+            if(mctsP.lastToAct) return super.chooseTarget(outcome, target, source, game);
+        }
+        lastToAct = true;
         nextAction = NextAction.CHOOSE_TARGET;
-        return false;
+        return super.chooseTarget(outcome, target, source, game);
+    }
+    @Override
+    public boolean choose(Outcome outcome, Target target, Ability source, Game game, Map<String, Serializable> options) {
+        //reroute to chooseTarget
+        return chooseTarget(outcome, target, source, game);
     }
 }
diff --git a/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/PriorityNextAction.java b/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/PriorityNextAction.java
index 076a23aa2b..0861c0d9bb 100644
--- a/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/PriorityNextAction.java
+++ b/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/PriorityNextAction.java
@@ -3,6 +3,7 @@ package mage.player.ai;
 import mage.abilities.Ability;
 import mage.abilities.ActivatedAbility;
 import mage.game.Game;
+import mage.game.GameState;
 
 import java.util.ArrayList;
 import java.util.List;
@@ -11,7 +12,6 @@ public class PriorityNextAction implements MCTSNodeNextAction{
 
     @Override
     public List<MCTSNode> performNextAction(MCTSNode node, MCTSPlayer player, Game game, String fullStateValue) {
-        node.macroState = game;
         List<MCTSNode> children = new ArrayList<>();
         List<Ability> abilities;
         if (!MCTSNode.USE_ACTION_CACHE)
@@ -21,12 +21,20 @@ public class PriorityNextAction implements MCTSNodeNextAction{
         for (Ability ability: abilities) {
             Game sim = game.createSimulationForAI();
             MCTSPlayer simPlayer = (MCTSPlayer) sim.getPlayer(player.getId());
-            boolean success = simPlayer.activateAbility((ActivatedAbility)ability, sim);
-            if(!success) continue;//failsafe
+            boolean success = simPlayer.activateAbility((ActivatedAbility)ability.copy(), sim);
+            if(!success) {
+                System.out.println("PRIORITY FAILSAFE TRIGGERED: " + ability.toString());
+                continue;//failsafe
+            }
             sim.resume();
-            children.add(new MCTSNode(node, sim, ability));
+            children.add(new MCTSNode(node, sim, ability.copy()));
         }
 
         return children;
     }
+
+    @Override
+    public void applyAction(MCTSNode node, MCTSPlayer player, Game game) {
+        player.activateAbility((ActivatedAbility) node.getAction(), game);
+    }
 }
diff --git a/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/SelectAttackersNextAction.java b/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/SelectAttackersNextAction.java
index b5f7fcc439..bb1aba9393 100644
--- a/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/SelectAttackersNextAction.java
+++ b/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/SelectAttackersNextAction.java
@@ -4,6 +4,7 @@ import mage.game.Game;
 
 import java.util.ArrayList;
 import java.util.List;
+import java.util.Set;
 import java.util.UUID;
 
 import static mage.player.ai.MCTSNode.getAttacks;
@@ -11,7 +12,6 @@ import static mage.player.ai.MCTSNode.getAttacks;
 public class SelectAttackersNextAction implements MCTSNodeNextAction{
     @Override
     public List<MCTSNode> performNextAction(MCTSNode node, MCTSPlayer player, Game game, String fullStateValue) {
-        node.macroState = game;
         List<MCTSNode> children = new ArrayList<>();
         List<List<UUID>> attacks;
         if (!MCTSNode.USE_ACTION_CACHE)
@@ -31,4 +31,13 @@ public class SelectAttackersNextAction implements MCTSNodeNextAction{
 
         return children;
     }
+
+    @Override
+    public void applyAction(MCTSNode node, MCTSPlayer player, Game game) {
+        UUID defenderId = game.getOpponents(player.getId()).iterator().next();
+        Set<UUID> attack = node.combat.getAttackers();
+        for (UUID attackerId: attack) {
+            player.declareAttacker(attackerId, defenderId, game, false);
+        }
+    }
 }
diff --git a/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/SelectBlockersNextAction.java b/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/SelectBlockersNextAction.java
index a92c7a6f14..a524d92397 100644
--- a/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/SelectBlockersNextAction.java
+++ b/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/SelectBlockersNextAction.java
@@ -12,7 +12,6 @@ import static mage.player.ai.MCTSNode.getBlocks;
 public class SelectBlockersNextAction implements MCTSNodeNextAction{
     @Override
     public List<MCTSNode> performNextAction(MCTSNode node, MCTSPlayer player, Game game, String fullStateValue) {
-        node.macroState = game;
         List<MCTSNode> children = new ArrayList<>();
         List<List<List<UUID>>> blocks;
         if (!MCTSNode.USE_ACTION_CACHE)
@@ -24,6 +23,7 @@ public class SelectBlockersNextAction implements MCTSNodeNextAction{
             MCTSPlayer simPlayer = (MCTSPlayer) sim.getPlayer(player.getId());
             List<CombatGroup> groups = sim.getCombat().getGroups();
             for (int i = 0; i < groups.size(); i++) {
+                if(groups.get(i).getAttackers().isEmpty()) continue;//failsafe
                 if (i < block.size()) {
                     for (UUID blockerId : block.get(i)) {
                         simPlayer.declareBlocker(simPlayer.getId(), blockerId, groups.get(i).getAttackers().get(0), sim);
@@ -36,4 +36,18 @@ public class SelectBlockersNextAction implements MCTSNodeNextAction{
 
         return children;
     }
+
+    @Override
+    public void applyAction(MCTSNode node, MCTSPlayer player, Game game) {
+        List<CombatGroup> groups = game.getCombat().getGroups();
+        List<CombatGroup> block = node.combat.getGroups();
+        for (int i = 0; i < groups.size(); i++) {
+            if(groups.get(i).getAttackers().isEmpty()) continue;//failsafe
+            if (i < block.size()) {
+                for (UUID blockerId : block.get(i).getBlockers()) {
+                    player.declareBlocker(player.getId(), blockerId, groups.get(i).getAttackers().get(0), game);
+                }
+            }
+        }
+    }
 }
diff --git a/Mage.Tests/features_mapping.ser b/Mage.Tests/features_mapping.ser
index 3f3d2b16ed..c99685f0f0 100644
Binary files a/Mage.Tests/features_mapping.ser and b/Mage.Tests/features_mapping.ser differ
diff --git a/Mage.Tests/src/test/java/org/mage/test/AI/RL/GenerateMappings.java b/Mage.Tests/src/test/java/org/mage/test/AI/RL/GenerateMappings.java
index 1dde5c0a0f..9b7131649e 100644
--- a/Mage.Tests/src/test/java/org/mage/test/AI/RL/GenerateMappings.java
+++ b/Mage.Tests/src/test/java/org/mage/test/AI/RL/GenerateMappings.java
@@ -23,29 +23,8 @@ import java.nio.file.Paths;
 import java.util.*;
 
 public class GenerateMappings extends MinimaxVectorExtractionTests {
-    private String deckNameA = "UWTempo.dck"; //simplegreen, UWTempo
-    private String deckNameB = "simplegreen.dck";
-    //private StateEncoder encoder;
-    private int seed;
-    //private Set<Integer> ignore;
-    //private Map<String, Integer> actions;
-    // File where the persistent mapping is stored
-    private static final String MAPPING_FILE = "features_mapping.ser";
-    private static final String ACTIONS_FILE = "actions_mapping.ser";
 
 
-    @Override
-    public List<String> getFullSimulatedPlayers() {
-        return Arrays.asList("PlayerA", "PlayerB");
-    }
-
-    @Override
-    protected Game createNewGameAndPlayers() throws GameException, FileNotFoundException {
-        Game game = new TwoPlayerDuel(MultiplayerAttackOption.LEFT, RangeOfInfluence.ONE, MulliganType.GAME_DEFAULT.getMulligan(0), 60, 20, 7);
-        playerA = createPlayer(game, "PlayerA", "C:\\Users\\WillWroble\\Documents\\" + deckNameA);
-        playerB = createPlayer(game, "PlayerB", "C:\\Users\\WillWroble\\Documents\\" + deckNameB);
-        return game;
-    }
     @Override
     protected TestPlayer createPlayer(String name, RangeOfInfluence rangeOfInfluence) {
         if (getFullSimulatedPlayers().contains(name)) {
@@ -63,6 +42,7 @@ public class GenerateMappings extends MinimaxVectorExtractionTests {
         }
         return super.createPlayer(name, rangeOfInfluence);
     }
+    @Override
     public void init_seed() {
         seed = RandomUtil.nextInt();
         //seed = -1421792887;
@@ -70,57 +50,13 @@ public class GenerateMappings extends MinimaxVectorExtractionTests {
         System.out.printf("USING SEED: %d\n", seed);
         RandomUtil.setSeed(seed);
     }
-    @Before
-    public void init_encoder() {
-        init_seed();
-        System.out.println("Setting up encoder");
-        encoder = new StateEncoder();
-
-        // Try to load the persistent mapping from file
-        File mappingFile = new File(MAPPING_FILE);
-        if (mappingFile.exists()) {
-            try {
-                encoder.loadMapping(MAPPING_FILE);
-                System.out.println("Loaded persistent mapping from " + MAPPING_FILE);
-            } catch (IOException | ClassNotFoundException e) {
-                System.out.println("Failed to load mapping. Starting with a fresh mapping.");
-            }
-        } else {
-            System.out.println("No persistent mapping found. Starting fresh.");
-        }
-        //try to load persistent action mappings from file
-        File actionsFile = new File(ACTIONS_FILE);
-        if (actionsFile.exists()) {
-            try {
-                ActionEncoder.actionMap = (Map<String, Integer>) loadObject(ACTIONS_FILE);
-                ActionEncoder.indexCount = ActionEncoder.actionMap.size();
-                System.out.println("Loaded persistent mapping from " + ACTIONS_FILE);
-            } catch (IOException | ClassNotFoundException e) {
-                System.out.println("Failed to load mapping. Starting with a fresh mapping.");
-            }
-        } else {
-            System.out.println("No persistent mapping found. Starting fresh.");
-        }
-
-        set_encoder();
-    }
+    @Override
     public void set_encoder() {
         ComputerPlayerPureMCTS pmc = (ComputerPlayerPureMCTS)playerA.getComputerPlayer();
         pmc.setEncoder(encoder);
         encoder.setAgent(playerA.getId());
         encoder.setOpponent(playerB.getId());
     }
-    public void reset_game() {
-        try {
-            reset();
-        } catch (FileNotFoundException e) {
-            throw new RuntimeException(e);
-        } catch (GameException e) {
-            throw new RuntimeException(e);
-        }
-        set_encoder();
-
-    }
     @Test
     public void print_current_ignore_list() {
         System.out.printf("IGNORE LIST SIZE: %d\n", encoder.ignoreList.size());
@@ -170,30 +106,4 @@ public class GenerateMappings extends MinimaxVectorExtractionTests {
         }
         System.out.println();
     }
-    public void persistData() {
-        try {
-            encoder.persistMapping(MAPPING_FILE);
-            System.out.printf("Persisted feature mapping to %s\n", MAPPING_FILE);
-            //saveObject(ignore, IGNORE_FILE);
-            //System.out.printf("Persisted ignore list to %s\n", IGNORE_FILE);
-            saveObject(new HashMap<>(ActionEncoder.actionMap), ACTIONS_FILE);
-            System.out.printf("Persisted action mapping to %s\n", ACTIONS_FILE);
-        } catch (IOException e) {
-            e.printStackTrace();
-        }
-    }
-
-    // Method to save a Serializable object to a file
-    public static void saveObject(Object obj, String fileName) throws IOException {
-        try (ObjectOutputStream out = new ObjectOutputStream(Files.newOutputStream(Paths.get(fileName)))) {
-            out.writeObject(obj);
-        }
-    }
-
-    // Method to load a Serializable object from a file
-    public static Object loadObject(String fileName) throws IOException, ClassNotFoundException {
-        try (ObjectInputStream in = new ObjectInputStream(Files.newInputStream(Paths.get(fileName)))) {
-            return in.readObject();
-        }
-    }
 }
diff --git a/Mage.Tests/src/test/java/org/mage/test/AI/RL/MCTS2Tests.java b/Mage.Tests/src/test/java/org/mage/test/AI/RL/MCTS2Tests.java
index 7c941506cc..b9d287b47c 100644
--- a/Mage.Tests/src/test/java/org/mage/test/AI/RL/MCTS2Tests.java
+++ b/Mage.Tests/src/test/java/org/mage/test/AI/RL/MCTS2Tests.java
@@ -38,8 +38,8 @@ public class MCTS2Tests extends CardTestPlayerBaseAI {
     @Override
     protected Game createNewGameAndPlayers() throws GameException, FileNotFoundException {
         Game game = new TwoPlayerDuel(MultiplayerAttackOption.LEFT, RangeOfInfluence.ONE, MulliganType.GAME_DEFAULT.getMulligan(0), 60, 20, 7);
-        playerA = createPlayer(game, "PlayerA", "C:\\Users\\WillWroble\\Documents\\" + deckNameA);
-        playerB = createPlayer(game, "PlayerB", "C:\\Users\\WillWroble\\Documents\\" + deckNameB);
+        playerA = createPlayer(game, "PlayerA", "C:\\Users\\owner\\Documents\\" + deckNameA);
+        playerB = createPlayer(game, "PlayerB", "C:\\Users\\owner\\Documents\\" + deckNameB);
         return game;
     }
     @Override
diff --git a/Mage.Tests/src/test/java/org/mage/test/AI/RL/MCTS2WithNNTests.java b/Mage.Tests/src/test/java/org/mage/test/AI/RL/MCTS2WithNNTests.java
index f910217717..c8f383299a 100644
--- a/Mage.Tests/src/test/java/org/mage/test/AI/RL/MCTS2WithNNTests.java
+++ b/Mage.Tests/src/test/java/org/mage/test/AI/RL/MCTS2WithNNTests.java
@@ -1,60 +1,26 @@
 package org.mage.test.AI.RL;
 
-import ai.onnxruntime.OrtException;
-import mage.constants.MultiplayerAttackOption;
 import mage.constants.PhaseStep;
 import mage.constants.RangeOfInfluence;
-import mage.game.Game;
-import mage.game.GameException;
-import mage.game.TwoPlayerDuel;
-import mage.game.mulligan.MulliganType;
+import mage.constants.Zone;
 import mage.player.ai.*;
 import mage.util.RandomUtil;
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
-import org.mage.test.player.TestComputerPlayer7;
-import org.mage.test.player.TestComputerPlayer8;
-import org.mage.test.player.TestComputerPlayerMonteCarlo2;
-import org.mage.test.player.TestPlayer;
-import org.mage.test.serverside.base.CardTestPlayerBaseAI;
+import org.mage.test.player.*;
 
 import java.io.*;
-import java.nio.file.Files;
-import java.nio.file.Paths;
 import java.util.*;
 
 public class MCTS2WithNNTests extends MinimaxVectorExtractionTests {
-    private String deckNameA = "UWTempo.dck"; //simplegreen, UWTempo
-    private String deckNameB = "simplegreen.dck";
-    private List<LabeledState> labeledStates = new ArrayList<>();
-    private List<LabeledState> labeledStateBatch = new ArrayList<>();
-    //private StateEncoder encoder;
-    //private Set<Integer> ignore;
-    //private Map<String, Integer> actions;
-    // File where the persistent mapping is stored
-    private static final String MAPPING_FILE = "features_mapping.ser";
-    private static final String ACTIONS_FILE = "actions_mapping.ser";
-    private static final String TRAIN_OUT_FILE = "training.bin";
-    private static final String TEST_OUT_FILE = "testing.bin";
-    private int seed;
 
-
-
-    @Override
-    public List<String> getFullSimulatedPlayers() {
-        return Arrays.asList("PlayerA", "PlayerB");
-    }
+    public static final String REPLAY_BUFFER_FILE = "replay_buffer.ser";
+    public static final int REPLAY_BUFFER_CAPACITY = 10000; // e.g., holds states from ~200-300 games
+    public ReplayBuffer replayBuffer;
+    public int wins = 0;
+    public int total = 0;
 
-    @Override
-    protected Game createNewGameAndPlayers() throws GameException, FileNotFoundException {
-        ComputerPlayerMCTS2.PATH_TO_NN = "C:\\Users\\WillWroble\\Documents\\GitHub\\MageZero\\exports\\UWTempo\\ver2\\Model.onnx";
-
-        Game game = new TwoPlayerDuel(MultiplayerAttackOption.LEFT, RangeOfInfluence.ONE, MulliganType.GAME_DEFAULT.getMulligan(0), 60, 20, 7);
-        playerA = createPlayer(game, "PlayerA", "C:\\Users\\WillWroble\\Documents\\" + deckNameA);
-        playerB = createPlayer(game, "PlayerB", "C:\\Users\\WillWroble\\Documents\\" + deckNameB);
-        return game;
-    }
     @Override
     protected TestPlayer createPlayer(String name, RangeOfInfluence rangeOfInfluence) {
         if (getFullSimulatedPlayers().contains(name)) {
@@ -64,27 +30,14 @@ public class MCTS2WithNNTests extends MinimaxVectorExtractionTests {
                 testPlayer.setAIPlayer(true); // enable full AI support (game simulations) for all turns by default
                 return testPlayer;
             } else {
-                TestComputerPlayer7 t7 = new TestComputerPlayer7(name, RangeOfInfluence.ONE, getSkillLevel());
-                TestPlayer testPlayer = new TestPlayer(t7);
+                TestComputerPlayer8 t8 = new TestComputerPlayer8(name, RangeOfInfluence.ONE, getSkillLevel());
+                TestPlayer testPlayer = new TestPlayer(t8);
                 testPlayer.setAIPlayer(true); // enable full AI support (game simulations) for all turns by default
                 return testPlayer;
             }
         }
         return super.createPlayer(name, rangeOfInfluence);
     }
-    public void init_seed() {
-        seed = RandomUtil.nextInt();
-        //seed = -1421792887;
-        //seed = 233400479;
-        //seed = 1603827803;
-        //seed = -99205609;
-
-        //seed = 144516733;
-        //seed = 197732112;
-        seed = -781685651;
-        System.out.printf("USING SEED: %d\n", seed);
-        RandomUtil.setSeed(seed);
-    }
     @Before
     public void init_encoder() {
         init_seed();
@@ -117,102 +70,136 @@ public class MCTS2WithNNTests extends MinimaxVectorExtractionTests {
         } else {
             System.out.println("No persistent mapping found. Starting fresh.");
         }
+        //also set up buffer
+        File bufferFile = new File(REPLAY_BUFFER_FILE);
+        if (bufferFile.exists()) {
+            try {
+                replayBuffer = (ReplayBuffer) loadObject(REPLAY_BUFFER_FILE);
+                System.out.printf("Loaded Replay Buffer with %d states from %s%n", replayBuffer.size(), REPLAY_BUFFER_FILE);
+            } catch (IOException | ClassNotFoundException e) {
+                System.out.println("Failed to load Replay Buffer. Starting with a fresh one.");
+                replayBuffer = new ReplayBuffer(REPLAY_BUFFER_CAPACITY);
+            }
+        } else {
+            System.out.println("No Replay Buffer found. Starting fresh.");
+            replayBuffer = new ReplayBuffer(REPLAY_BUFFER_CAPACITY);
+        }
 
         set_encoder();
         labeledStates = new ArrayList<>();
     }
+    @Override
+    public void init_seed() {
+        seed = RandomUtil.nextInt();
+        //seed = -1421792887;
+        //seed = 233400479;
+        //seed = 1603827803;
+        //seed = -99205609;
+
+        //seed = 144516733;
+        //seed = 197732112;
+        //seed = -781685651;
+        //seed = 2036403658;
+        //seed = -1702733670;
+        //seed = 1617973009;
+        //seed = 1735298645;
+        seed = -1943293127;
+        System.out.printf("USING SEED: %d\n", seed);
+        RandomUtil.setSeed(seed);
+    }
+    @Override
     public void set_encoder() {
         ComputerPlayerMCTS2 mcts2 = (ComputerPlayerMCTS2) playerA.getComputerPlayer();
+        mcts2.clearTree();
+        MCTSNode.clearCaches();
+        ComputerPlayer8 c8 = (ComputerPlayer8)playerB.getComputerPlayer();
+        c8.setEncoder(encoder);
         mcts2.setEncoder(encoder);
+        mcts2.setBuffer(replayBuffer);
+        mcts2.initNN("models/Model1.onnx");
         encoder.setAgent(playerA.getId());
         encoder.setOpponent(playerB.getId());
     }
-    public void reset_game() {
-        try {
-            ((ComputerPlayerMCTS2)playerA.getComputerPlayer()).nn.close();
-        } catch (OrtException oe) {
-            oe.printStackTrace();
-        }
-        try {
-            reset();
-        } catch (FileNotFoundException e) {
-            throw new RuntimeException(e);
-        } catch (GameException e) {
-            throw new RuntimeException(e);
-        }
-        set_encoder();
-
-    }
-    public void reset_vectors() {
-        encoder.macroStateVectors.clear();
-        encoder.stateScores.clear();
-        ActionEncoder.actionVectors.clear();
-    }
-
-    /**
-     * uses saved list of actions and states to make a labeled vector batch for training
-     */
+    @Override
     public void create_labeled_states() {
+        total++;
+        if(playerA.hasWon()) wins++;
         int N = encoder.macroStateVectors.size();
         double Œ≥ = 0.99;          // discount factor
-        double Œª = 0;           // how much weight to give the minimax estimate vs. terminal
 
         labeledStateBatch.clear();
         for(int i = 0; i < N; i++) {
-            // 1) decompress your raw state and action bits (you already have this)
-            Set<Integer> state = encoder.getCompressedVector(encoder.macroStateVectors.get(i));
+            Set<Integer> state = encoder.macroStateVectors.get(i);
             double[] action = ActionEncoder.actionVectors.get(i);
 
-            // 2) get your raw minimax score and normalize into [-1,+1]
-            double normScore = encoder.stateScores.get(i);
-            //double normScore = rawScore / (double)Math.abs(GameStateEvaluator2.LOSE_GAME_SCORE);
-
-            //double scale = 20000.0;              // or better yet: maxAbs(stateScores)
-            //double normScore = Math.tanh(rawScore/scale);
-
-
-            // 3) build your discounted terminal label in [-1,+1]
             boolean win = playerA.hasWon();
             double terminal = win ? +1.0 : -1.0;
             double discount = Math.pow(Œ≥, N - i - 1);
 
-            // 4) blend them
-            double blended = Œª * normScore + (1.0 - Œª) * terminal * discount;
+            double score = terminal * discount;
 
-            // 5) store a single LabeledState with that double label
-            labeledStateBatch.add(new LabeledState(state, action, blended));
+            labeledStateBatch.add(new LabeledState(state, action, score));
         }
-
-        // shuffle before writing out / persisting
-        //Collections.shuffle(labeledStateBatch);
-
         reset_vectors();
     }
-    public void print_labeled_states() {
-        for (LabeledState ls : labeledStates) {
-            StringBuilder sb1 = new StringBuilder();
-            for (int i = 0; i < 100; i++) {
-                sb1.append(ls.stateVector[i]);
-                //sb1.append(", ");
-            }
-
-            System.out.printf("State: %s, Action: %s, Result: %s\n", sb1.toString(), Arrays.toString(ls.actionVector), ls.resultLabel);
+    public void loadGame() {
+        if (replayBuffer.size() == 0) {
+            System.out.println("Replay buffer is empty, skipping state load.");
+            reset_game();
+            return;
         }
+        currentGame = replayBuffer.sample(1).get(0).copy();
+        TestPlayer newPlayerA = (TestPlayer) currentGame.getPlayer(playerA.getId());
+        TestPlayer newPlayerB = (TestPlayer) currentGame.getPlayer(playerB.getId());
+        newPlayerA.setMatchPlayer(playerA.getMatchPlayer());
+        newPlayerB.setMatchPlayer(playerB.getMatchPlayer());
+
+        //ComputerPlayerMCTS2 mcts2 = (ComputerPlayerMCTS2) newPlayerA.getComputerPlayer();
+        //mcts2.root = null;
+        //ComputerPlayerMCTS.macroState = ComputerPlayerMCTS.createCompleteMCTSGame(currentGame);
+
+        playerA.restore(newPlayerA);
+        playerB.restore(newPlayerB);
+        currentGame.getState().getPlayers().put(playerA.getId(), playerA);
+        currentGame.getState().getPlayers().put(playerB.getId(), playerB);
+        currentGame.setGameOptions(gameOptions);
+        set_encoder();
     }
     @Test
     public void test_1_game() {
+        int maxTurn = 50;
+        Features.printOldFeatures = false;
+        //ComputerPlayer.PRINT_DECISION_FALLBACKS = true;
+        ComputerPlayerMCTS2.SHOW_THREAD_INFO = true;
+        setStrictChooseMode(false);
+        setStopAt(maxTurn, PhaseStep.END_TURN);
+        execute();
+    }
+    @Test
+    public void test_save_1_game_to_buffer() {
         int maxTurn = 50;
         Features.printOldFeatures = false;
         ComputerPlayerMCTS2.SHOW_THREAD_INFO = true;
         setStrictChooseMode(true);
         setStopAt(maxTurn, PhaseStep.END_TURN);
         execute();
-
+        save_buffer();
     }
     @Test
-    public void print_current_ignore_list() {
+    public void test_1_game_from_buffer() {
+        loadGame();
+        int maxTurn = 50;
+        Features.printOldFeatures = false;
+        ComputerPlayerMCTS2.SHOW_THREAD_INFO = true;
+        setStrictChooseMode(true);
+        setStopAt(maxTurn, PhaseStep.END_TURN);
+        currentGame.resume();
+    }
+    @Test
+    public void print_data() {
         System.out.printf("IGNORE LIST SIZE: %d\n", encoder.ignoreList.size());
         System.out.printf("REDUCED VECTOR SIZE: %d\n", StateEncoder.indexCount - encoder.ignoreList.size());
+        System.out.printf("REPLAY BUFFER SIZE: %d\n", replayBuffer.size());
     }
     /**
      * make a training set of 50 games
@@ -222,7 +209,10 @@ public class MCTS2WithNNTests extends MinimaxVectorExtractionTests {
         int maxTurn = 50;
         Features.printOldFeatures = false;
         ComputerPlayerMCTS2.SHOW_THREAD_INFO = true;
+        ComputerPlayer.PRINT_DECISION_FALLBACKS = true;
         for(int i = 0; i < 5; i++) {
+            addCard(Zone.HAND, playerA, "Lost Jitte", 1);
+            removeAllCardsFromHand(playerB);
             setStrictChooseMode(true);
             setStopAt(maxTurn, PhaseStep.END_TURN);
             execute();
@@ -240,10 +230,40 @@ public class MCTS2WithNNTests extends MinimaxVectorExtractionTests {
         print_labeled_states();
         persistLabeledStates(TRAIN_OUT_FILE);
         persistData();
+        save_buffer();
         System.out.printf("IGNORE LIST SIZE: %d\n", encoder.ignoreList.size());
         System.out.printf("REDUCED VECTOR SIZE: %d\n", StateEncoder.indexCount - encoder.ignoreList.size());
+        System.out.printf("WINRATE: %f\n", wins*1.0/total);
     }
+    @Test
+    public void make_train_ds_50_from_buffer() {
+        int maxTurn = 50;
+        Features.printOldFeatures = false;
+        ComputerPlayerMCTS2.SHOW_THREAD_INFO = true;
+        for(int i = 0; i < 5; i++) {
+            loadGame();
+            setStrictChooseMode(true);
+            setStopAt(maxTurn, PhaseStep.END_TURN);
+            currentGame.resume();
+            create_labeled_states();
+            labeledStates.addAll(labeledStateBatch);
+            labeledStateBatch.clear();
+            reset_game();
+            System.out.printf("GAME #%d RESET... NEW GAME STARTING\n", i+1);
+        }
+        Set<Integer> newIgnore = new HashSet<>(FeatureMerger.computeIgnoreListFromLS(labeledStates));
+        Set<Integer> oldIgnore = new HashSet<>(encoder.ignoreList);
+        encoder.ignoreList = combine_ignore_lists(oldIgnore, newIgnore);
+        compress_labeled_states();
 
+        print_labeled_states();
+        //persistLabeledStates(TRAIN_OUT_FILE);
+        //persistData();
+        //save_buffer();
+        System.out.printf("IGNORE LIST SIZE: %d\n", encoder.ignoreList.size());
+        System.out.printf("REDUCED VECTOR SIZE: %d\n", StateEncoder.indexCount - encoder.ignoreList.size());
+        System.out.printf("WINRATE: %f\n", wins*1.0/total);
+    }
     /**
      * make a testing/validation set of 5 random states from each of 50 games
      */
@@ -265,63 +285,22 @@ public class MCTS2WithNNTests extends MinimaxVectorExtractionTests {
         persistLabeledStates(TEST_OUT_FILE);
         persistData();
     }
+    public void save_buffer() {
+        try {
+            saveObject(replayBuffer, REPLAY_BUFFER_FILE);
+            System.out.printf("Persisted replay buffer to %s%n", REPLAY_BUFFER_FILE);
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+    }
     @After
     public void print_vector_size() {
         System.out.printf("FINAL (unreduced) VECTOR SIZE: %d\n", StateEncoder.indexCount);
         System.out.printf("FINAL ACTION VECTOR SIZE: %d\n", ActionEncoder.indexCount);
+        System.out.printf("REPLAY BUFFER SIZE: %d\n", replayBuffer.size());
         for(String s : ActionEncoder.actionMap.keySet()) {
             System.out.printf("[%s => %d] ", s, ActionEncoder.actionMap.get(s));
         }
         System.out.println();
     }
-    private void persistLabeledStates(String filename) {
-        try (DataOutputStream out = new DataOutputStream(
-                new BufferedOutputStream(new FileOutputStream(filename)))) {
-
-            // 1) Header
-            int n = labeledStates.size();
-            int S = StateEncoder.COMPRESSED_VECTOR_SIZE;         // total feature count
-            int wordsPerState = (S + 63) >>> 6;       // ‚åàS/64‚åâ longs per state
-            int A = 128;
-
-            out.writeInt(n);
-            out.writeInt(S);
-            out.writeInt(wordsPerState);
-            out.writeInt(A);
-
-            // 2) Body
-            for (LabeledState ls : labeledStates) {
-                ls.persist(out);
-            }
-        } catch (IOException e) {
-            e.printStackTrace();
-        }
-    }
-
-    public void persistData() {
-        try {
-            encoder.persistMapping(MAPPING_FILE);
-            System.out.printf("Persisted feature mapping to %s\n", MAPPING_FILE);
-            //saveObject(ignore, IGNORE_FILE);
-            //System.out.printf("Persisted ignore list to %s\n", IGNORE_FILE);
-            saveObject(new HashMap<>(ActionEncoder.actionMap), ACTIONS_FILE);
-            System.out.printf("Persisted action mapping to %s\n", ACTIONS_FILE);
-        } catch (IOException e) {
-            e.printStackTrace();
-        }
-    }
-
-    // Method to save a Serializable object to a file
-    public static void saveObject(Object obj, String fileName) throws IOException {
-        try (ObjectOutputStream out = new ObjectOutputStream(Files.newOutputStream(Paths.get(fileName)))) {
-            out.writeObject(obj);
-        }
-    }
-
-    // Method to load a Serializable object from a file
-    public static Object loadObject(String fileName) throws IOException, ClassNotFoundException {
-        try (ObjectInputStream in = new ObjectInputStream(Files.newInputStream(Paths.get(fileName)))) {
-            return in.readObject();
-        }
-    }
 }
diff --git a/Mage.Tests/src/test/java/org/mage/test/AI/RL/MCTSEncoderTests.java b/Mage.Tests/src/test/java/org/mage/test/AI/RL/MCTSEncoderTests.java
index e41b4b39a4..f6b4018cda 100644
--- a/Mage.Tests/src/test/java/org/mage/test/AI/RL/MCTSEncoderTests.java
+++ b/Mage.Tests/src/test/java/org/mage/test/AI/RL/MCTSEncoderTests.java
@@ -39,8 +39,8 @@ public class MCTSEncoderTests extends CardTestPlayerBaseAI {
                 RangeOfInfluence.ONE,
                 MulliganType.GAME_DEFAULT.getMulligan(0),
                 60, 20, 7);
-        playerA = createPlayer(game, "PlayerA", "C:\\Users\\WillWroble\\Documents\\" + deckNameA);
-        playerB = createPlayer(game, "PlayerB", "C:\\Users\\WillWroble\\Documents\\" + deckNameB);
+        playerA = createPlayer(game, "PlayerA", "C:\\Users\\owner\\Documents\\" + deckNameA);
+        playerB = createPlayer(game, "PlayerB", "C:\\Users\\owner\\Documents\\" + deckNameB);
         return game;
     }
 
diff --git a/Mage.Tests/src/test/java/org/mage/test/AI/RL/MinimaxVectorExtractionTests.java b/Mage.Tests/src/test/java/org/mage/test/AI/RL/MinimaxVectorExtractionTests.java
index 5f06b17ade..0e4b2a6deb 100644
--- a/Mage.Tests/src/test/java/org/mage/test/AI/RL/MinimaxVectorExtractionTests.java
+++ b/Mage.Tests/src/test/java/org/mage/test/AI/RL/MinimaxVectorExtractionTests.java
@@ -8,6 +8,7 @@ import mage.game.GameException;
 import mage.game.TwoPlayerDuel;
 import mage.game.mulligan.MulliganType;
 import mage.player.ai.*;
+import mage.util.RandomUtil;
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
@@ -24,17 +25,18 @@ import java.util.*;
 public class MinimaxVectorExtractionTests extends CardTestPlayerBaseAI {
     private String deckNameA = "UWTempo.dck"; //simplegreen, UWTempo
     private String deckNameB = "simplegreen.dck";
-    private List<LabeledState> labeledStates = new ArrayList<>();
-    private List<LabeledState> labeledStateBatch = new ArrayList<>();
+    public List<LabeledState> labeledStates = new ArrayList<>();
+    public List<LabeledState> labeledStateBatch = new ArrayList<>();
     public StateEncoder encoder;
+    public int seed;
 
     //private Set<Integer> ignore;
     //private Map<String, Integer> actions;
     // File where the persistent mapping is stored
-    private static final String MAPPING_FILE = "features_mapping.ser";
-    private static final String ACTIONS_FILE = "actions_mapping.ser";
-    private static final String TRAIN_OUT_FILE = "training.bin";
-    private static final String TEST_OUT_FILE = "testing.bin";
+    public static final String MAPPING_FILE = "features_mapping.ser";
+    public static final String ACTIONS_FILE = "actions_mapping.ser";
+    public static final String TRAIN_OUT_FILE = "training.bin";
+    public static final String TEST_OUT_FILE = "testing.bin";
 
 
     @Override
@@ -45,8 +47,8 @@ public class MinimaxVectorExtractionTests extends CardTestPlayerBaseAI {
     @Override
     protected Game createNewGameAndPlayers() throws GameException, FileNotFoundException {
         Game game = new TwoPlayerDuel(MultiplayerAttackOption.LEFT, RangeOfInfluence.ONE, MulliganType.GAME_DEFAULT.getMulligan(0), 60, 20, 7);
-        playerA = createPlayer(game, "PlayerA", "C:\\Users\\WillWroble\\Documents\\" + deckNameA);
-        playerB = createPlayer(game, "PlayerB", "C:\\Users\\WillWroble\\Documents\\" + deckNameB);
+        playerA = createPlayer(game, "PlayerA",  deckNameA);
+        playerB = createPlayer(game, "PlayerB",  deckNameB);
         return game;
     }
     @Override
@@ -66,8 +68,14 @@ public class MinimaxVectorExtractionTests extends CardTestPlayerBaseAI {
         }
         return super.createPlayer(name, rangeOfInfluence);
     }
+    public void init_seed() {
+        seed = RandomUtil.nextInt();
+        System.out.printf("USING SEED: %d\n", seed);
+        RandomUtil.setSeed(seed);
+    }
     @Before
     public void init_encoder() {
+        init_seed();
         System.out.println("Setting up encoder");
         encoder = new StateEncoder();
         //ignore = new HashSet<>();
@@ -202,33 +210,6 @@ public class MinimaxVectorExtractionTests extends CardTestPlayerBaseAI {
         return updatedIgnoreList;
     }
 
-    /**
-     * can only grow ignore list
-     * @param oldList
-     * @param newList
-     * @return
-     */
-    public Set<Integer> union_ignore_lists(Set<Integer> oldList, Set<Integer> newList) {
-        Set<Integer> updatedIgnoreList = new HashSet<>();
-
-        int boundaryForOldFeatures = this.encoder.initialRawSize;
-
-
-        for (int i = 0; i < boundaryForOldFeatures; i++) {
-            if (oldList.contains(i)) {
-                updatedIgnoreList.add(i);
-            }
-        }
-
-        for (Integer featureIndexInNewList : newList) {
-            if (featureIndexInNewList >= boundaryForOldFeatures) {
-                updatedIgnoreList.add(featureIndexInNewList);
-            }
-        }
-
-        return updatedIgnoreList;
-    }
-
     /**
      * use the current encoder's compression at the end so it can use the new ignore list
      */
@@ -238,6 +219,11 @@ public class MinimaxVectorExtractionTests extends CardTestPlayerBaseAI {
         }
     }
     @Test
+    public void print_current_ignore_list() {
+        System.out.printf("IGNORE LIST SIZE: %d\n", encoder.ignoreList.size());
+        System.out.printf("REDUCED VECTOR SIZE: %d\n", StateEncoder.indexCount - encoder.ignoreList.size());
+    }
+    @Test
     public void make_ignore_X_50() {
         int maxTurn = 50;
         Features.printOldFeatures = false;
@@ -266,7 +252,7 @@ public class MinimaxVectorExtractionTests extends CardTestPlayerBaseAI {
     public void make_train_ds_X_250() {
         int maxTurn = 50;
         Features.printOldFeatures = false;
-        for(int i = 0; i < 5; i++) {
+        for(int i = 0; i < 250; i++) {
             setStrictChooseMode(true);
             setStopAt(maxTurn, PhaseStep.END_TURN);
             execute();
@@ -319,14 +305,14 @@ public class MinimaxVectorExtractionTests extends CardTestPlayerBaseAI {
     }
     @After
     public void print_vector_size() {
-        System.out.printf("FINAL (unreduced) VECTOR SIZE: %d\n", StateEncoder.indexCount);
+        System.out.printf("RAW VECTOR SIZE: %d\n", StateEncoder.indexCount);
         System.out.printf("FINAL ACTION VECTOR SIZE: %d\n", ActionEncoder.indexCount);
         for(String s : ActionEncoder.actionMap.keySet()) {
             System.out.printf("[%s => %d] ", s, ActionEncoder.actionMap.get(s));
         }
         System.out.println();
     }
-    private void persistLabeledStates(String filename) {
+    public void persistLabeledStates(String filename) {
         try (DataOutputStream out = new DataOutputStream(new BufferedOutputStream(Files.newOutputStream(Paths.get(filename))))) {
 
             // 1) Header
@@ -334,7 +320,7 @@ public class MinimaxVectorExtractionTests extends CardTestPlayerBaseAI {
 
             // 'S' now represents the TOTAL size of your global feature vocabulary.
             // The constant should be updated to reflect this.
-            int S = StateEncoder.GLOBAL_FEATURE_COUNT;
+            int S = StateEncoder.indexCount;
 
             // 'A' is still the size of the policy vector.
             int A = 128;
diff --git a/Mage.Tests/src/test/java/org/mage/test/AI/RL/PureMCTSTests.java b/Mage.Tests/src/test/java/org/mage/test/AI/RL/PureMCTSTests.java
index 24027cfe92..edd4d4bbc8 100644
--- a/Mage.Tests/src/test/java/org/mage/test/AI/RL/PureMCTSTests.java
+++ b/Mage.Tests/src/test/java/org/mage/test/AI/RL/PureMCTSTests.java
@@ -44,8 +44,8 @@ public class PureMCTSTests extends CardTestPlayerBaseAI {
     @Override
     protected Game createNewGameAndPlayers() throws GameException, FileNotFoundException {
         Game game = new TwoPlayerDuel(MultiplayerAttackOption.LEFT, RangeOfInfluence.ONE, MulliganType.GAME_DEFAULT.getMulligan(0), 60, 20, 7);
-        playerA = createPlayer(game, "PlayerA", "C:\\Users\\WillWroble\\Documents\\" + deckNameA);
-        playerB = createPlayer(game, "PlayerB", "C:\\Users\\WillWroble\\Documents\\" + deckNameB);
+        playerA = createPlayer(game, "PlayerA", "C:\\Users\\owner\\Documents\\" + deckNameA);
+        playerB = createPlayer(game, "PlayerB", "C:\\Users\\owner\\Documents\\" + deckNameB);
         return game;
     }
     @Override
diff --git a/Mage.Tests/src/test/java/org/mage/test/AI/RL/RLEncodingTests.java b/Mage.Tests/src/test/java/org/mage/test/AI/RL/RLEncodingTests.java
index 0297f37e2e..71b9ed5d82 100644
--- a/Mage.Tests/src/test/java/org/mage/test/AI/RL/RLEncodingTests.java
+++ b/Mage.Tests/src/test/java/org/mage/test/AI/RL/RLEncodingTests.java
@@ -40,8 +40,8 @@ public class RLEncodingTests extends CardTestPlayerBaseAI {
     @Override
     protected Game createNewGameAndPlayers() throws GameException, FileNotFoundException {
         Game game = new TwoPlayerDuel(MultiplayerAttackOption.LEFT, RangeOfInfluence.ONE, MulliganType.GAME_DEFAULT.getMulligan(0), 60, 20, 7);
-        playerA = createPlayer(game, "PlayerA", "C:\\Users\\WillWroble\\Documents\\" + deckNameA);
-        playerB = createPlayer(game, "PlayerB", "C:\\Users\\WillWroble\\Documents\\" + deckNameB);
+        playerA = createPlayer(game, "PlayerA", "C:\\Users\\owner\\Documents\\" + deckNameA);
+        playerB = createPlayer(game, "PlayerB", "C:\\Users\\owner\\Documents\\" + deckNameB);
         return game;
     }
     @Override
diff --git a/Mage.Tests/src/test/java/org/mage/test/player/TestPlayer.java b/Mage.Tests/src/test/java/org/mage/test/player/TestPlayer.java
index e82d12ad8a..5232de9ac2 100644
--- a/Mage.Tests/src/test/java/org/mage/test/player/TestPlayer.java
+++ b/Mage.Tests/src/test/java/org/mage/test/player/TestPlayer.java
@@ -169,6 +169,11 @@ public class TestPlayer implements Player {
         this.strictChooseMode = testPlayer.strictChooseMode;
     }
 
+    @Override
+    public Ability getLastActivated() {
+        return computerPlayer.getLastActivated();
+    }
+
     public void addChoice(String choice) {
         // prepare face down
         // how-to fix:
diff --git a/Mage.Tests/testing.bin b/Mage.Tests/testing.bin
index ab27eacfbd..3d931d5819 100644
Binary files a/Mage.Tests/testing.bin and b/Mage.Tests/testing.bin differ
diff --git a/Mage.Tests/training.bin b/Mage.Tests/training.bin
index f3a0f558bc..7aff576c27 100644
Binary files a/Mage.Tests/training.bin and b/Mage.Tests/training.bin differ
diff --git a/Mage/src/main/java/mage/cards/decks/DeckCardLayout.java b/Mage/src/main/java/mage/cards/decks/DeckCardLayout.java
index b12e9b7cee..966a8dceb8 100644
--- a/Mage/src/main/java/mage/cards/decks/DeckCardLayout.java
+++ b/Mage/src/main/java/mage/cards/decks/DeckCardLayout.java
@@ -2,13 +2,14 @@ package mage.cards.decks;
 
 import mage.util.Copyable;
 
+import java.io.Serializable;
 import java.util.ArrayList;
 import java.util.List;
 
 /**
  * Created by stravant@gmail.com on 2016-10-03.
  */
-public class DeckCardLayout implements Copyable<DeckCardLayout> {
+public class DeckCardLayout implements Copyable<DeckCardLayout>, Serializable {
 
     private final List<List<List<DeckCardInfo>>> cards;
     private final String settings;
diff --git a/Mage/src/main/java/mage/game/Exile.java b/Mage/src/main/java/mage/game/Exile.java
index 7d8b7bd566..813342e32f 100644
--- a/Mage/src/main/java/mage/game/Exile.java
+++ b/Mage/src/main/java/mage/game/Exile.java
@@ -14,7 +14,7 @@ import java.util.stream.Collectors;
  */
 public class Exile implements Serializable, Copyable<Exile> {
 
-    private static final UUID PERMANENT = UUID.randomUUID();
+    private final UUID PERMANENT = UUID.nameUUIDFromBytes("Permanent".getBytes());
 
     private final Map<UUID, ExileZone> exileZones = new HashMap<>();
 
diff --git a/Mage/src/main/java/mage/game/Game.java b/Mage/src/main/java/mage/game/Game.java
index 2df39b9016..4fabcbdb5a 100644
--- a/Mage/src/main/java/mage/game/Game.java
+++ b/Mage/src/main/java/mage/game/Game.java
@@ -46,6 +46,14 @@ import java.util.*;
 import java.util.stream.Collectors;
 
 public interface Game extends MageItem, Serializable, Copyable<Game> {
+//    void setMacroState(Game game);
+//    void setMacroPlayerId(UUID id);
+//    void setLastAction(Ability ability);
+    Game getLastPriority();
+    UUID getLastPriorityPlayerId();
+    Ability getLastPriorityAction();
+
+    void setLastPriority(Game game);
 
     MatchType getGameType();
 
@@ -640,6 +648,9 @@ public interface Game extends MageItem, Serializable, Copyable<Game> {
 
     boolean executingRollback();
 
+    void addCard(UUID cardId, Card card);
+
+
     /**
      * Add counters to permanent before ETB. Use it before put real permanent to battlefield.
      */
diff --git a/Mage/src/main/java/mage/game/GameImpl.java b/Mage/src/main/java/mage/game/GameImpl.java
index fcacee29f7..20aae6d13a 100644
--- a/Mage/src/main/java/mage/game/GameImpl.java
+++ b/Mage/src/main/java/mage/game/GameImpl.java
@@ -93,6 +93,10 @@ import java.util.stream.Collectors;
  * If it's a temporary/auto-generated data then mark that field as transient and comment in copy constructor.
  */
 public abstract class GameImpl implements Game {
+    //shallow game history for AI
+    private Game lastPriority = this;
+    private UUID lastPriorityPlayerId;
+    public Ability lastPriorityAction;
 
     private static final int ROLLBACK_TURNS_MAX = 4;
     private static final String UNIT_TESTS_ERROR_TEXT = "Error in unit tests";
@@ -182,6 +186,8 @@ public abstract class GameImpl implements Game {
     }
 
     protected GameImpl(final GameImpl game) {
+        this.lastPriorityAction = game.lastPriorityAction;
+        this.lastPriorityPlayerId = game.lastPriorityPlayerId;
         //this.customData = game.customData; // temporary data, no need on game copy
         //this.losingPlayer = game.losingPlayer; // temporary data, no need on game copy
         this.aiGame = game.aiGame;
@@ -247,6 +253,48 @@ public abstract class GameImpl implements Game {
          */
     }
 
+    /**
+     * @return the game object from right before the last priority
+     */
+    @Override
+    public Game getLastPriority() {
+        return lastPriority;
+    }
+
+    /**
+     * @return the id of the player who last had priority
+     */
+    @Override
+    public UUID getLastPriorityPlayerId() {
+        return lastPriorityPlayerId;
+    }
+
+    /**
+     * @return the action made during the last priority
+     */
+    @Override
+    public Ability getLastPriorityAction() {
+        return lastPriorityAction;
+    }
+    /**
+     * @return the action made during the last priority
+     */
+    @Override
+    public void setLastPriority(Game game) {
+        lastPriority = game;
+    }
+//    @Override
+//    public void setMacroState(Game game) {
+//        macroState = game;
+//    }
+//    @Override
+//    public void setMacroPlayerId(UUID id) {
+//        macroPlayerId = id;
+//    }
+//    @Override
+//    public void setLastAction(Ability ability) {
+//        lastAction = ability;
+//    }
     @Override
     public boolean isSimulation() {
         return simulation;
@@ -255,6 +303,7 @@ public abstract class GameImpl implements Game {
     @Override
     public Game createSimulationForAI() {
         Game res = this.copy();
+        ((GameImpl) res).lastPriority = lastPriority;
         ((GameImpl) res).simulation = true;
         ((GameImpl) res).aiGame = true;
         return res;
@@ -948,7 +997,14 @@ public abstract class GameImpl implements Game {
         }
         return savedStates.size();
     }
-
+    // In mage.game.GameImpl.java
+    @Override
+    public void addCard(UUID cardId, Card card) {
+        // This public method allows our reconstructor to populate the master card map.
+        if (cardId != null && card != null) {
+            this.gameCards.put(cardId, card);
+        }
+    }
     /**
      * Warning, for inner usage only, use player.restoreState as much as possible instead
      *
@@ -1713,8 +1769,11 @@ public abstract class GameImpl implements Game {
                                 if (isPaused() || checkIfGameIsOver()) {
                                     return;
                                 }
+                                lastPriority = this.copy();
+                                lastPriorityPlayerId = player.getId();
                                 // resetPassed should be called if player performs any action
                                 if (player.priority(this)) {
+                                    lastPriorityAction = player.getLastActivated();
                                     if (executingRollback()) {
                                         return;
                                     }
diff --git a/Mage/src/main/java/mage/players/Player.java b/Mage/src/main/java/mage/players/Player.java
index aed45f3a4a..c64a877e80 100644
--- a/Mage/src/main/java/mage/players/Player.java
+++ b/Mage/src/main/java/mage/players/Player.java
@@ -70,7 +70,7 @@ public interface Player extends MageItem, Copyable<Player> {
     enum PayLifeCostLevel {
         allAbilities, nonSpellnonActivatedAbilities, onlyManaAbilities, none
     }
-
+    Ability getLastActivated();
     /**
      * Current player is real life player (human). Try to use in GUI and network engine only.
      * <p>
diff --git a/Mage/src/main/java/mage/players/PlayerImpl.java b/Mage/src/main/java/mage/players/PlayerImpl.java
index 432b0917f0..35f60235f8 100644
--- a/Mage/src/main/java/mage/players/PlayerImpl.java
+++ b/Mage/src/main/java/mage/players/PlayerImpl.java
@@ -83,6 +83,7 @@ public abstract class PlayerImpl implements Player, Serializable {
     static final Map<PhaseStep, Step.StepPart> SILENT_PHASES_STEPS = ImmutableMap.<PhaseStep, Step.StepPart>builder().
             put(PhaseStep.DECLARE_ATTACKERS, Step.StepPart.PRE).build();
 
+    private Ability lastActivated;
     /**
      * Used to cancel waiting requests send to the player
      */
@@ -200,7 +201,7 @@ public abstract class PlayerImpl implements Player, Serializable {
     protected final List<List<Mana>> availableTriggeredManaList = new ArrayList<>();
 
     protected PlayerImpl(String name, RangeOfInfluence range) {
-        this(UUID.randomUUID());
+        this(UUID.nameUUIDFromBytes(name.getBytes()));
         this.name = name;
         this.range = range;
         hand = new CardsImpl();
@@ -218,6 +219,9 @@ public abstract class PlayerImpl implements Player, Serializable {
     }
 
     protected PlayerImpl(final PlayerImpl player) {
+
+        this.lastActivated = player.lastActivated;
+
         this.abort = player.abort;
         this.playerId = player.playerId;
 
@@ -301,7 +305,9 @@ public abstract class PlayerImpl implements Player, Serializable {
         this.phyrexianColors = player.getPhyrexianColors() != null ? player.phyrexianColors.copy() : null;
         this.designations = CardUtil.deepCopyObject(player.designations);
     }
-
+    public Ability getLastActivated() {
+        return lastActivated;
+    }
     /**
      * Restore on rollback
      *
@@ -1599,6 +1605,7 @@ public abstract class PlayerImpl implements Player, Serializable {
         if (ability == null) {
             return false;
         }
+        lastActivated = ability.copy();
         boolean result;
         if (ability instanceof PassAbility) {
             pass(game);
