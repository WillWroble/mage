diff --git a/.gitignore b/.gitignore
index d35b250f77..e525ae285b 100644
--- a/.gitignore
+++ b/.gitignore
@@ -61,3 +61,9 @@ Utils/*implemented.txt
 # build tools
 mage-bundle.zip
 .env
+*.ser
+*.bin
+*.bin
+*.onnx
+Mage.Tests/training.bin
+Mage.Tests/testing.bin
diff --git a/Mage.Server.Plugins/Mage.Player.AI.MA/src/mage/player/ai/ComputerPlayer6.java b/Mage.Server.Plugins/Mage.Player.AI.MA/src/mage/player/ai/ComputerPlayer6.java
index d22e381cc8..98d36984fd 100644
--- a/Mage.Server.Plugins/Mage.Player.AI.MA/src/mage/player/ai/ComputerPlayer6.java
+++ b/Mage.Server.Plugins/Mage.Player.AI.MA/src/mage/player/ai/ComputerPlayer6.java
@@ -431,6 +431,7 @@ public class ComputerPlayer6 extends ComputerPlayer {
      */
     protected Integer addActionsTimed() {
         // run new game simulation in parallel thread
+        //assert (threadPoolSimulations != null);
         FutureTask<Integer> task = new FutureTask<>(() -> addActions(root, maxDepth, Integer.MIN_VALUE, Integer.MAX_VALUE));
         threadPoolSimulations.execute(task);
         try {
diff --git a/Mage.Server.Plugins/Mage.Player.AI.MA/src/mage/player/ai/GameStateEvaluator2.java b/Mage.Server.Plugins/Mage.Player.AI.MA/src/mage/player/ai/GameStateEvaluator2.java
index 7adc1cb429..3ec0de6bf9 100644
--- a/Mage.Server.Plugins/Mage.Player.AI.MA/src/mage/player/ai/GameStateEvaluator2.java
+++ b/Mage.Server.Plugins/Mage.Player.AI.MA/src/mage/player/ai/GameStateEvaluator2.java
@@ -154,6 +154,12 @@ public final class GameStateEvaluator2 {
                         + ":" + GameStateEvaluator2.evaluatePermanent(p, game, true))
                 .collect(Collectors.joining("; "));
         sb.append("-> Permanents: [").append(ownPermanentsInfo).append("]");
+        // graveyard
+        sb.setLength(0);
+        String ownGraveInfo = player.getGraveyard().stream()
+                .map(id -> game.getObject(id).getName())
+                .collect(Collectors.joining("; "));
+        sb.append("-> Graveyard: [").append(ownGraveInfo).append("]");
         logger.info(sb.toString());
     }
     public static int evaluatePermanent(Permanent permanent, Game game, boolean useCombatPermanentScore) {
diff --git a/Mage.Server.Plugins/Mage.Player.AI.RL/pom.xml b/Mage.Server.Plugins/Mage.Player.AI.RL/pom.xml
index 3e9a7d0a90..caaa9161cb 100644
--- a/Mage.Server.Plugins/Mage.Player.AI.RL/pom.xml
+++ b/Mage.Server.Plugins/Mage.Player.AI.RL/pom.xml
@@ -39,7 +39,7 @@
         <dependency>
             <groupId>com.microsoft.onnxruntime</groupId>
             <artifactId>onnxruntime</artifactId>
-            <version>1.15.1</version>
+            <version>1.18.0</version>
         </dependency>
     </dependencies>
 
diff --git a/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/ComputerPlayer8.java b/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/ComputerPlayer8.java
index f7085b15c9..b94f825eb7 100644
--- a/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/ComputerPlayer8.java
+++ b/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/ComputerPlayer8.java
@@ -11,7 +11,8 @@ import mage.target.Target;
 import java.util.UUID;
 
 public class ComputerPlayer8 extends ComputerPlayer7{
-    private StateEncoder encoder;
+    //public static boolean saveMinimaxScore = true;
+    private transient StateEncoder encoder;
     public ComputerPlayer8(ComputerPlayer7 player) {
         super(player);
     }
@@ -114,6 +115,11 @@ public class ComputerPlayer8 extends ComputerPlayer7{
         }
         return false;
     }
+    double [] getActionVec(Ability a) {
+        double[] out = new double[128];
+        out[ActionEncoder.getAction(a)] = 1.0;
+        return out;
+    }
     @Override
     protected void act(Game game) {
         if (actions == null
@@ -129,11 +135,12 @@ public class ComputerPlayer8 extends ComputerPlayer7{
                         getAbilityAndSourceInfo(game, ability, true)
                 ));
                 //save action vector
-                ActionEncoder.addAction(ability);
+                encoder.addAction(getActionVec(ability));
                 //save state vector
-                encoder.processMacroState(game);
+                encoder.processMacroState(game, getId());
                 //add scores
-                encoder.stateScores.add(root.score);
+                double perspectiveFactor = getId() == encoder.getMyPlayerID() ? 1.0 : -1.0;
+                encoder.stateScores.add(perspectiveFactor*Math.tanh(root.score*1.0/20000));
                 if (!ability.getTargets().isEmpty()) {
                     for (Target target : ability.getTargets()) {
                         for (UUID id : target.getTargets()) {
diff --git a/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/ComputerPlayerMCTS2.java b/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/ComputerPlayerMCTS2.java
index 3afa935f9e..38cd6837cc 100644
--- a/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/ComputerPlayerMCTS2.java
+++ b/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/ComputerPlayerMCTS2.java
@@ -1,25 +1,17 @@
 package mage.player.ai;
 
 import ai.onnxruntime.OrtException;
-import javafx.util.Pair;
-import mage.abilities.Ability;
-import mage.abilities.ActivatedAbility;
-import mage.abilities.common.PassAbility;
 import mage.constants.PhaseStep;
 import mage.constants.RangeOfInfluence;
 import mage.game.Game;
-import mage.game.combat.Combat;
-import mage.game.combat.CombatGroup;
-import mage.game.turn.Phase;
+import mage.game.GameState;
 import mage.player.ai.MCTSPlayer.NextAction;
-import mage.players.Player;
+import mage.util.RandomUtil;
 import mage.util.ThreadUtils;
 import mage.util.XmageThreadFactory;
 import org.apache.log4j.Logger;
 
-import java.util.ArrayList;
-import java.util.List;
-import java.util.UUID;
+import java.util.*;
 import java.util.concurrent.*;
 
 /**
@@ -30,26 +22,21 @@ public class ComputerPlayerMCTS2 extends ComputerPlayerMCTS {
 
     private static final Logger logger = Logger.getLogger(ComputerPlayerMCTS2.class);
 
-    private StateEncoder encoder = null;
-    private static final int MAX_MCTS_CYCLES = 5;//number of additional cycles the search is allowed to run
-    private static final int BASE_THREAD_TIMEOUT = 3;//seconds
-    private static final int MIN_TREE_VISITS = 100;
-    private static final int MAX_TREE_VISITS = 200;
+    private transient StateEncoder encoder = null;
+    private transient ReplayBuffer buffer = null;
+    private static final int MAX_MCTS_CYCLES = 6;//number of additional cycles the search is allowed to run
+    private static final int BASE_THREAD_TIMEOUT = 1;//seconds
+    private static final int MIN_TREE_VISITS = 50;//per child per thread
 
     public static boolean SHOW_THREAD_INFO = false;
-    public NeuralNetEvaluator nn;
+    public transient NeuralNetEvaluator nn;
+
+
 
-    public static String PATH_TO_NN = "null";
-    private final Object encoderLock = new Object();
 
 
     public ComputerPlayerMCTS2(String name, RangeOfInfluence range, int skill) {
         super(name, range, skill);
-        try {
-            nn = new NeuralNetEvaluator(PATH_TO_NN);
-        } catch (OrtException e) {
-            throw new RuntimeException(e);
-        }
     }
 
     protected ComputerPlayerMCTS2(UUID id) {
@@ -67,44 +54,48 @@ public class ComputerPlayerMCTS2 extends ComputerPlayerMCTS {
     }
 
     /**
-     * Evaluate the game state for the given player.
-     * Replace this placeholder with your actual value network call.
+     * Evaluates a node's game state using the neural network.
+     * This method encodes the state into sparse global indices, runs inference,
+     * and updates the node's policy prior.
      *
-     * @param node     the game state to evaluate
-
+     * @param node The MCTSNode to evaluate.
+     * @return The value of the game state as predicted by the neural network's value head.
      */
     protected double evaluateState(MCTSNode node) {
-        //return GameStateEvaluator2.evaluate(playerId, game).getTotalScore();
 
-        // 1) First, encode the state exactly as you do in processState(),
-        //    but return it as a float[] of length S (with 0f/1f).
-        boolean[] bits;
-        NeuralNetEvaluator.InferenceResult out;
-        synchronized(encoderLock) {
-            encoder.processState(node.getGame());
-            bits = encoder.getCompressedVector(StateEncoder.featureVector);
+        int[] activeGlobalIndices;
+
+        encoder.processState(node.getGame(), getId());
+        activeGlobalIndices = encoder.getFinalActiveGlobalIndicesArray();
+
 
-            float[] input = new float[bits.length];
-            for (int i = 0; i < bits.length; i++) input[i] = bits[i] ? 1.0f : 0.0f;
+        long[] onnxIndices = new long[activeGlobalIndices.length];
 
-            // 2) Run the ONNX model
-            out = nn.infer(input);
+        for (int i = 0; i < activeGlobalIndices.length; i++) {
+            onnxIndices[i] = activeGlobalIndices[i];
         }
 
+        NeuralNetEvaluator.InferenceResult out = nn.infer(onnxIndices);
         node.policy = out.policy;
-        // 3a) If you just want a value‐based rollout, return the value:
-        return (out.value);  // scale or cast to int as you like
 
+        return out.value;
     }
 
     public void setEncoder(StateEncoder enc) {
         encoder = enc;
     }
-
-    public StateEncoder getEncoder() {
-        return encoder;
+    public void setBuffer(ReplayBuffer buf) {
+        buffer = buf;
     }
-    public int diffVisits(List<Integer> children) {
+    public void initNN(String path) {
+        try {
+            nn = new NeuralNetEvaluator(path);
+        } catch (OrtException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    public double diffVisits(List<Integer> children) {
         int max = -1;
         int max2 = -1;//second highest
         for(int n : children) {
@@ -115,7 +106,7 @@ public class ComputerPlayerMCTS2 extends ComputerPlayerMCTS {
                 max2 = n;
             }
         }
-        return max-max2;
+        return (max*1.0)/max2;
     }
     public int averageVisits(List<Integer> children) {
         int sum = 0;
@@ -143,10 +134,11 @@ public class ComputerPlayerMCTS2 extends ComputerPlayerMCTS {
         int initialVisits = root.getAverageVisits();
         //if(initialVisits > MAX_TREE_VISITS) return;//just keep using tree
         if(SHOW_THREAD_INFO) System.out.printf("STARTING ROOT VISITS: %d\n", initialVisits);
-        int thinkTime = BASE_THREAD_TIMEOUT;//calculateThinkTime(game, action);
+        int thinkTime = BASE_THREAD_TIMEOUT;
 
 
         if (this.threadPoolSimulations == null) {
+            System.out.println(poolSize);
             this.threadPoolSimulations = new ThreadPoolExecutor(
                     poolSize,
                     poolSize,
@@ -157,10 +149,12 @@ public class ComputerPlayerMCTS2 extends ComputerPlayerMCTS {
             );
         }
         List<MCTSExecutor> tasks = new ArrayList<>();
+        long seed = RandomUtil.nextInt();
         for (int i = 0; i < poolSize; i++) {
             Game sim = createMCTSGame(game);
             MCTSPlayer player = (MCTSPlayer) sim.getPlayer(playerId);
             player.setNextAction(action);
+            player.dirichletSeed = seed;
             // Create an executor that overrides rollout() to use evaluateState().
             MCTSExecutor exec = new MCTSExecutor(sim, playerId, thinkTime) {
                 @Override
@@ -176,11 +170,13 @@ public class ComputerPlayerMCTS2 extends ComputerPlayerMCTS {
         int cycleCounter = 0;
         int fullTime = 0;
 
-        while (averageVisits(childVisits)+initialVisits < MIN_TREE_VISITS) {//use max visits of children as indicator
+        while (averageVisits(childVisits)+initialVisits < MIN_TREE_VISITS*poolSize) {//use max visits of children as indicator
 
-            if (cycleCounter > MAX_MCTS_CYCLES) break;
-            cycleCounter++;
+            if (cycleCounter > MAX_MCTS_CYCLES) break; //early exit
+
+            if(diffVisits(childVisits) > 2.5 && averageVisits(childVisits) > MIN_TREE_VISITS*poolSize*0.5) break;
 
+            cycleCounter++;
             try {
                 List<Future<Boolean>> runningTasks = threadPoolSimulations.invokeAll(tasks, thinkTime, TimeUnit.SECONDS);
                 for (Future<Boolean> runningTask : runningTasks) {
@@ -193,7 +189,9 @@ public class ComputerPlayerMCTS2 extends ComputerPlayerMCTS {
                     throw new IllegalStateException("One of the simulated games raised an error: " + e, e);
                 }
             }
+
             childVisits = getChildVisits(tasks);
+
             if (SHOW_THREAD_INFO) {
                 System.out.printf("CYCLE %d: %d threads were created\n", cycleCounter, tasks.size());
                 for (MCTSExecutor task : tasks) {
@@ -204,7 +202,6 @@ public class ComputerPlayerMCTS2 extends ComputerPlayerMCTS {
                 System.out.printf("\nCOMPOSITE CHILDREN: %s\n", childVisits.toString());
             }
             fullTime += thinkTime;
-            thinkTime += 1;
         }
         int simCount = 0;
         for (MCTSExecutor task : tasks) {
@@ -223,8 +220,57 @@ public class ComputerPlayerMCTS2 extends ComputerPlayerMCTS {
         }
         MCTSNode.logHitMiss();
     }
+    double[] getActionVec() {
+        double tau = 1.0;            // your temperature hyperparam
+        int    A   = 128;
+        double[] out = new double[A];
+        double   sum = 0;
+        // 1) accumulate visits^(1/tau)
+        for (MCTSNode child : root.children) {
+            if (child.getAction() != null) {
+                int idx = ActionEncoder.getAction(child.getAction());
+                double v = child.visits;
+                // apply temperature
+                double vt = Math.pow(v, 1.0 / tau);
+                out[idx] = vt;
+                sum += vt;
+            }
+        }
+
+        // 2) normalize into a proper distribution
+        if (sum > 0) {
+            for (int i = 0; i < A; i++) {
+                out[i] = out[i] / sum;
+            }
+        }
+        return out;
+    }
+    @Override
+    protected void calculateActions(Game game, NextAction action) {
+        if (root == null) {
+            Game sim = createMCTSGame(game);
+            MCTSPlayer player = (MCTSPlayer) sim.getPlayer(playerId);
+            player.setNextAction(action);
+            root = new MCTSNode(playerId, sim);
+            root.chooseTargetAction = new ArrayList<>(chooseTargetAction);
+        }
+        applyMCTS(game, action);
+        if (root != null) {
+            MCTSNode best = root.bestChild();
+            if(best == null) return;
+
+            encoder.processMacroState(game, getId());
+            encoder.addAction(getActionVec());
+            encoder.stateScores.add(root.getWinRatio());
+            Game copiedState = game.copy();
+            if(buffer != null)
+                buffer.add(copiedState);
 
-    private static List<Integer> getChildVisits(List<MCTSExecutor> tasks) {
+            root = best;
+            root.emancipate();
+        }
+    }
+    private List<Integer> getChildVisits(List<MCTSExecutor> tasks) {
         List<Integer> childVisits = new ArrayList<>();
         int min = Integer.MAX_VALUE;
         for(MCTSExecutor task : tasks) {
@@ -233,7 +279,7 @@ public class ComputerPlayerMCTS2 extends ComputerPlayerMCTS {
 
         for(int i = 0; i <  min; i++) {
             int visitSum = 0;
-            for(int j = 0; j < 8; j++) {
+            for(int j = 0; j < poolSize; j++) {
                 visitSum += tasks.get(j).root.children.get(i).visits;
             }
             childVisits.add(visitSum);
diff --git a/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/ComputerPlayerMinimaxOpponent.java b/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/ComputerPlayerMinimaxOpponent.java
new file mode 100644
index 0000000000..d7c56d7862
--- /dev/null
+++ b/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/ComputerPlayerMinimaxOpponent.java
@@ -0,0 +1,145 @@
+package mage.player.ai;
+
+import mage.abilities.Ability;
+import mage.abilities.ActivatedAbility;
+import mage.constants.RangeOfInfluence;
+import mage.game.Game;
+import mage.game.events.GameEvent;
+import mage.target.Target;
+
+import java.util.UUID;
+
+public class ComputerPlayerMinimaxOpponent extends ComputerPlayer7{
+
+    public ComputerPlayerMinimaxOpponent(ComputerPlayer7 player) {
+        super(player);
+    }
+
+    public ComputerPlayerMinimaxOpponent(String name, RangeOfInfluence range, int skill) {
+        super(name, range, skill);
+    }
+
+
+
+    @Override
+    public boolean priority(Game game) {
+        game.resumeTimer(getTurnControlledBy());
+        boolean result = priorityPlay(game);
+        game.pauseTimer(getTurnControlledBy());
+        return result;
+    }
+    private boolean priorityPlay(Game game) {
+        game.getState().setPriorityPlayerId(playerId);
+        game.firePriorityEvent(playerId);
+
+
+        switch (game.getTurnStepType()) {
+            case UPKEEP:
+
+            case DRAW:
+                pass(game);
+                return false;
+            case PRECOMBAT_MAIN:
+                // 09.03.2020:
+                // in old version it passes opponent's pre-combat step (game.isActivePlayer(playerId) -> pass(game))
+                // why?!
+
+
+                //printBattlefieldScore(game, "Sim PRIORITY on MAIN 1");
+
+                if (actions.isEmpty()) {
+                    calculateActions(game);
+                } else {
+                    // TODO: is it possible non empty actions without calculation?!
+                    throw new IllegalStateException("wtf");
+                }
+                act(game);
+                return true;
+            case BEGIN_COMBAT:
+                pass(game);
+                return false;
+            case DECLARE_ATTACKERS:
+                //printBattlefieldScore(game, "Sim PRIORITY on DECLARE ATTACKERS");
+                if (actions.isEmpty()) {
+                    calculateActions(game);
+                } else {
+                    // TODO: is it possible non empty actions without calculation?!
+                    throw new IllegalStateException("wtf");
+                }
+                act(game);
+                return true;
+            case DECLARE_BLOCKERS:
+                //printBattlefieldScore(game, "Sim PRIORITY on DECLARE BLOCKERS");
+                if (actions.isEmpty()) {
+                    calculateActions(game);
+                } else {
+                    // TODO: is it possible non empty actions without calculation?!
+                    throw new IllegalStateException("wtf");
+                }
+                act(game);
+                return true;
+            case FIRST_COMBAT_DAMAGE:
+            case COMBAT_DAMAGE:
+            case END_COMBAT:
+                pass(game);
+                return false;
+            case POSTCOMBAT_MAIN:
+                //printBattlefieldScore(game, "Sim PRIORITY on MAIN 2");
+                if (actions.isEmpty()) {
+                    calculateActions(game);
+                } else {
+                    // TODO: is it possible non empty actions without calculation?!
+                    throw new IllegalStateException("wtf");
+                }
+                act(game);
+                return true;
+            case END_TURN:
+                //state learning testing only check state at end of its turns
+                if(game.getActivePlayerId() == getId()) {
+                    printBattlefieldScore(game, "END STEP====================");
+                }
+            case CLEANUP:
+                actionCache.clear();
+                pass(game);
+                return false;
+        }
+        return false;
+    }
+    @Override
+    protected void act(Game game) {
+        if (actions == null
+                || actions.isEmpty()) {
+            pass(game);
+        } else {
+            boolean usedStack = false;
+            while (actions.peek() != null) {
+                Ability ability = actions.poll();
+                // example: ===> SELECTED ACTION for PlayerA: Play Swamp
+                System.out.println(String.format("===> SELECTED ACTION for %s: %s",
+                        getName(),
+                        getAbilityAndSourceInfo(game, ability, true)
+                ));
+                if (!ability.getTargets().isEmpty()) {
+                    for (Target target : ability.getTargets()) {
+                        for (UUID id : target.getTargets()) {
+                            target.updateTarget(id, game);
+                            if (!target.isNotTarget()) {
+                                game.addSimultaneousEvent(GameEvent.getEvent(GameEvent.EventType.TARGETED, id, ability, ability.getControllerId()));
+                            }
+                        }
+                    }
+                }
+                //ComputerPlayerMCTS.macroState = ComputerPlayerMCTS.createCompleteMCTSGame(game);
+                //ComputerPlayerMCTS.macroPlayerId = getId();
+                //ComputerPlayerMCTS.lastAction = ability.copy();
+                this.activateAbility((ActivatedAbility) ability, game);
+                if (ability.isUsesStack()) {
+                    usedStack = true;
+                }
+            }
+            if (usedStack) {
+                pass(game);
+            }
+        }
+    }
+}
diff --git a/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/ComputerPlayerPureMCTS.java b/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/ComputerPlayerPureMCTS.java
index 3a9d7315f1..16210cbb92 100644
--- a/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/ComputerPlayerPureMCTS.java
+++ b/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/ComputerPlayerPureMCTS.java
@@ -4,36 +4,37 @@ import ai.onnxruntime.OrtException;
 import mage.constants.PhaseStep;
 import mage.constants.RangeOfInfluence;
 import mage.game.Game;
+import mage.game.GameState;
 import mage.player.ai.MCTSPlayer.NextAction;
+import mage.util.RandomUtil;
 import mage.util.ThreadUtils;
 import mage.util.XmageThreadFactory;
 import org.apache.log4j.Logger;
 
-import java.util.ArrayList;
-import java.util.List;
-import java.util.UUID;
+import java.util.*;
 import java.util.concurrent.*;
 
 /**
- * ComputerPlayerPureMCTS extends ComputerPlayerMCTS and uses random rollouts to maxaminze feature discovery
+ * ComputerPlayerPureMCTS extends ComputerPlayerMCTS and always returns 0 at leaf nodes.
+ * It is designed as a purely random chaotic agent for feature discovery
  */
 public class ComputerPlayerPureMCTS extends ComputerPlayerMCTS {
 
     private static final Logger logger = Logger.getLogger(ComputerPlayerPureMCTS.class);
 
-    private StateEncoder encoder = null;
-    private static final int MAX_MCTS_CYCLES = 5;//number of additional cycles the search is allowed to run
-    private static final int BASE_THREAD_TIMEOUT = 3;//seconds
-    private static final int MIN_TREE_VISITS = 100;
+    private transient StateEncoder encoder = null;
+    private transient ReplayBuffer buffer = null;
+    private static final int MAX_MCTS_CYCLES = 6;//number of additional cycles the search is allowed to run
+    private static final int BASE_THREAD_TIMEOUT = 1;//seconds
+    private static final int MIN_TREE_VISITS = 50;//per child per thread
 
     public static boolean SHOW_THREAD_INFO = false;
-    private final Object encoderLock = new Object();
+
 
 
 
     public ComputerPlayerPureMCTS(String name, RangeOfInfluence range, int skill) {
         super(name, range, skill);
-
     }
 
     protected ComputerPlayerPureMCTS(UUID id) {
@@ -50,34 +51,22 @@ public class ComputerPlayerPureMCTS extends ComputerPlayerMCTS {
         return new ComputerPlayerPureMCTS(this);
     }
 
-
-
+    /**
+     * just meaningless exploration
+     * @param node
+     * @return
+     */
+    protected double evaluateState(MCTSNode node) {
+        encoder.processMacroState(node.getGame(), getId());
+        encoder.addAction(getActionVec());
+        encoder.stateScores.add(0.0);
+        return 0;
+    }
     public void setEncoder(StateEncoder enc) {
         encoder = enc;
     }
-
-    public StateEncoder getEncoder() {
-        return encoder;
-    }
-    public int diffVisits(List<Integer> children) {
-        int max = -1;
-        int max2 = -1;//second highest
-        for(int n : children) {
-            if(n > max) {
-                max2 = max;
-                max = n;
-            } else if(n > max2) {
-                max2 = n;
-            }
-        }
-        return max-max2;
-    }
-    protected double evaluateState(MCTSNode node) {
-        synchronized(encoderLock) {
-            encoder.processMacroState(node.getGame());
-            if(node.getAction() != null)ActionEncoder.addAction(node.getAction());
-        }
-        return 0;
+    public void setBuffer(ReplayBuffer buf) {
+        buffer = buf;
     }
     public int averageVisits(List<Integer> children) {
         int sum = 0;
@@ -105,10 +94,11 @@ public class ComputerPlayerPureMCTS extends ComputerPlayerMCTS {
         int initialVisits = root.getAverageVisits();
         //if(initialVisits > MAX_TREE_VISITS) return;//just keep using tree
         if(SHOW_THREAD_INFO) System.out.printf("STARTING ROOT VISITS: %d\n", initialVisits);
-        int thinkTime = BASE_THREAD_TIMEOUT;//calculateThinkTime(game, action);
+        int thinkTime = BASE_THREAD_TIMEOUT;
 
 
         if (this.threadPoolSimulations == null) {
+            System.out.println(poolSize);
             this.threadPoolSimulations = new ThreadPoolExecutor(
                     poolSize,
                     poolSize,
@@ -119,10 +109,12 @@ public class ComputerPlayerPureMCTS extends ComputerPlayerMCTS {
             );
         }
         List<MCTSExecutor> tasks = new ArrayList<>();
+        long seed = RandomUtil.nextInt();
         for (int i = 0; i < poolSize; i++) {
             Game sim = createMCTSGame(game);
             MCTSPlayer player = (MCTSPlayer) sim.getPlayer(playerId);
             player.setNextAction(action);
+            player.dirichletSeed = seed;
             // Create an executor that overrides rollout() to use evaluateState().
             MCTSExecutor exec = new MCTSExecutor(sim, playerId, thinkTime) {
                 @Override
@@ -130,7 +122,7 @@ public class ComputerPlayerPureMCTS extends ComputerPlayerMCTS {
                     // Instead of a full simulation, evaluate the leaf state with our value function.
                     return evaluateState(node);
                 }
-            };;
+            };
             tasks.add(exec);
         }
         //runs mcts sims until the root has been visited enough times
@@ -138,11 +130,13 @@ public class ComputerPlayerPureMCTS extends ComputerPlayerMCTS {
         int cycleCounter = 0;
         int fullTime = 0;
 
-        while (averageVisits(childVisits)+initialVisits < MIN_TREE_VISITS) {//use max visits of children as indicator
+        while (averageVisits(childVisits)+initialVisits < MIN_TREE_VISITS*poolSize) {//use max visits of children as indicator
 
-            if (cycleCounter > MAX_MCTS_CYCLES) break;
-            cycleCounter++;
+            if (cycleCounter > MAX_MCTS_CYCLES) break; //early exit
+
+            //if(diffVisits(childVisits) > 2.5 && averageVisits(childVisits) > MIN_TREE_VISITS*poolSize*0.5) break;
 
+            cycleCounter++;
             try {
                 List<Future<Boolean>> runningTasks = threadPoolSimulations.invokeAll(tasks, thinkTime, TimeUnit.SECONDS);
                 for (Future<Boolean> runningTask : runningTasks) {
@@ -155,7 +149,9 @@ public class ComputerPlayerPureMCTS extends ComputerPlayerMCTS {
                     throw new IllegalStateException("One of the simulated games raised an error: " + e, e);
                 }
             }
+
             childVisits = getChildVisits(tasks);
+
             if (SHOW_THREAD_INFO) {
                 System.out.printf("CYCLE %d: %d threads were created\n", cycleCounter, tasks.size());
                 for (MCTSExecutor task : tasks) {
@@ -166,7 +162,6 @@ public class ComputerPlayerPureMCTS extends ComputerPlayerMCTS {
                 System.out.printf("\nCOMPOSITE CHILDREN: %s\n", childVisits.toString());
             }
             fullTime += thinkTime;
-            thinkTime += 1;
         }
         int simCount = 0;
         for (MCTSExecutor task : tasks) {
@@ -185,8 +180,54 @@ public class ComputerPlayerPureMCTS extends ComputerPlayerMCTS {
         }
         MCTSNode.logHitMiss();
     }
+    double[] getActionVec() {
+        double tau = 1.0;            // your temperature hyperparam
+        int    A   = 128;
+        double[] out = new double[A];
+        double   sum = 0;
+        // 1) accumulate visits^(1/tau)
+        for (MCTSNode child : root.children) {
+            if (child.getAction() != null) {
+                int idx = ActionEncoder.getAction(child.getAction());
+                double v = child.visits;
+                // apply temperature
+                double vt = Math.pow(v, 1.0 / tau);
+                out[idx] = vt;
+                sum += vt;
+            }
+        }
+
+        // 2) normalize into a proper distribution
+        if (sum > 0) {
+            for (int i = 0; i < A; i++) {
+                out[i] = out[i] / sum;
+            }
+        }
+        return out;
+    }
+    @Override
+    protected void calculateActions(Game game, NextAction action) {
+        if (root == null) {
+            Game sim = createMCTSGame(game);
+            MCTSPlayer player = (MCTSPlayer) sim.getPlayer(playerId);
+            player.setNextAction(action);
+            root = new MCTSNode(playerId, sim);
+            root.chooseTargetAction = new ArrayList<>(chooseTargetAction);
+        }
+        applyMCTS(game, action);
+        if (root != null) {
+            MCTSNode best = root.bestChild();
+            if(best == null) return;
+
+            encoder.processMacroState(game, getId());
+            encoder.addAction(getActionVec());
+            encoder.stateScores.add(root.getWinRatio());
 
-    private static List<Integer> getChildVisits(List<MCTSExecutor> tasks) {
+            root = best;
+            root.emancipate();
+        }
+    }
+    private List<Integer> getChildVisits(List<MCTSExecutor> tasks) {
         List<Integer> childVisits = new ArrayList<>();
         int min = Integer.MAX_VALUE;
         for(MCTSExecutor task : tasks) {
@@ -195,7 +236,7 @@ public class ComputerPlayerPureMCTS extends ComputerPlayerMCTS {
 
         for(int i = 0; i <  min; i++) {
             int visitSum = 0;
-            for(int j = 0; j < 8; j++) {
+            for(int j = 0; j < poolSize; j++) {
                 visitSum += tasks.get(j).root.children.get(i).visits;
             }
             childVisits.add(visitSum);
diff --git a/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/FeatureMerger.java b/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/FeatureMerger.java
index 495e8e3a94..108e887937 100644
--- a/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/FeatureMerger.java
+++ b/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/FeatureMerger.java
@@ -1,56 +1,190 @@
 package mage.player.ai;
 
+import com.j256.ormlite.stmt.query.In;
+
 import java.util.*;
 
 public class FeatureMerger {
-
     /**
-     * Drops only those features that perfectly co-occurred (and fired at least once) across all M states.
-     * Leaves zero-count features intact.
+     * Computes an ignore list for features.
+     * Drops features that perfectly co-occurred with another feature (and fired at least once).
+     * Also drops features that never occurred at all.
+     *
+     * @param stateVectorsSet List of Sets of Integers, where each Set contains the active global feature indices for a state.
+     * @return A Set of feature indices to ignore.
      */
-    public static Set<Integer> computeIgnoreList(List<BitSet> stateVectors) {
-        int M = stateVectors.size();
-        if (M == 0) return Collections.emptySet();
+    public static Set<Integer> computeIgnoreList(List<Set<Integer>> stateVectorsSet) {
+        int S = StateEncoder.indexCount;
+        int M = stateVectorsSet.size();
+        if (M == 0) {
+            return Collections.emptySet();
+        }
+
+        // patterns[f] will be a BitSet indicating in which of the M stateVectors feature 'f' occurred.
+        BitSet[] patterns = new BitSet[S];
+        for (int f = 0; f < S; f++) {
+            patterns[f] = new BitSet(M);
+        }
+
+        for (int row = 0; row < M; row++) {
+            Set<Integer> activeIndices = stateVectorsSet.get(row);
+            if (activeIndices != null) { // Check for null set if that's possible in your data
+                for (Integer activeFeatureIndex : activeIndices) { // Iterating over Integer objects
+                    // Ensure the index is within the bounds of our patterns array
+                    if (activeFeatureIndex != null && activeFeatureIndex >= 0 && activeFeatureIndex < S) {
+                        patterns[activeFeatureIndex].set(row);
+                    } else {
+                        // Log or handle out-of-bounds or null index if necessary
+                        // System.err.println("Warning: Feature index " + activeFeatureIndex + " is out of bounds/null for S=" + S);
+                    }
+                }
+            }
+        }
+
+        Map<BitSet, Integer> representative = new HashMap<>(S);
+        Set<Integer> ignoreList = new HashSet<>();
 
+        for (int f = 0; f < S; f++) {
+            BitSet pattern = patterns[f];
+            if (pattern.isEmpty()) {
+                // Feature f never occurred in any stateVector - add to ignore list
+                ignoreList.add(f);
+                continue;
+            }
+
+            BitSet key = (BitSet) pattern.clone();
+            Integer firstFeatureWithThisPattern = representative.get(key);
+
+            if (firstFeatureWithThisPattern == null) {
+                representative.put(key, f);
+            } else {
+                ignoreList.add(f);
+            }
+        }
+        return ignoreList;
+    }
+
+    /**
+     * Computes an ignore list for features using LabeledState objects.
+     * Assumes LabeledState.activeGlobalIndices is an int[] of active global feature indices.
+     *
+     * @param labeledStates List of LabeledState objects.
+     * @return A Set of feature indices to ignore.
+     */
+    public static Set<Integer> computeIgnoreListFromLS(List<LabeledState> labeledStates) {
+        int M = labeledStates.size();
         int S = StateEncoder.indexCount;
-        long[] fingerprint = new long[S];
-        int[]  counts      = new int[S];
-        long   token       = 1;
-
-        // 1) Build fingerprint & counts
-        for (BitSet vec : stateVectors) {
-            long t = token++;
-            for (int i = 0; i < S; i++) {
-                if (vec.get(i)) {
-                    counts[i]++;
-                    fingerprint[i] ^= t;
+        if (M == 0) {
+            return Collections.emptySet();
+        }
+
+        BitSet[] patterns = new BitSet[S];
+        for (int f = 0; f < S; f++) {
+            patterns[f] = new BitSet(M);
+        }
+
+        for (int row = 0; row < M; row++) {
+            // Assuming LabeledState now has a field like 'activeGlobalIndices' of type int[]
+            int[] activeIndices = labeledStates.get(row).stateVector;
+            for (int activeFeatureIndex : activeIndices) {
+                if (activeFeatureIndex >= 0 && activeFeatureIndex < S) {
+                    patterns[activeFeatureIndex].set(row);
+                } else {
+                    // Log or handle out-of-bounds index
                 }
             }
         }
 
-        // 2) Group only the features that actually occurred (counts[i] > 0)
-        Map<Long, List<Integer>> groups = new HashMap<>(S);
-        for (int i = 0; i < S; i++) {
-            if (counts[i] == 0) continue;       // **skip zero‐count features**
-            groups
-                    .computeIfAbsent(fingerprint[i], __ -> new ArrayList<>())
-                    .add(i);
+        // The rest of the logic is identical to computeIgnoreList
+        Map<BitSet, Integer> representative = new HashMap<>(S);
+        Set<Integer> ignoreList = new HashSet<>();
+
+        for (int f = 0; f < S; f++) {
+            BitSet pattern = patterns[f];
+            if (pattern.isEmpty()) {
+                ignoreList.add(f);
+                continue;
+            }
+            BitSet key = (BitSet) pattern.clone();
+            Integer first = representative.get(key);
+            if (first == null) {
+                representative.put(key, f);
+            } else {
+                ignoreList.add(f);
+            }
+        }
+        return ignoreList;
+    }
+    /**
+     * Computes an ignore list for features using LabeledState objects.
+     * Assumes LabeledState.activeGlobalIndices is an int[] of active global feature indices.
+     * @param endIndex max index to use
+     * @param labeledStates List of LabeledState objects.
+     * @return A Set of feature indices to ignore.
+     */
+    public static Set<Integer> computeIgnoreListFromLS(List<LabeledState> labeledStates, int startIndex, int endIndex) {
+        int M = labeledStates.size();
+        if (M == 0) {
+            return Collections.emptySet();
+        }
+
+        BitSet[] patterns = new BitSet[endIndex];
+        for (int f = startIndex; f < endIndex; f++) {
+            patterns[f] = new BitSet(M);
         }
 
-        // 3) Within each non‐zero group, drop duplicates whose counts match
-        Set<Integer> ignore = new HashSet<>();
-        for (List<Integer> grp : groups.values()) {
-            if (grp.size() < 2) continue;
-            Collections.sort(grp);
-            int keeper = grp.get(0);
-            for (int j = 1; j < grp.size(); j++) {
-                int idx = grp.get(j);
-                if (counts[idx] == counts[keeper]) {
-                    ignore.add(idx);
+        for (int row = 0; row < M; row++) {
+            // Assuming LabeledState now has a field like 'activeGlobalIndices' of type int[]
+            int[] activeIndices = labeledStates.get(row).stateVector;
+            for (int activeFeatureIndex : activeIndices) {
+                if (activeFeatureIndex >= startIndex && activeFeatureIndex < endIndex) {
+                    patterns[activeFeatureIndex].set(row);
+                } else {
+                    // Log or handle out-of-bounds index
                 }
             }
         }
 
-        return ignore;
+        // The rest of the logic is identical to computeIgnoreList
+        Map<BitSet, Integer> representative = new HashMap<>(endIndex);
+        Set<Integer> ignoreList = new HashSet<>();
+
+        for (int f = startIndex; f < endIndex; f++) {
+            BitSet pattern = patterns[f];
+            if (pattern.isEmpty()) {
+                ignoreList.add(f);
+                continue;
+            }
+            BitSet key = (BitSet) pattern.clone();
+            Integer first = representative.get(key);
+            if (first == null) {
+                representative.put(key, f);
+            } else {
+                ignoreList.add(f);
+            }
+        }
+        return ignoreList;
+    }
+    /**
+     * Compresses a raw feature vector by removing any indices present in the ignore set.
+     * @param ignore The Set of feature indices to remove.
+     * @param stateVector The uncompressed array of feature indices.
+     * @return A new, compressed array of feature indices.
+     */
+    public static int[] getCompressedVectorArray(Set<Integer> ignore, int[] stateVector) {
+        // Use a List to dynamically store the features that are kept.
+        List<Integer> compressedList = new ArrayList<>();
+        for (int featureIndex : stateVector) {
+            if (!ignore.contains(featureIndex)) {
+                compressedList.add(featureIndex);
+            }
+        }
+
+        // Convert the List to a primitive int array for final storage.
+        int[] out = new int[compressedList.size()];
+        for (int i = 0; i < compressedList.size(); i++) {
+            out[i] = compressedList.get(i);
+        }
+        return out;
     }
-}
+}
\ No newline at end of file
diff --git a/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/Features.java b/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/Features.java
index bd08fa186d..0fd9dcdf12 100644
--- a/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/Features.java
+++ b/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/Features.java
@@ -4,18 +4,22 @@ import java.io.*;
 import java.nio.file.Files;
 import java.nio.file.Paths;
 import java.util.*;
+import java.util.concurrent.atomic.AtomicInteger;
 
 /**
- *this hierarchical structure represents the mapping of every possible relevant feature encountered from a game state to
- * an index on a 200000 dimension binary vector. the reduced form of this vector (4000) will be used as input for both a policy and
+ * This hierarchical structure represents the mapping of every possible relevant feature encountered from a game state to
+ * an index on a 200000 dimension binary vector. The reduced form of this vector (~5000) will be used as input for both a policy and
  * value neural network. To see how game features are mapped look at StateEncoder.java this data structure only handles and stores the
- * mappings
+ * mappings.
+ *
  * @author willwroble
  */
-public class Features  implements Serializable {
-    private static final long serialVersionUID = 1L;
-    public int globalIndexCount;
-    Set<Integer> ignoreList;
+public class Features implements Serializable {
+    private static final long serialVersionUID = 2L; // Version updated for the structural change
+    public AtomicInteger localIndexCount; // a mutable, thread-safe counter
+    public int previousLocalIndexCount = 0;
+    public Set<Integer> ignoreList;
+    public int version = 0;
 
     private final Map<String, Map<Integer, Features>> subFeatures;
     private final Map<String, Map<Integer, Integer>> features;
@@ -23,13 +27,16 @@ public class Features  implements Serializable {
     private final Map<String, Integer> occurrences;
     private final Map<String, TreeMap<Integer, Integer>> numericOccurrences;
     private final Map<String, Features> categoriesForChildren; //isn't reset between states, represents all possible categories for children
-    public Set<Features> categories; //resets every state represents temporary category features fall under
+    private final Set<Features> categories; //resets every state represents temporary category features fall under
     public boolean passToParent = true;
 
-    public String featureName;
+    private transient StateEncoder encoder;
+
+    private String featureName;
     public Features parent;
     public static boolean printOldFeatures = true;
     public static boolean printNewFeatures = true;
+
     public Features() {
         //constructor
         subFeatures = new HashMap<>();
@@ -39,54 +46,84 @@ public class Features  implements Serializable {
         numericOccurrences = new HashMap<>();
         categoriesForChildren = new HashMap<>();
         categories = new HashSet<>();
+        ignoreList = new HashSet<>();
+        localIndexCount = new AtomicInteger(0);
         parent = null;
         featureName = "root";
     }
+
     public Features(Features p, String name) {
         this();
+        // Manually set fields instead of calling this(), to avoid creating a new AtomicInteger
         parent = p;
         featureName = name;
+        encoder = p.encoder;
+        localIndexCount = p.localIndexCount;
     }
 
+    public Features(String name, StateEncoder e, AtomicInteger i) {
+        this();
+        featureName = name;
+        encoder = e;
+        localIndexCount = i;
+    }
 
-    public Features getCategory(String name) {
+    public void setEncoder(StateEncoder encoder) {
+        this.encoder = encoder;
+        for (String n : subFeatures.keySet()) {
+            for (Integer i : subFeatures.get(n).keySet()) {
+                subFeatures.get(n).get(i).setEncoder(encoder);
+            }
+        }
+        for (String n : categoriesForChildren.keySet()) {
+            categoriesForChildren.get(n).setEncoder(encoder);
+        }
+    }
 
-        if(categoriesForChildren.containsKey(name)) {//already contains category
+    public Features getCategory(String name) {
+        if(name.isEmpty()) return null;
+        if (categoriesForChildren.containsKey(name)) { //already contains category
             return categoriesForChildren.get(name);
-
-        } else{//completely new
+        } else { //completely new
             Features parentCategory = null;
-            if(parent != null) parentCategory = parent.getCategory(name); //categories can have a parent
-            Features newCat = new Features(parentCategory, name + "_" + featureName);
+            if (parent != null) parentCategory = parent.getCategory(name); //categories can have a parent
+            Features newCat;
+            if (parentCategory != null) {
+                newCat = new Features(parentCategory, name + "_" + featureName);
+            } else {
+                newCat = new Features(name + "_" + featureName, encoder, localIndexCount);
+            }
             categoriesForChildren.put(name, newCat);
             return newCat;
         }
-
     }
 
     /**
      * gets subfeatures at name or creates them if they dont exist
+     *
      * @param name
      * @return subfeature at name (never returns null)
      */
     public Features getSubFeatures(String name) {
         return getSubFeatures(name, true);
     }
+
     public Features getSubFeatures(String name, boolean passToParent) {
-        //first add as a normal binary feature
+        if(name.isEmpty()) return null;
+        //added as normal binary feature
         addFeature(name);
 
         int n = occurrences.get(name);
-        if(subFeatures.containsKey(name)) {//already contains feature
-            if(subFeatures.get(name).containsKey(n)) {//contains count too
+        if (subFeatures.containsKey(name)) { //already contains feature
+            if (subFeatures.get(name).containsKey(n)) { //contains count too
                 return subFeatures.get(name).get(n);
-            } else {//new count
+            } else { //new count
                 Map<Integer, Features> map = subFeatures.get(name);
                 Features newSub = new Features(this, name + "_" + Integer.toString(n));
                 map.put(n, newSub);
                 return newSub;
             }
-        } else{//completely new
+        } else { //completely new
             Map<Integer, Features> newMap = new HashMap<>();
             Features newSub = new Features(this, name + "_1");
             newMap.put(1, newSub);
@@ -95,6 +132,7 @@ public class Features  implements Serializable {
             return newSub;
         }
     }
+
     /**
      * similar to a subfeature a category will pool features within itself. however
      * unlike subfeatures a feature can inherit multiple categories(ie card type and color).
@@ -102,112 +140,116 @@ public class Features  implements Serializable {
      * this function creates/finds the category with the given name and adds it as a
      * category for this feature to pass up to, similar to the parent
      * Categories should always be added before features
+     *
      * @param name
      */
     public void addCategory(String name) {
+        if(name.isEmpty()) return;
         addFeature(name); //first add as feature since every category is also a feature
         Features categoryFeature = parent.getCategory(name);
         categories.add(categoryFeature);
     }
+
     public void addFeature(String name) {
         addFeature(name, true);
     }
+
     public void addFeature(String name, boolean callParent) {
+        if(name.isEmpty()) return;
         //usually add feature to parent/categories
-        if(parent != null && callParent && passToParent) {
+        if (parent != null && callParent && passToParent) {
             parent.addFeature(name);
-            for(Features c : categories) {
+            for (Features c : categories) {
                 c.addFeature(name);
             }
         }
 
-        if(features.containsKey(name)) {//has feature
-            int count = occurrences.get(name)+1;
+        if (features.containsKey(name)) { //has feature
+            int count = occurrences.get(name) + 1;
             occurrences.put(name, count);
-            if(features.get(name).containsKey(count)) {//already contains feature at this count
-                if(printOldFeatures) System.out.printf("Index %d is already reserved for feature %s at %d times in %s\n", features.get(name).get(count), name, count, featureName);
-            } else {//contains feature but different count
-                features.get(name).put(count, StateEncoder.indexCount++);
-                if(printNewFeatures) System.out.printf("Feature %s exists but has not occurred %d times, reserving index %d for the %d occurrence of this feature in %s\n",
-                        name, count, StateEncoder.indexCount-1, count, featureName);
+            if (features.get(name).containsKey(count)) { //already contains feature at this count
+                if (printOldFeatures)
+                    System.out.printf("Index %d is already reserved for feature %s at %d times in %s\n", features.get(name).get(count), name, count, featureName);
+            } else { //contains feature but different count
+                features.get(name).put(count, localIndexCount.getAndIncrement()); //  FIXED: Use atomic increment
+                if (printNewFeatures)
+                    System.out.printf("Feature %s exists but has not occurred %d times, reserving index %d for the %d occurrence of this feature in %s\n",
+                            name, count, localIndexCount.get() - 1, count, featureName);
             }
-        } else {//completely new feature
+        } else { //completely new feature
             occurrences.put(name, 1);
             Map<Integer, Integer> n = new HashMap<>();
-            n.put(1, StateEncoder.indexCount++);
+            n.put(1, localIndexCount.getAndIncrement());
             features.put(name, n);
-            if(printNewFeatures) System.out.printf("New feature %s discovered in %s, reserving index %d for this feature\n", name, featureName, n.get(1));
+            if (printNewFeatures)
+                System.out.printf("New feature %s discovered in %s, reserving index %d for this feature\n", name, featureName, n.get(1));
         }
-        StateEncoder.featureVector.set(features.get(name).get(occurrences.get(name)),true);
+        encoder.featureVector.add(features.get(name).get(occurrences.get(name)));
     }
+
     public void addNumericFeature(String name, int num) {
         addNumericFeature(name, num, true);
     }
+
     public void addNumericFeature(String name, int num, boolean callParent) {
+        if(name.isEmpty()) return;
         //usually add feature to parent/categories
-        if(parent != null && callParent && passToParent) {
+        if (parent != null && callParent && passToParent) {
             parent.addNumericFeature(name, num);
-            //keep track of numerical sum for parents
-            for(int i = 0; i < num; i++) {
-                parent.addFeature(name + "_SUM", false);
-            }
-            for(Features c : categories) {
-                c.addFeature(name);
-                //keep track of numerical sum for categories
-                for(int i = 0; i < num; i++) {
-                    c.addFeature(name + "_SUM", false);
-                }
-            }
         }
 
         //also adds copy to number right below this one which will recursively increment the occurrences of each lesser feature
         //Integer nextHighest = numericFeatures.get(name).floorKey(num-1);
-        if(num > 0) addNumericFeature(name, num-1, false);
-
-        if(numericFeatures.containsKey(name)) {
+        if (num > 0) addNumericFeature(name, num - 1, false);
 
-            if(numericFeatures.get(name).containsKey(num)) {
-                int count = numericOccurrences.get(name).get(num)+1;
+        if (numericFeatures.containsKey(name)) {
+            if (numericFeatures.get(name).containsKey(num)) {
+                int count = numericOccurrences.get(name).get(num) + 1;
                 numericOccurrences.get(name).put(num, count);
 
-                if(numericFeatures.get(name).get(num).containsKey(count)) {//already contains feature at this count
-                    if(printOldFeatures) System.out.printf("Index %d is already reserved for numeric feature %s with %d at %d times in %s\n", numericFeatures.get(name).get(num).get(count), name, num, count, featureName);
-                } else {//contains feature and num but different count
-                    numericFeatures.get(name).get(num).put(count, StateEncoder.indexCount++);
-                    if(printNewFeatures) System.out.printf("Numeric feature %s with %d exists but has not occurred %d times, reserving index %d for the %d occurrence of this feature in %s\n",
-                            name, num, count, StateEncoder.indexCount-1, count, featureName);
+                if (numericFeatures.get(name).get(num).containsKey(count)) { //already contains feature at this count
+                    if (printOldFeatures)
+                        System.out.printf("Index %d is already reserved for numeric feature %s with %d at %d times in %s\n", numericFeatures.get(name).get(num).get(count), name, num, count, featureName);
+                } else { //contains feature and num but different count
+                    numericFeatures.get(name).get(num).put(count, localIndexCount.getAndIncrement());
+                    if (printNewFeatures)
+                        System.out.printf("Numeric feature %s with %d exists but has not occurred %d times, reserving index %d for the %d occurrence of this feature in %s\n",
+                                name, num, count, localIndexCount.get() - 1, count, featureName);
                 }
             } else { //contains category but not this number
                 Map<Integer, Map<Integer, Integer>> map = numericFeatures.get(name);
                 Map<Integer, Integer> subMap = new HashMap<>();
-                subMap.put(1, StateEncoder.indexCount++);
+                subMap.put(1, localIndexCount.getAndIncrement());
                 map.put(num, subMap);
                 numericOccurrences.get(name).put(num, 1);
-                if(printNewFeatures) System.out.printf("Numeric feature %s exists but has not occurred with %d, reserving index %d for this feature at %d in %s\n",
-                        name, num, StateEncoder.indexCount-1, num, featureName);
+                if (printNewFeatures)
+                    System.out.printf("Numeric feature %s exists but has not occurred with %d, reserving index %d for this feature at %d in %s\n",
+                            name, num, localIndexCount.get() - 1, num, featureName);
             }
-        } else {//completely new feature category
+        } else { //completely new feature category
             TreeMap<Integer, Map<Integer, Integer>> newMap = new TreeMap<>();
             Map<Integer, Integer> subMap = new HashMap<>();
-            subMap.put(1, StateEncoder.indexCount++);
+            subMap.put(1, localIndexCount.getAndIncrement());
             newMap.put(num, subMap);
             numericFeatures.put(name, newMap);
             TreeMap<Integer, Integer> newTreeMap = new TreeMap<>();
             newTreeMap.put(num, 1);
             numericOccurrences.put(name, newTreeMap);
-            if(printNewFeatures) System.out.printf("New numeric feature %s discovered with %d in %s, reserving index %d for this feature at %d\n", name,
-                    num, featureName, StateEncoder.indexCount-1, num);
+            if (printNewFeatures)
+                System.out.printf("New numeric feature %s discovered with %d in %s, reserving index %d for this feature at %d\n", name,
+                        num, featureName, localIndexCount.get() - 1, num);
         }
-        StateEncoder.featureVector.set(numericFeatures.get(name).get(num).get(numericOccurrences.get(name).get(num)),true);
+        encoder.featureVector.add(numericFeatures.get(name).get(num).get(numericOccurrences.get(name).get(num)));
     }
+
     public void stateRefresh() {
         categories.clear();
         occurrences.replaceAll((k, v) -> 0);
-        for(String c : numericOccurrences.keySet()) {
+        for (String c : numericOccurrences.keySet()) {
             numericOccurrences.get(c).replaceAll((k, v) -> 0);
         }
-        for(String n : subFeatures.keySet()) {
-            for(int i : subFeatures.get(n).keySet()) {
+        for (String n : subFeatures.keySet()) {
+            for (int i : subFeatures.get(n).keySet()) {
                 subFeatures.get(n).get(i).stateRefresh();
             }
         }
@@ -216,6 +258,164 @@ public class Features  implements Serializable {
         }
     }
 
+    /**
+     * always discard f after merging
+     *
+     * @param f object to merge with
+     */
+    public synchronized void merge(Features f) {
+        if (this == f) return;
+
+        // Normal features
+        for (String n : f.features.keySet()) {
+            Map<Integer, Integer> thisOccurrenceMap = this.features.computeIfAbsent(n, k -> new HashMap<>());
+            this.occurrences.putIfAbsent(n, 0);
+            for (int i : f.features.get(n).keySet()) {
+                if (!thisOccurrenceMap.containsKey(i)) {
+                    thisOccurrenceMap.put(i, this.localIndexCount.getAndIncrement());
+                }
+            }
+        }
+
+        // Numeric features
+        for (String n : f.numericFeatures.keySet()) {
+            TreeMap<Integer, Map<Integer, Integer>> thisNumericMap = this.numericFeatures.computeIfAbsent(n, k -> new TreeMap<>());
+            this.numericOccurrences.putIfAbsent(n, new TreeMap<>());
+            for (int num : f.numericFeatures.get(n).keySet()) {
+                Map<Integer, Integer> thisOccurrenceMap = thisNumericMap.computeIfAbsent(num, k -> new HashMap<>());
+                this.numericOccurrences.get(n).putIfAbsent(num, 0);
+                for (int i  : f.numericFeatures.get(n).get(num).keySet()) {
+                    if (!thisOccurrenceMap.containsKey(i)) {
+                        thisOccurrenceMap.put(i, this.localIndexCount.getAndIncrement());
+                    }
+                }
+            }
+        }
+        //subfeatures
+        for (String n : f.subFeatures.keySet()) {
+            Map<Integer, Features> thisSubMap = this.subFeatures.computeIfAbsent(n, k -> new HashMap<>());
+            for (int i : f.subFeatures.get(n).keySet()) {
+                Features thisSubFeature = thisSubMap.computeIfAbsent(i, k -> new Features(this, n + "_" + i));
+                thisSubFeature.merge(f.subFeatures.get(n).get(i));
+            }
+        }
+        //category labels
+        for (String n : f.categoriesForChildren.keySet()) {
+            if (!this.categoriesForChildren.containsKey(n)) {
+                this.categoriesForChildren.put(n, this.getCategory(n));
+            }
+            this.categoriesForChildren.get(n).merge(f.categoriesForChildren.get(n));
+        }
+    }
+    /**
+     * Creates a synchronized, deep copy of this Features object.
+     * By being synchronized, it ensures we get a clean snapshot and never
+     * copy the object while another thread is in the middle of merging.
+     * @return A new, completely independent deep copy of this object.
+     */
+    public synchronized Features createDeepCopy() {
+        try {
+            ByteArrayOutputStream byteOutput = new ByteArrayOutputStream();
+            ObjectOutputStream objectOutput = new ObjectOutputStream(byteOutput);
+            objectOutput.writeObject(this);
+            objectOutput.close();
+
+            ByteArrayInputStream byteInput = new ByteArrayInputStream(byteOutput.toByteArray());
+            ObjectInputStream objectInput = new ObjectInputStream(byteInput);
+            Features copy = (Features) objectInput.readObject();
+            objectInput.close();
+
+            return copy;
+        } catch (IOException | ClassNotFoundException e) {
+            throw new RuntimeException("Failed to create a deep copy of the Features object.", e);
+        }
+    }
+    /**
+     * Prints the entire feature tree, hiding features on the ignore list by default.
+     */
+    public void printFeatureTree() {
+        // Default behavior: do not print ignored features.
+        printFeatureTree(false);
+    }
+
+    /**
+     * Prints the entire feature tree in a hierarchical format.
+     *
+     * @param showIgnored If true, all features will be printed. If false, features
+     * whose indices are in the ignoreList will not be printed.
+     */
+    public void printFeatureTree(boolean showIgnored) {
+        // Start the recursion, passing the root's ignoreList down the tree.
+        printTreeRecursive(this.featureName, showIgnored, this.ignoreList);
+    }
+
+    /**
+     * Helper function to recursively traverse and print the feature tree.
+     *
+     * @param prefix        The current hierarchical path of the feature.
+     * @param showIgnored   If false, features on the ignore list are skipped.
+     * @param masterIgnoreList The single ignoreList from the root object to check against.
+     */
+    private void printTreeRecursive(String prefix, boolean showIgnored, Set<Integer> masterIgnoreList) {
+        // The conditional check for printing.
+        final boolean shouldPrintAll = showIgnored;
+
+        // Print the direct "leaf" features of the current node
+        if (this.features != null) {
+            for (Map.Entry<String, Map<Integer, Integer>> featureEntry : this.features.entrySet()) {
+                String featureName = featureEntry.getKey();
+                Map<Integer, Integer> occurrenceMap = featureEntry.getValue();
+                for (Map.Entry<Integer, Integer> occurrenceEntry : occurrenceMap.entrySet()) {
+                    Integer occurrence = occurrenceEntry.getKey();
+                    Integer index = occurrenceEntry.getValue();
+                    if (shouldPrintAll || !masterIgnoreList.contains(index)) {
+                        System.out.println(prefix + "/" + featureName + "/" + occurrence + "=>" + index);
+                    }
+                }
+            }
+        }
+
+        // Print the direct numeric "leaf" features of the current node
+        if (this.numericFeatures != null) {
+            for (Map.Entry<String, TreeMap<Integer, Map<Integer, Integer>>> numericEntry : this.numericFeatures.entrySet()) {
+                String featureName = numericEntry.getKey();
+                for (Map.Entry<Integer, Map<Integer, Integer>> valueEntry : numericEntry.getValue().entrySet()) {
+                    int numValue = valueEntry.getKey();
+                    for (Map.Entry<Integer, Integer> occurrenceEntry : valueEntry.getValue().entrySet()) {
+                        Integer occurrence = occurrenceEntry.getKey();
+                        Integer index = occurrenceEntry.getValue();
+                        if (shouldPrintAll || !masterIgnoreList.contains(index)) {
+                            System.out.println(prefix + "/" + featureName + "_val" + numValue + "/" + occurrence + "=>" + index);
+                        }
+                    }
+                }
+            }
+        }
+
+        // Recurse into sub-features, passing the master list along
+        if (this.subFeatures != null) {
+            for (Map.Entry<String, Map<Integer, Features>> subEntry : this.subFeatures.entrySet()) {
+                String subFeatureName = subEntry.getKey();
+                Map<Integer, Features> occurrenceMap = subEntry.getValue();
+                for (Map.Entry<Integer, Features> occurrenceEntry : occurrenceMap.entrySet()) {
+                    Integer occurrence = occurrenceEntry.getKey();
+                    Features subFeatureInstance = occurrenceEntry.getValue();
+                    String newPrefix = prefix + "/" + subFeatureName + "/" + occurrence;
+                    subFeatureInstance.printTreeRecursive(newPrefix, showIgnored, masterIgnoreList);
+                }
+            }
+        }
+
+        // Recurse into categories, passing the master list along
+        if (this.categoriesForChildren != null) {
+            for (Map.Entry<String, Features> categoryEntry : this.categoriesForChildren.entrySet()) {
+                String categoryName = categoryEntry.getKey();
+                Features categoryFeature = categoryEntry.getValue();
+                String newPrefix = prefix + "/" + categoryName;
+                categoryFeature.printTreeRecursive(newPrefix, showIgnored, masterIgnoreList);
+            }
+        }
+    }
     // Helper method to persist the Features mapping to a file
     public void saveMapping(String filename) throws IOException {
         try (ObjectOutputStream oos = new ObjectOutputStream(Files.newOutputStream(Paths.get(filename)))) {
@@ -229,4 +429,4 @@ public class Features  implements Serializable {
             return (Features) ois.readObject();
         }
     }
-}
+}
\ No newline at end of file
diff --git a/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/LabeledState.java b/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/LabeledState.java
index a69a5e4c86..1a89d5a66b 100644
--- a/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/LabeledState.java
+++ b/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/LabeledState.java
@@ -2,6 +2,8 @@ package mage.player.ai;
 
 import java.io.*;
 import java.util.BitSet;
+import java.util.HashSet;
+import java.util.Set;
 
 /**
  * Represents a single training example: a bitset-encoded game state,
@@ -11,69 +13,78 @@ public class LabeledState implements Serializable {
     private static final long serialVersionUID = 1L;
 
     /** Bit-packed state vector of length S. */
-    public final BitSet stateVector;
+    public int[] stateVector;
     /** Index of the chosen action (one-hot). */
-    public final int actionIndex;
+    public final double[] actionVector;
     /** Value label (e.g., -1.0 for loss, +1.0 for win). */
     public final double resultLabel;
 
+
     /**
      * Construct a labeled state.
-     * @param stateBitset  BitSet of active features
-     * @param actionIdx    index of the chosen action
+     * @param stateIndices  indices of active features
+     * @param actionVec    vec of the action distribution
      * @param label        scalar outcome label
      */
-    public LabeledState(BitSet stateBitset, int actionIdx, double label) {
+    public LabeledState(Set<Integer> stateIndices, double[] actionVec, double label) {
         // clone to ensure immutability
-        this.stateVector = (BitSet) stateBitset.clone();
-        this.actionIndex = actionIdx;
+        this.stateVector = stateIndices.stream()                       // 1. Get a Stream<Integer>
+                .mapToInt(Integer::intValue)    // 2. Convert to IntStream (unboxes Integer to int)
+                .toArray();
+        this.actionVector = actionVec;
         this.resultLabel = label;
     }
+    public void compress(StateEncoder encoder) {
+        stateVector = encoder.getCompressedVectorArray(stateVector);
+    }
+    public void compress(Set<Integer> ignoreList) {
+        stateVector = FeatureMerger.getCompressedVectorArray(ignoreList, stateVector);
+    }
 
     /**
      * Persist this labeled state to the given DataOutputStream.
      * Caller must write header (record count, S, wordsPerState) before calling.
      * @param out            DataOutputStream to write to
-     * @param totalFeatures  total feature count S
      * @throws IOException   on I/O error
      */
-    public void persist(DataOutputStream out, int totalFeatures) throws IOException {
-        int wordsPerState = (totalFeatures + 63) >>> 6;  // ceil(S/64)
+    public void persist(DataOutputStream out) throws IOException {
+//        for (int j : stateVector) {
+//            if (j >= maxIndex) return; //dont persist a state with unfinalized features
+//        }
+        // 1) Write the NUMBER of active indices first.
+        out.writeInt(stateVector.length);
 
-        // pack stateVector into a fixed-size long[]
-        long[] raw = stateVector.toLongArray();
-        long[] packed = new long[wordsPerState];
-        System.arraycopy(raw, 0, packed, 0, raw.length);
-        for (long w : packed) {
-            out.writeLong(w);
+        // 2) Write only the active indices themselves.
+        for (int index : stateVector) {
+            out.writeInt(index);
         }
-
-        // write action index
-        out.writeInt(actionIndex);
-        // write result label
+        // --- The rest of the method remains the same ---
+        // 3) Write your action-distribution vector
+        for (double p : actionVector) {
+            out.writeDouble(p);
+        }
+        // 4) Write result label
         out.writeDouble(resultLabel);
     }
-
-    /**
-     * Load a single LabeledState from the given DataInputStream.
-     * Caller must have read header (S, wordsPerState) before calling.
-     * @param in             DataInputStream to read from
-     * @param totalFeatures  total feature count S
-     * @return               a new LabeledState
-     * @throws IOException   on I/O error
-     */
-    public static LabeledState load(DataInputStream in, int totalFeatures) throws IOException {
-        int wordsPerState = (totalFeatures + 63) >>> 6;
-
-        long[] packed = new long[wordsPerState];
-        for (int i = 0; i < wordsPerState; i++) {
-            packed[i] = in.readLong();
+    public void persist(DataOutputStream out, int mIndex) throws IOException {
+        // Convert the BitSet to an array of active indices
+        int count = 0;
+        for(int index : stateVector) {
+            if(index < mIndex) count++;
         }
-        BitSet state = BitSet.valueOf(packed);
-
-        int actionIdx = in.readInt();
-        double label  = in.readDouble();
+        // 1) Write the NUMBER of active indices first.
+        out.writeInt(count);
 
-        return new LabeledState(state, actionIdx, label);
+        // 2) Write only the active indices themselves.
+        for (int index : stateVector) {
+            if(index < mIndex) out.writeInt(index);
+        }
+        // --- The rest of the method remains the same ---
+        // 3) Write your action-distribution vector
+        for (double p : actionVector) {
+            out.writeDouble(p);
+        }
+        // 4) Write result label
+        out.writeDouble(resultLabel);
     }
 }
diff --git a/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/NeuralNetEvaluator.java b/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/NeuralNetEvaluator.java
index 8c48f16a57..d9f0a8a722 100644
--- a/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/NeuralNetEvaluator.java
+++ b/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/NeuralNetEvaluator.java
@@ -6,8 +6,8 @@ import ai.onnxruntime.OnnxTensor;
 import ai.onnxruntime.OnnxValue;
 import ai.onnxruntime.OrtException;
 
-import java.nio.FloatBuffer;
-import java.util.Collections;
+import java.nio.LongBuffer; // For int64 tensors
+import java.util.HashMap; // For multiple inputs
 import java.util.Map;
 import java.util.Optional;
 import java.util.concurrent.CompletableFuture;
@@ -16,85 +16,131 @@ import java.util.concurrent.Executors;
 
 /**
  * Lightweight ONNX Runtime wrapper for policy/value inference.
+ * Adapted for models expecting sparse indices and offsets (e.g., from EmbeddingBag).
  */
 public class NeuralNetEvaluator implements AutoCloseable {
 
     public static class InferenceResult {
         public final float[] policy;
-        public final float  value;
+        public final float value;
         public InferenceResult(float[] policy, float value) {
             this.policy = policy;
-            this.value  = value;
+            this.value = value;
         }
     }
 
-    private final OrtEnvironment  env;
-    private final OrtSession      session;
+    private final OrtEnvironment env;
+    private final OrtSession session;
     private final ExecutorService executor;
 
+    // You'll need to get these names by inspecting your exported ONNX model
+    // (e.g., using a tool like Netron)
+    private final String onnxIndicesInputName = "indices"; // Placeholder name
+    private final String onnxOffsetsInputName = "offsets"; // Placeholder name
+    private final String onnxPolicyOutputName = "policy";  // Assuming this remains the same
+    private final String onnxValueOutputName = "value";    // Assuming this remains the same
+
+
     public NeuralNetEvaluator(String onnxPath) throws OrtException {
         this(onnxPath,
                 Math.max(1, Runtime.getRuntime().availableProcessors() - 1));
     }
 
     public NeuralNetEvaluator(String onnxPath, int threads) throws OrtException {
-        // 1) Shared environment
         this.env = OrtEnvironment.getEnvironment();
-
-        // 2) Tune session options via nested SessionOptions
         OrtSession.SessionOptions opts = new OrtSession.SessionOptions();
         opts.setOptimizationLevel(OrtSession.SessionOptions.OptLevel.ALL_OPT);
-        opts.setIntraOpNumThreads(1);
-        opts.setInterOpNumThreads(1);
-
-        // 3) Thread-safe session (parsed once at startup)
+        opts.setIntraOpNumThreads(1); // Good for when executor handles parallelism
+        opts.setInterOpNumThreads(1); // Good for when executor handles parallelism
         this.session = env.createSession(onnxPath, opts);
-
-        // 4) Executor for non-blocking inference
         this.executor = Executors.newFixedThreadPool(Math.max(1, threads));
     }
 
-    public InferenceResult infer(float[] state) {
-        try (
-                OnnxTensor input = OnnxTensor.createTensor(
-                        env,
-                        FloatBuffer.wrap(state),
-                        new long[]{1, state.length}
-                );
-                OrtSession.Result res = session.run(
-                        Collections.singletonMap("state_input", (OnnxTensor)input)
-                )
-        ) {
-            // policy tensor
-            Optional<OnnxValue> optP = res.get("policy");
+    /**
+     * Performs inference using sparse feature indices.
+     * @param activeGlobalIndices Array of active global feature indices for the state.
+     * @return InferenceResult containing policy and value.
+     */
+    public InferenceResult infer(long[] activeGlobalIndices) { // Changed signature
+        // For single sample inference, offsets tensor is just [0]
+        long[] offsets = new long[]{0};
+
+        // The shape of the indices tensor is [num_active_indices]
+        long[] indicesShape = new long[]{activeGlobalIndices.length};
+        // The shape of the offsets tensor is [batch_size], which is 1 here
+        long[] offsetsShape = new long[]{1};
+
+
+        Map<String, OnnxTensor> inputs = null;
+        OrtSession.Result outputs = null;
+        OnnxTensor indicesTensor = null;
+        OnnxTensor offsetsTensor = null;
+
+        try {
+            indicesTensor = OnnxTensor.createTensor(
+                    env,
+                    LongBuffer.wrap(activeGlobalIndices),
+                    indicesShape
+            );
+            offsetsTensor = OnnxTensor.createTensor(
+                    env,
+                    LongBuffer.wrap(offsets),
+                    offsetsShape
+            );
+
+            inputs = new HashMap<>();
+            inputs.put(onnxIndicesInputName, indicesTensor);
+            inputs.put(onnxOffsetsInputName, offsetsTensor);
+
+            outputs = session.run(inputs);
+
+            // Policy tensor
+            Optional<OnnxValue> optP = outputs.get(onnxPolicyOutputName);
             if (!optP.isPresent()) {
-                throw new RuntimeException("Missing 'policy' output from ONNX model");
+                throw new RuntimeException("Missing '" + onnxPolicyOutputName + "' output from ONNX model");
             }
             OnnxTensor policyTensor = (OnnxTensor) optP.get();
-            float[] policy = ((float[][]) policyTensor.getValue())[0];
+            float[] policy = ((float[][]) policyTensor.getValue())[0]; // Assumes policy output shape [1, policy_dim]
 
-            // value tensor
-            Optional<OnnxValue> optV = res.get("value");
+            // Value tensor
+            Optional<OnnxValue> optV = outputs.get(onnxValueOutputName);
             if (!optV.isPresent()) {
-                throw new RuntimeException("Missing 'value' output from ONNX model");
+                throw new RuntimeException("Missing '" + onnxValueOutputName + "' output from ONNX model");
             }
             OnnxTensor valueTensor = (OnnxTensor) optV.get();
-            float value = ((float[]) valueTensor.getValue())[0];
+            float[] valueArray = (float[]) valueTensor.getValue();
+            // Access the first (and only) element of the 1D array.
+            float value = valueArray[0];
 
             return new InferenceResult(policy, value);
         } catch (OrtException e) {
             throw new RuntimeException("ONNX inference failed", e);
+        } finally {
+            // Ensure tensors are closed to free native memory
+            if (indicesTensor != null) indicesTensor.close();
+            if (offsetsTensor != null) offsetsTensor.close();
+            if (outputs != null) outputs.close();
+            // The 'inputs' map itself doesn't need explicit closing if its OnnxTensor values are closed.
         }
     }
 
-    public CompletableFuture<InferenceResult> inferAsync(float[] state) {
-        return CompletableFuture.supplyAsync(() -> infer(state), executor);
+    /**
+     * Performs asynchronous inference using sparse feature indices.
+     * @param activeGlobalIndices Array of active global feature indices for the state.
+     * @return CompletableFuture<InferenceResult> containing policy and value.
+     */
+    public CompletableFuture<InferenceResult> inferAsync(long[] activeGlobalIndices) { // Changed signature
+        return CompletableFuture.supplyAsync(() -> infer(activeGlobalIndices), executor);
     }
 
     @Override
     public void close() throws OrtException {
-        session.close();
-        env.close();
-        executor.shutdown();
+        if (session != null) session.close();
+        // OrtEnvironment.getEnvironment() is a singleton; closing it here might affect other users.
+        // Usually, you close it when the application is shutting down if you obtained it via getEnvironment().
+        // If you created it with OrtEnvironment.create(), then you must close it.
+        // For simplicity, let's assume it's fine if only this class uses it.
+        // env.close(); // Be cautious with closing the shared environment.
+        if (executor != null) executor.shutdown();
     }
-}
+}
\ No newline at end of file
diff --git a/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/ReplayBuffer.java b/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/ReplayBuffer.java
new file mode 100644
index 0000000000..1b7b322fa7
--- /dev/null
+++ b/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/ReplayBuffer.java
@@ -0,0 +1,94 @@
+package mage.player.ai;
+
+import mage.game.Game;
+import mage.game.GameState;
+import mage.util.RandomUtil;
+
+import java.io.Serializable;
+import java.util.*;
+import java.util.concurrent.ConcurrentLinkedDeque;
+
+/**
+ * A fixed-size replay buffer to store experiences for training reinforcement learning models.
+ * It acts as a sliding window (FIFO): when the buffer is full, adding a new element
+ * removes the oldest one. This class is thread-safe for additions.
+ */
+public class ReplayBuffer implements Serializable {
+    private static final long serialVersionUID = 1L; // For serialization
+    private final Deque<Game> buffer;
+    private final int capacity;
+    private final Random random = new Random();
+
+    public ReplayBuffer(int capacity) {
+        this.capacity = capacity;
+        // Use a thread-safe Deque to allow additions from multiple game-playing threads if needed in the future.
+        this.buffer = new ConcurrentLinkedDeque<>();
+    }
+
+    /**
+     * Adds a single GameState to the buffer.
+     * If the buffer is at capacity, the oldest element is removed.
+     *
+     * @param state The GameState to add.
+     */
+    public synchronized void add(Game state) {
+        if (buffer.size() >= capacity) {
+            buffer.pollFirst(); // Remove the oldest element
+        }
+        buffer.add(state);
+    }
+
+    /**
+     * Adds a collection of GameStates to the buffer.
+     *
+     * @param states The collection of states from a completed game.
+     */
+    public void addAll(Collection<Game> states) {
+        for (Game state : states) {
+            add(state); // Use the synchronized add method
+        }
+    }
+
+    /**
+     * Samples a random batch of GameStates from the buffer.
+     *
+     * @param batchSize The number of states to sample.
+     * @return A list containing the sampled GameStates. Returns an empty list if the buffer is empty.
+     */
+    public List<Game> sample(int batchSize) {
+        // Create a temporary list for random access, as Deque doesn't support get(index)
+        List<Game> tempList = new ArrayList<>(buffer);
+        if (tempList.isEmpty()) {
+            return new ArrayList<>();
+        }
+
+        List<Game> sampleBatch = new ArrayList<>();
+        for (int i = 0; i < batchSize; i++) {
+            int randomIndex = RandomUtil.nextInt(tempList.size());
+            sampleBatch.add(tempList.get(randomIndex));
+        }
+        return sampleBatch;
+    }
+
+    /**
+     * Returns the current number of elements in the buffer.
+     *
+     * @return The size of the buffer.
+     */
+    public int size() {
+        return buffer.size();
+    }
+
+    /**
+     * Returns the maximum capacity of the buffer.
+     *
+     * @return The capacity.
+     */
+    public int getCapacity() {
+        return capacity;
+    }
+
+    public boolean isReadyForSampling(int requiredSize) {
+        return buffer.size() >= requiredSize;
+    }
+}
\ No newline at end of file
diff --git a/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/StateEncoder.java b/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/StateEncoder.java
index cdd3e9485b..31de2e0c32 100644
--- a/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/StateEncoder.java
+++ b/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/StateEncoder.java
@@ -1,6 +1,5 @@
 package mage.player.ai;
 
-import com.j256.ormlite.stmt.query.In;
 import mage.MageObject;
 import mage.abilities.*;
 import mage.abilities.costs.Cost;
@@ -8,7 +7,6 @@ import mage.abilities.costs.Costs;
 import mage.abilities.costs.mana.ManaCost;
 import mage.abilities.costs.mana.ManaCosts;
 import mage.abilities.effects.Effect;
-import mage.abilities.mana.ManaOptions;
 import mage.cards.Card;
 import mage.cards.Cards;
 import mage.constants.CardType;
@@ -31,37 +29,30 @@ import java.util.*;
 /**
  * Deck specific state encoder for reinforcement learning.
  * Before vectors can be made, the encoder must learn all game features of
- * the given 60 card decks through a first pass of 1,000 simulated mcst games
+ * the given 60 card decks through a first pass of 1,000 simulated mcst and minimax games
  */
 public class StateEncoder {
     public static int indexCount;
-    public static int reducedIndexCount;
-    private int originalVectorSize;
     private Features features;
-    public static BitSet featureVector;
-    public static boolean[] reducedFeatureVector;
-    public static int[] rawToReduced;
-    public static Map<Integer, boolean[][]> pendingFeatures; //maps raw index to occurrence matrix for cohort
+    public Set<Integer> featureVector = new HashSet<>();
     private UUID opponentID;
     private UUID myPlayerID;
-    public List<BitSet> macroStateVectors = new ArrayList<>();
-    public List<BitSet> microStateVectors = new ArrayList<>();
+    public List<Set<Integer>> macroStateVectors = new ArrayList<>();
+    public List<Set<Integer>> microStateVectors = new ArrayList<>();
+    public List<Boolean> activeStates = new ArrayList<>();
 
-    public List<Integer> stateScores = new ArrayList<>();
+    public List<Double> stateScores = new ArrayList<>();
+    public List<double[]> actionVectors = new ArrayList<>();
+    public int initialRawSize = 0;//original max index
+    public int mappingVersion = 0;
 
     public Set<Integer> ignoreList;
 
     public StateEncoder() {
         //using statics for convenience for now
-        indexCount = 0;
-        reducedIndexCount = 1; //pending features map to zero
-        originalVectorSize = 0;
+        //indexCount = 0;
         features = new Features();
-        featureVector = new BitSet(30000);
-        reducedFeatureVector = new boolean[5000];
-        rawToReduced = new int[30000];
-        Arrays.fill(rawToReduced, 0);
-        pendingFeatures = new HashMap<>();
+        features.setEncoder(this);
         ignoreList = new HashSet<>();
     }
     public void setAgent(UUID me) {
@@ -70,8 +61,12 @@ public class StateEncoder {
     public void setOpponent(UUID op) {
         opponentID = op;
     }
+    public Features getFeatures() {return features;}
+    public synchronized UUID getMyPlayerID() {return myPlayerID;}
+    public synchronized void addAction(double[] actionVec) { actionVectors.add(actionVec); }
 
     public void processManaCosts(ManaCosts<ManaCost> manaCost, Game game, Features f, Boolean callParent) {
+        if(f == null) return;
         //f.addFeature(manaCost.getText());
         f.addNumericFeature("ManaValue", manaCost.manaValue(), callParent);
         for(ManaCost mc : manaCost) {
@@ -87,6 +82,7 @@ public class StateEncoder {
         }
     }
     public void processAbility(Ability a, Game game, Features f) {
+        if(f == null) return;
         Costs<Cost> c = a.getCosts();
         //for now lets not worry about encoding costs per abilities
         /*ManaCosts<ManaCost> mcs = a.getManaCostsToPay();
@@ -94,18 +90,20 @@ public class StateEncoder {
             Features costFeature = f.getSubFeatures("AbilityCost");
             processCosts(c, mcs, game, costFeature, false); //dont propagate mana cost up for abilities
         }*/
-        for(Effect e : a.getAllEffects()) {
-            for(Mode m : a.getModes().getAvailableModes(a, game)) {
-                f.addFeature(e.getText(m));
+        for(Mode m : a.getModes().getAvailableModes(a, game)) {
+            for(Effect e : m.getEffects()) {
+                f.parent.addFeature(e.getText(m));//only add feature for abstraction (isn't dynamic)
             }
         }
     }
     public void processActivatedAbility(ActivatedAbility aa, Game game, Features f) {
+        if(f == null) return;
         processAbility(aa, game, f);
 
         if(aa.canActivate(myPlayerID, game).canActivate()) f.addFeature("CanActivate"); //use aa.canActivate()
     }
     public void processTriggeredAbility(TriggeredAbility ta, Game game, Features f) {
+        if(f == null) return;
         processAbility(ta, game, f);
 
         if(!ta.checkTriggeredLimit(game)) f.addFeature("ReachedTriggerLimit"); //use ta.checkTriggeredLimit()
@@ -114,7 +112,7 @@ public class StateEncoder {
 
     }
     public void processCard(Card c, Game game, Features f) {
-
+        if(f == null) return;
         f.parent.addFeature("Card");//raw universal type of card added for counting purposes
 
         if(c.isPermanent()) f.addCategory("Permanent");
@@ -124,7 +122,7 @@ public class StateEncoder {
         }
         //add subtypes
         for (SubType st : c.getSubtype(game)) {
-            f.addCategory(st.name());
+            if(!st.name().isEmpty()) f.addCategory(st.name());
         }
         //add color
         if(c.getColor(game).isRed()) f.addCategory("RedCard");
@@ -154,6 +152,7 @@ public class StateEncoder {
 
     }
     public void processPermBattlefield(Permanent p, Game game, Features f) {
+        if(f == null) return;
         processCard(p, game, f);
         //is tapped?
         if(p.isTapped()) f.addFeature("Tapped");
@@ -161,6 +160,7 @@ public class StateEncoder {
         //process attachments
         for (UUID id : p.getAttachments()) {
             Permanent attachment = game.getPermanent(id);
+            if(attachment == null) continue;
             //modify name to not count auras/equipment twice
             f.passToParent = false; //don't pass pooled attachment features up, or they will be counted twice
             Features attachmentFeatures = f.getSubFeatures(attachment.getName());
@@ -187,10 +187,12 @@ public class StateEncoder {
         }
         if(p.isCreature(game)) {
             if(p.canAttack(opponentID, game)) f.addFeature("CanAttack"); //use p.canAttack()
-            if(p.canBlock(opponentID, game)) f.addFeature("CanBlock"); //use p.canBlock()
+            if(p.canBlockAny(game)) f.addFeature("CanBlock");
+            f.addNumericFeature("Damage", p.getDamage());
         }
     }
     public void processCardInGraveyard(Card c, Game game, Features f) {
+        if(f == null) return;
         //process as card
         processCard(c, game, f);
         //process abilities in gy
@@ -212,6 +214,7 @@ public class StateEncoder {
 
     }
     public void processCardInHand(Card c, Game game, Features f) {
+        if(f == null) return;
         //process as card
         processCard(c, game, f);
         //process abilities in hand
@@ -234,38 +237,45 @@ public class StateEncoder {
         }
     }
     public void processBattlefield(Battlefield bf, Game game, Features f, UUID playerID) {
+        if(f == null) return;
         for (Permanent p : bf.getAllActivePermanents(playerID)) {
             Features permFeatures = f.getSubFeatures(p.getName());
             processPermBattlefield(p, game, permFeatures);
         }
     }
     public void processGraveyard(Graveyard gy, Game game, Features f) {
+        if(f == null) return;
         for (Card c : gy.getCards(game)) {
             Features graveCardFeatures = f.getSubFeatures(c.getName());
             processCardInGraveyard(c, game, graveCardFeatures);
         }
     }
     public void processHand(Cards hand, Game game, Features f) {
+        if(f == null) return;
         for (Card c : hand.getCards(game)) {
             Features handCardFeatures = f.getSubFeatures(c.getName());
             processCardInHand(c, game, handCardFeatures);
         }
     }
     public void processStackObject(StackObject so, int stackPosition, Game game, Features f) {
+        if(f == null) return;
         f.addNumericFeature("StackPosition", stackPosition, false);
         if(so.getControllerId()==myPlayerID) f.addFeature("isController");
         Ability sa = so.getStackAbility();
         if(sa instanceof TriggeredAbility) {
             processTriggeredAbility((TriggeredAbility) sa, game, f);
         } else {
-            processAbility(sa, game, f);
-        }
-        MageObject source = game.getObject(so.getSourceId());
-        for (Ability a : source.getAbilities().getStaticAbilities(Zone.STACK)) {
-            f.addFeature(a.toString());
+            processActivatedAbility((ActivatedAbility)sa, game, f);
+            if(sa instanceof SpellAbility) {
+                MageObject source = game.getObject(so.getSourceId());
+                for (Ability a : source.getAbilities().getStaticAbilities(Zone.STACK)) {
+                    f.addFeature(a.toString());
+                }
+            }
         }
     }
     public void processStack(SpellStack stack, Game game, Features f) {
+        if(f == null) return;
         Iterator<StackObject> itr = stack.descendingIterator();
         StackObject so;
         f.addNumericFeature("StackSize", stack.size());
@@ -277,8 +287,23 @@ public class StateEncoder {
             processStackObject(so, i, game, soFeatures);
         }
     }
-    public void processOpponentState(Game game) {
-        Player myPlayer = game.getPlayer(opponentID);
+    public void processManaPool(ManaPool mp, Game game,  Features f) {
+        if(f == null) return;
+        f.addNumericFeature("GreenMana", mp.getGreen());
+        f.addNumericFeature("RedMana", mp.getRed());
+        f.addNumericFeature("BlueMana", mp.getBlue());
+        f.addNumericFeature("WhiteMana", mp.getWhite());
+        f.addNumericFeature("BlackMana", mp.getBlack());
+        f.addNumericFeature("ColorlessMana", mp.getColorless());
+        //TODO: deal with conditional mana
+    }
+    public void processOpponentState(Game game, UUID activePlayerID) {
+        //switch for perspective reasons
+        UUID temp = myPlayerID;
+        myPlayerID = opponentID;
+        opponentID = temp;
+
+        Player myPlayer = game.getPlayer(myPlayerID);
         //game metadata
         features.addNumericFeature("OpponentLifeTotal", myPlayer.getLife());
         if(myPlayer.canPlayLand()) features.addFeature("OpponentCanPlayLand"); //use features.addFeature(myPlayer.canPlayLand())
@@ -289,7 +314,7 @@ public class StateEncoder {
         //start with battlefield
         Battlefield bf = game.getBattlefield();
         Features bfFeatures = features.getSubFeatures("OpponentBattlefield");
-        processBattlefield(bf, game, bfFeatures, opponentID);
+        processBattlefield(bf, game, bfFeatures, myPlayerID);
 
         //now do graveyard
         Graveyard gy = myPlayer.getGraveyard();
@@ -298,29 +323,29 @@ public class StateEncoder {
 
         //now do hand (cards are face down so only keep count of number of cards
         // TODO: keep track of face up cards and exile
-        Cards hand = myPlayer.getHand();
-        features.addNumericFeature("OpponentCardsInHand", hand.size());
+        if(myPlayerID==activePlayerID) { //invert perspective
+            Cards hand = myPlayer.getHand();
+            Features handFeatures = features.getSubFeatures("Hand");
+            processHand(hand, game, handFeatures);
+        } else {
+            Cards hand = myPlayer.getHand();
+            features.addNumericFeature("OpponentCardsInHand", hand.size());
+        }
+        //switch back
+        opponentID = myPlayerID;
+        myPlayerID = temp;
 
     }
-    public void processManaPool(ManaPool mp, Game game,  Features f) {
-        f.addNumericFeature("GreenMana", mp.getGreen());
-        f.addNumericFeature("RedMana", mp.getRed());
-        f.addNumericFeature("BlueMana", mp.getBlue());
-        f.addNumericFeature("WhiteMana", mp.getWhite());
-        f.addNumericFeature("BlackMana", mp.getBlack());
-        f.addNumericFeature("ColorlessMana", mp.getColorless());
-        //TODO: deal with conditional mana
-    }
-    public void processState(Game game) {
+    public synchronized void processState(Game game, UUID actingPlayerID) {
         features.stateRefresh();
         featureVector.clear();
-        Arrays.fill(reducedFeatureVector, false);
 
         Player myPlayer = game.getPlayer(myPlayerID);
 
         //game metadata
-        features.addFeature(game.getPhase().getType().name());
+        features.addFeature(game.getTurnStepType().toString()); //phases
         if(game.isActivePlayer(myPlayerID)) features.addFeature("IsActivePlayer");
+        if(actingPlayerID==myPlayerID) features.addFeature("IsActingPlayer");
         features.addNumericFeature("LifeTotal", myPlayer.getLife());
         if(myPlayer.canPlayLand()) features.addFeature("CanPlayLand"); //use features.addFeature(myPlayer.canPlayLand())
 
@@ -343,98 +368,90 @@ public class StateEncoder {
         processGraveyard(gy, game, gyFeatures);
 
         //now do hand
-        Cards hand = myPlayer.getHand();
-        Features handFeatures = features.getSubFeatures("Hand");
-        processHand(hand, game, handFeatures);
-
+        if(myPlayerID==actingPlayerID) { //keep perspective
+            Cards hand = myPlayer.getHand();
+            Features handFeatures = features.getSubFeatures("Hand");
+            processHand(hand, game, handFeatures);
+        } else {
+            assert (false);
+            Cards hand = myPlayer.getHand();
+            features.addNumericFeature("OpponentCardsInHand", hand.size());
+        }
         //TODO: add exile
 
         //lastly do opponent
-        processOpponentState(game);
+        processOpponentState(game, actingPlayerID);
+
+        //mapping version
+        features.addNumericFeature("Mapping Version", features.version);
 
-        //update reduced vector
-        //updateReducedVector();
-        //stateVectors.add(Arrays.copyOf(featureVector, 30000));
     }
-    public void processMicroState(Game game) {
-        processState(game);
-        microStateVectors.add((BitSet) featureVector.clone());
+    public void processMicroState(Game game, UUID actingPlayerID) {
+        processState(game, actingPlayerID);
+        microStateVectors.add(new HashSet<>(featureVector));
     }
-    public void processMacroState(Game game) {
-        processState(game);
-        macroStateVectors.add((BitSet) featureVector.clone());
+    public synchronized void processMacroState(Game game, UUID actingPlayerID) {
+        processState(game, actingPlayerID);
+        macroStateVectors.add(new HashSet<>(featureVector));
+        //activeStates.add(game.getActivePlayerId() == myPlayerID);
     }
-
-    /*
-    public void updateReducedVector() {
-        //map normal features
-        for(int i = 0; i < originalVectorSize; i++) {
-            if(!featureVector[i]) continue;
-            int reducedIndex = rawToReduced[i]; //pending features map to zero
-            reducedFeatureVector[reducedIndex] = true;
-        }
-        //update matrix for each pending feature
-        for (int f : pendingFeatures.keySet()) {
-            boolean[][] m = pendingFeatures.get(f);
-            boolean allIndependent = true;
-            for(int i = 1; i < m.length; i++) {
-                if(rawToReduced[i+f] != 0) continue;//only care to check un finalized features
-                boolean isIndependent = true;
-                for(int j = 0; j < m.length; j++) {
-                    m[i][j] = (featureVector[i+f] != featureVector[j+f]) || m[i][j]; //don't change if true
-                    if(rawToReduced[j+f] != 0 && !m[i][j]) {//compared to feature is finalized and they aren't independent
-                        isIndependent = false;
-                    }
-                }
-                if(isIndependent) {
-                    //finalize feature if independent (and hasn't been finalized)
-                    System.out.printf("pending feature at raw index %d has been finalized at reduced index %d\n", i+f, reducedIndexCount);
-                    rawToReduced[i+f] = reducedIndexCount;
-                    reducedFeatureVector[reducedIndexCount++] = featureVector[i+f]; //can be added silently (feature itself didn't fire)
-                } else {
-                    allIndependent = false;
-                }
-            }
-            if(allIndependent) {
-                pendingFeatures.remove(f);
-                System.out.printf("entire pending batch from %d has been successfully finalized\n", f);
+    /**
+     * Takes an array of raw indices, filters out those present in the ignoreList,
+     * and returns a new array of the remaining indices.
+     *
+     * @param rawIndices The input array of feature indices.
+     * @return A new int[] containing only the indices not in the ignoreList.
+     */
+    public int[] getCompressedVectorArray(int[] rawIndices) {
+        Set<Integer> filteredIndicesSet = new HashSet<>();
+
+        for (int index : rawIndices) {
+            if (!this.ignoreList.contains(index)) { // Assuming ignoreList is a member
+                filteredIndicesSet.add(index);
             }
         }
-        //matrix for batch of new features
-        int batchSize = indexCount - originalVectorSize;
-        boolean[][] occurrenceMatrix = new boolean[batchSize][batchSize]; //maps if 2 features occurred independently for each pair
-        if(batchSize > 0) {
-            //add first new feature to reduced vector
-            System.out.printf("new reduced feature at raw index %d has been finalized at reduced index %d representing a batch of %d new features\n", originalVectorSize, reducedIndexCount, batchSize);
-            rawToReduced[originalVectorSize] = reducedIndexCount;
-            reducedFeatureVector[reducedIndexCount++] = true;
-            pendingFeatures.put(originalVectorSize, occurrenceMatrix); //pending features are stored in by their first feature in batch
 
-        }
-        //lastly update original size
-        originalVectorSize = indexCount;
+        // Convert the Set<Integer> to an int[]
+        return filteredIndicesSet.stream()
+                .mapToInt(Integer::intValue)
+                .toArray();
     }
-    */
-    public boolean[] getCompressedVector(BitSet rawState) {
-        boolean[] state = new boolean[4000];
-        for(int k = 0, j = 0; j < indexCount && k < 4000; j++) {
-            if(!ignoreList.contains(j)) {
-                state[k++] = rawState.get(j);
+    public Set<Integer> getCompressedVector(Set<Integer> rawIndices) {
+        Set<Integer> filteredIndicesSet = new HashSet<>();
+
+        for (int index : rawIndices) {
+            if (!this.ignoreList.contains(index)) { // Assuming ignoreList is a member
+                filteredIndicesSet.add(index);
             }
         }
-        return state;
+        return filteredIndicesSet;
+    }
+    public synchronized int[] getFinalActiveGlobalIndicesArray() {
+        Set<Integer> out1 = getCompressedVector(featureVector);
+        return out1.stream().mapToInt(Integer::intValue).toArray();
+
     }
     // Persist the persistent feature mapping
     public void persistMapping(String filename) throws IOException {
-        features.globalIndexCount = indexCount;
-        features.ignoreList = ignoreList;
+        //features.localIndexCount = indexCount;
+        //features.ignoreList = new HashSet<>(ignoreList);
+        features.version = mappingVersion;
         features.saveMapping(filename);
     }
 
     // Load the feature mapping from file
     public void loadMapping(String filename) throws IOException, ClassNotFoundException {
         features = Features.loadMapping(filename);
-        indexCount = features.globalIndexCount;
-        ignoreList = features.ignoreList;
+        features.setEncoder(this);
+        //indexCount = features.localIndexCount;
+        //ignoreList = new HashSet<>(features.ignoreList);
+        //mappingVersion = features.version;
+        //initialRawSize = indexCount;
+    }
+    // Load the feature mapping from object
+    public void loadMapping(Features f) {
+        features = f.createDeepCopy();
+        features.setEncoder(this);
+
     }
 }
diff --git a/Mage.Server.Plugins/Mage.Player.AI/src/main/java/mage/player/ai/ComputerPlayer.java b/Mage.Server.Plugins/Mage.Player.AI/src/main/java/mage/player/ai/ComputerPlayer.java
index 8ccda6a0e0..afbe9b4a84 100644
--- a/Mage.Server.Plugins/Mage.Player.AI/src/main/java/mage/player/ai/ComputerPlayer.java
+++ b/Mage.Server.Plugins/Mage.Player.AI/src/main/java/mage/player/ai/ComputerPlayer.java
@@ -38,6 +38,7 @@ import mage.game.events.GameEvent;
 import mage.game.match.Match;
 import mage.game.permanent.Permanent;
 import mage.game.stack.Spell;
+import mage.game.stack.StackAbility;
 import mage.game.stack.StackObject;
 import mage.game.tournament.Tournament;
 import mage.player.ai.simulators.CombatGroupSimulator;
@@ -64,10 +65,14 @@ import java.util.Map.Entry;
  */
 public class ComputerPlayer extends PlayerImpl {
 
+    public Set<Set<UUID>> chooseTargetOptions = new HashSet<>();
+    public List<Set<UUID>> chooseTargetAction = new ArrayList<>();
+
     private static final Logger log = Logger.getLogger(ComputerPlayer.class);
     private long lastThinkTime = 0; // msecs for last AI actions calc
 
     protected int PASSIVITY_PENALTY = 5; // Penalty value for doing nothing if some actions are available (was 5)
+    public static boolean PRINT_DECISION_FALLBACKS = false;
 
     // debug only: set TRUE to debug simulation's code/games (on false sim thread will be stopped after few secs by timeout)
     protected boolean COMPUTER_DISABLE_TIMEOUT_IN_GAME_SIMULATIONS = false;
@@ -118,6 +123,8 @@ public class ComputerPlayer extends PlayerImpl {
 
     public ComputerPlayer(final ComputerPlayer player) {
         super(player);
+        chooseTargetOptions = new HashSet<>(player.chooseTargetOptions);
+        chooseTargetAction = new ArrayList<>(player.chooseTargetAction);
     }
 
     @Override
@@ -141,7 +148,7 @@ public class ComputerPlayer extends PlayerImpl {
 
     @Override
     public boolean choose(Outcome outcome, Target target, Ability source, Game game, Map<String, Serializable> options) {
-
+        if(PRINT_DECISION_FALLBACKS && name.equals("PlayerA")) System.out.println("choose: ");
         if (log.isDebugEnabled()) {
             log.debug("choose: " + outcome.toString() + ':' + target.toString());
         }
@@ -532,8 +539,9 @@ public class ComputerPlayer extends PlayerImpl {
 
     @Override
     public boolean chooseTarget(Outcome outcome, Target target, Ability source, Game game) {
+        if(PRINT_DECISION_FALLBACKS && name.equals("PlayerA")) System.out.println("chooseTarget: " + (source==null ? "null" : source.toString()));
         if (log.isDebugEnabled()) {
-            log.debug("chooseTarget: " + outcome.toString() + ':' + target.toString());
+            log.debug("chooseTarget: " + outcome.toString() + ':' + target.getTargetName() + ':' + (source==null ? "null" : source.toString()));
         }
 
         // target - real target, make all changes and add targets to it
@@ -1073,6 +1081,7 @@ public class ComputerPlayer extends PlayerImpl {
     } //end of chooseTarget method
 
     protected Card pickTarget(UUID abilityControllerId, List<Card> cards, Outcome outcome, Target target, Ability source, Game game) {
+        if(PRINT_DECISION_FALLBACKS && name.equals("PlayerA")) System.out.println("pickTarget: " + source.toString());
         Card card;
         while (!cards.isEmpty()) {
 
@@ -1097,6 +1106,7 @@ public class ComputerPlayer extends PlayerImpl {
 
     @Override
     public boolean chooseTargetAmount(Outcome outcome, TargetAmount target, Ability source, Game game) {
+        if(PRINT_DECISION_FALLBACKS && name.equals("PlayerA")) System.out.println("chooseTargetAmount: " + source.toString());
         // TODO: make same code for chooseTarget (without filter and target type dependence)
         if (log.isDebugEnabled()) {
             log.debug("chooseTarget: " + outcome.toString() + ':' + target.toString());
@@ -1904,6 +1914,7 @@ public class ComputerPlayer extends PlayerImpl {
 
     @Override
     public boolean chooseUse(Outcome outcome, String message, String secondMessage, String trueText, String falseText, Ability source, Game game) {
+        if(PRINT_DECISION_FALLBACKS && name.equals("PlayerA")) System.out.println("chooseUse: " + source.toString());
         log.debug("chooseUse: " + outcome.isGood());
         // Be proactive! Always use abilities, the evaluation function will decide if it's good or not
         // Otherwise some abilities won't be used by AI like LoseTargetEffect that has "bad" outcome
@@ -1913,7 +1924,10 @@ public class ComputerPlayer extends PlayerImpl {
 
     @Override
     public boolean choose(Outcome outcome, Choice choice, Game game) {
-        log.debug("choose 3");
+        if(PRINT_DECISION_FALLBACKS && name.equals("PlayerA")) System.out.println("choose2: " + choice.toString());
+        //log.info("choose 3");
+        // before falling back, dump the culprit
+        //System.out.println(choice.toString());
         //TODO: improve this
 
         // choose creature type
@@ -2020,6 +2034,7 @@ public class ComputerPlayer extends PlayerImpl {
 
     @Override
     public boolean chooseTarget(Outcome outcome, Cards cards, TargetCard target, Ability source, Game game) {
+        if(PRINT_DECISION_FALLBACKS && name.equals("PlayerA")) System.out.println("chooseTarget2: " + source.toString());
         if (cards == null || cards.isEmpty()) {
             return target.isRequired(source);
         }
@@ -2051,6 +2066,7 @@ public class ComputerPlayer extends PlayerImpl {
 
     @Override
     public boolean choose(Outcome outcome, Cards cards, TargetCard target, Ability source, Game game) {
+        if(PRINT_DECISION_FALLBACKS && name.equals("PlayerA")) System.out.println("choose3: " + source.toString());
         log.debug("choose 2");
         if (cards == null || cards.isEmpty()) {
             return true;
@@ -2128,13 +2144,14 @@ public class ComputerPlayer extends PlayerImpl {
 
     @Override
     public int chooseReplacementEffect(Map<String, String> effectsMap, Map<String, MageObject> objectsMap, Game game) {
-        log.debug("chooseReplacementEffect");
+        log.info("chooseReplacementEffect");
         //TODO: implement this
         return 0;
     }
 
     @Override
     public Mode chooseMode(Modes modes, Ability source, Game game) {
+        if(PRINT_DECISION_FALLBACKS && name.equals("PlayerA")) System.out.println("chooseMode: " + source.toString());
         log.debug("chooseMode");
         if (modes.getMode() != null && modes.getMaxModes(game, source) == modes.getSelectedModes().size()) {
             // mode was already set by the AI
@@ -2144,15 +2161,18 @@ public class ComputerPlayer extends PlayerImpl {
         // spell modes simulated by AI, see addModeOptions
         // trigger modes chooses here
         // TODO: add AI support to select best modes, current code uses first valid mode
+        List<Mode> allModes = modes.getAvailableModes(source, game);
+        //Collections.shuffle(allModes);
         AvailableMode:
-        for (Mode mode : modes.getAvailableModes(source, game)) {
+        for (Mode mode : allModes) {
             for (UUID selectedModeId : modes.getSelectedModes()) {
                 Mode selectedMode = modes.get(selectedModeId);
                 if (selectedMode.getId().equals(mode.getId())) {
                     continue AvailableMode;
                 }
             }
-            if (mode.getTargets().canChoose(source.getControllerId(), source, game)) { // and where targets are available
+            if (mode.getTargets().canChoose(source.getControllerId(), source, game)) {
+                // and where targets are available
                 return mode;
             }
         }
@@ -2161,6 +2181,7 @@ public class ComputerPlayer extends PlayerImpl {
 
     @Override
     public TriggeredAbility chooseTriggeredAbility(List<TriggeredAbility> abilities, Game game) {
+        if(PRINT_DECISION_FALLBACKS && name.equals("PlayerA")) System.out.println("chooseTriggeredAbility: " + abilities.toString());
         log.debug("chooseTriggeredAbility: " + abilities.toString());
         //TODO: improve this
         if (!abilities.isEmpty()) {
@@ -3052,6 +3073,9 @@ public class ComputerPlayer extends PlayerImpl {
 
         // restore used in AI simulations
         // all human players converted to computer and analyse
+        ComputerPlayer cPlayer = (ComputerPlayer)player;
+        chooseTargetOptions = new HashSet<>(cPlayer.chooseTargetOptions);
+        chooseTargetAction = new ArrayList<>(cPlayer.chooseTargetAction);
         this.human = false;
     }
 
diff --git a/Mage.Server.Plugins/Mage.Player.AIMCTS/pom.xml b/Mage.Server.Plugins/Mage.Player.AIMCTS/pom.xml
index d488c1ed04..f90a8210f8 100644
--- a/Mage.Server.Plugins/Mage.Player.AIMCTS/pom.xml
+++ b/Mage.Server.Plugins/Mage.Player.AIMCTS/pom.xml
@@ -30,6 +30,11 @@
             <artifactId>mage-player-ai</artifactId>
             <version>${project.version}</version>
         </dependency>
+        <dependency>
+            <groupId>org.apache.commons</groupId>
+            <artifactId>commons-math3</artifactId>
+            <version>3.6.1</version>
+        </dependency>
     </dependencies>
 
     <build>
diff --git a/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/ActionEncoder.java b/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/ActionEncoder.java
index 23e62ae152..c889ca5b02 100644
--- a/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/ActionEncoder.java
+++ b/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/ActionEncoder.java
@@ -1,46 +1,28 @@
 package mage.player.ai;
 
 import mage.abilities.Ability;
-import mage.abilities.SpellAbility;
-import mage.interfaces.Action;
-import sun.security.util.ArrayUtil;
 
-import java.io.IOException;
-import java.io.ObjectInputStream;
-import java.io.ObjectOutputStream;
-import java.io.Serializable;
-import java.nio.file.Files;
-import java.nio.file.Paths;
 import java.util.*;
-import java.util.stream.Collectors;
 
 public class ActionEncoder {
     public static int indexCount = 0;
     public static boolean printActions = false;
-    public static List<boolean[]> actionVectors = new ArrayList<>();
-    public static Map<Integer, String> reverseActionMap = new HashMap<>();
-    //public static boolean[] actionVector = new boolean[1000];
+    public static List<double[]> actionVectors = new ArrayList<>();
     public static Map<String, Integer> actionMap = new HashMap<>();
-    public static int addAction(Ability sa) {
+
+    public static synchronized void addAction(double[] label) {
+        actionVectors.add(label);
+    }
+    public static synchronized int getAction(Ability sa) {
         String name = sa.toString();
-        boolean[] actionVector = new boolean[128]; //inits with false's
         if(actionMap.containsKey(name)) {//already contains action
             if(printActions) System.out.printf("Action: %s already maps to index %d\n", name, actionMap.get(name));
         } else {
             actionMap.put(name, indexCount++);
             if(printActions) System.out.printf("New action: %s discovered, reserving index %d for this action\n", name, actionMap.get(name));
         }
-        actionVector[actionMap.get(name)] = true;
-        actionVectors.add(Arrays.copyOf(actionVector, 128));
-        //System.out.println(Arrays.toString(actionVector));
+        //actionIndices.add(actionMap.get(name));
         return actionMap.get(name);
     }
-    public static void makeInverseMap() {
-        Map<String ,Integer> original = actionMap;
-        Map<Integer, String> inverse = new HashMap<>();
-        for (Map.Entry<String, Integer> entry : original.entrySet()) {
-            inverse.put(entry.getValue(), entry.getKey());
-        }
-        reverseActionMap = inverse;
-    }
+
 }
diff --git a/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/ChooseTargetNextAction.java b/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/ChooseTargetNextAction.java
new file mode 100644
index 0000000000..a0ec97edbf
--- /dev/null
+++ b/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/ChooseTargetNextAction.java
@@ -0,0 +1,38 @@
+package mage.player.ai;
+
+import mage.abilities.Ability;
+import mage.abilities.ActivatedAbility;
+import mage.game.Game;
+import mage.target.Target;
+
+import java.util.*;
+
+public class ChooseTargetNextAction implements MCTSNodeNextAction {
+
+    @Override
+    public List<MCTSNode> performNextAction(MCTSNode node, MCTSPlayer player, Game game, String fullStateValue) {
+        List<MCTSNode> children = new ArrayList<>();
+        if(MCTSPlayer.PRINT_CHOOSE_DIALOGUES) System.out.println("expanding choose target");
+        // Get targets for the current ability
+        for (Set<UUID> targets: player.chooseTargetOptions) {
+            //create node to add option to
+            Game sim = game.getLastPriority().createSimulationForAI();
+            MCTSPlayer simPlayer2 = (MCTSPlayer) sim.getPlayer(player.getId());
+            MCTSPlayer simPlayer1 = (MCTSPlayer) sim.getPlayer(game.getLastPriorityPlayerId());
+            //simPlayer2.copyDialogues(player); //copy previous micro decisions
+            simPlayer2.chooseTargetAction.add(targets);
+            simPlayer1.activateAbility((ActivatedAbility) node.getAction().copy(), sim);
+            sim.resume();
+            MCTSNode newNode = new MCTSNode(node, sim, node.getAction().copy());
+            newNode.chooseTargetAction = new ArrayList<>(node.chooseTargetAction);
+            newNode.chooseTargetAction.add(targets);
+            children.add(newNode);
+        }
+        return children;
+    }
+
+    @Override
+    public void applyAction(MCTSNode node, MCTSPlayer player, Game game) {
+        //do nothing for now
+    }
+}
diff --git a/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/ComputerPlayerMCTS.java b/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/ComputerPlayerMCTS.java
index 2e61345f50..0d4c7b09d5 100644
--- a/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/ComputerPlayerMCTS.java
+++ b/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/ComputerPlayerMCTS.java
@@ -4,6 +4,7 @@ import mage.abilities.Ability;
 import mage.abilities.ActivatedAbility;
 import mage.abilities.common.PassAbility;
 import mage.cards.Card;
+import mage.constants.Outcome;
 import mage.constants.PhaseStep;
 import mage.constants.RangeOfInfluence;
 import mage.constants.Zone;
@@ -12,13 +13,13 @@ import mage.game.combat.Combat;
 import mage.game.combat.CombatGroup;
 import mage.player.ai.MCTSPlayer.NextAction;
 import mage.players.Player;
+import mage.target.Target;
 import mage.util.ThreadUtils;
 import mage.util.XmageThreadFactory;
 import org.apache.log4j.Logger;
 
-import java.util.ArrayList;
-import java.util.List;
-import java.util.UUID;
+import java.io.Serializable;
+import java.util.*;
 import java.util.concurrent.*;
 
 /**
@@ -31,18 +32,21 @@ public class ComputerPlayerMCTS extends ComputerPlayer {
     protected static final double THINK_TIME_MULTIPLIER = 1.0;
     protected static final boolean USE_MULTIPLE_THREADS = true;
 
-    protected transient MCTSNode root;
+    public transient MCTSNode root;
     protected int maxThinkTime;
     protected static final Logger logger = Logger.getLogger(ComputerPlayerMCTS.class);
-    protected int poolSize;
-
-    protected ExecutorService threadPoolSimulations = null;
-
+    public int poolSize = 2;
+    //public Set<Set<UUID>> chooseTargetOptions = new HashSet<>();
+    //public ArrayList<Set<UUID>> chosenChooseTargetActions = new ArrayList<>();
+    protected transient ExecutorService threadPoolSimulations = null;
+    //public static Game macroState;
+    //public static UUID macroPlayerId;
+    //public static Ability lastAction;
     public ComputerPlayerMCTS(String name, RangeOfInfluence range, int skill) {
         super(name, range);
         human = false;
         maxThinkTime = (int) (skill * THINK_TIME_MULTIPLIER);
-        poolSize = Runtime.getRuntime().availableProcessors();
+        //poolSize = 64;//Runtime.getRuntime().availableProcessors();
     }
 
     protected ComputerPlayerMCTS(UUID id) {
@@ -62,6 +66,7 @@ public class ComputerPlayerMCTS extends ComputerPlayer {
 
     @Override
     public boolean priority(Game game) {
+        chooseTargetAction.clear();
         if (game.getTurnStepType() == PhaseStep.UPKEEP) {
             if (!lastPhase.equals(game.getTurn().getValue(game.getTurnNum()))) {
                 logList(game.getTurn().getValue(game.getTurnNum()) + name + " hand: ", new ArrayList(hand.getCards(game)));
@@ -92,8 +97,9 @@ public class ComputerPlayerMCTS extends ComputerPlayer {
             Game sim = createMCTSGame(game);
             MCTSPlayer player = (MCTSPlayer) sim.getPlayer(playerId);
             player.setNextAction(action);
-            player.isRoot = true;
             root = new MCTSNode(playerId, sim);
+            root.chooseTargetAction = new ArrayList<>(chooseTargetAction);
+
         }
         applyMCTS(game, action);
         if (root != null && root.bestChild() != null) {
@@ -105,7 +111,7 @@ public class ComputerPlayerMCTS extends ComputerPlayer {
     protected void getNextAction(Game game, NextAction nextAction) {
         if (root != null) {
             MCTSNode newRoot;
-            newRoot = root.getMatchingState(game.getState().getValue(game, playerId));
+            newRoot = root.getMatchingState(game.getState().getValue(game, playerId), chooseTargetAction);
             if (newRoot != null) {
                 newRoot.emancipate();
             } else
@@ -141,6 +147,10 @@ public class ComputerPlayerMCTS extends ComputerPlayer {
             if (i < simulatedCombat.getGroups().size()) {
                 CombatGroup currentGroup = currentGroups.get(i);
                 CombatGroup simulatedGroup = simulatedCombat.getGroups().get(i);
+                if(currentGroup.getAttackers().isEmpty()) {
+                    System.out.println("Attacker not found - skipping");
+                    continue;
+                }
                 sb.append(game.getPermanent(currentGroup.getAttackers().get(0)).getName()).append(" with: ");
                 for (UUID blockerId : simulatedGroup.getBlockers()) {
                     // blockers can be added automaticly by requirement effects, so we must add only missing blockers
@@ -155,7 +165,36 @@ public class ComputerPlayerMCTS extends ComputerPlayer {
         logger.info(sb.toString());
         MCTSNode.logHitMiss();
     }
-
+    @Override
+    public boolean chooseTarget(Outcome outcome, Target target, Ability source, Game game) {
+        System.out.println("base choose target");
+        Set<UUID> possible = target.possibleTargets(getId(), game);
+        chooseTargetOptions.clear();
+        MCTSPlayer.getAllPossible(chooseTargetOptions, possible, target.copy(), source, game, getId());
+        getNextAction(game, NextAction.CHOOSE_TARGET);
+        Set<UUID> choice = root.chooseTargetAction.get(root.chooseTargetAction.size()-1);
+        for(UUID targetId : choice) {
+            Set<UUID> chosen = new HashSet<>();
+            if(target.canTarget(targetId, source, game)) {
+                target.addTarget(targetId, source, game);
+                chosen.add(targetId);
+                System.out.printf("Targeting %s\n", game.getObject(targetId).toString());
+            }
+            chooseTargetAction.add(chosen);
+        }
+        return target.isChosen(game);
+    }
+    @Override
+    public boolean choose(Outcome outcome, Target target, Ability source, Game game, Map<String, Serializable> options) {
+        if(game.getTurnNum()>1) {
+            //reroute to mcts simulator
+            return chooseTarget(outcome, target, source, game);
+        } else {
+            //reroute to default
+            System.out.println("falling back to default choose target");
+            return super.choose(outcome, target, source, game, options);
+        }
+    }
     protected long totalThinkTime = 0;
     protected long totalSimulations = 0;
 
@@ -302,13 +341,27 @@ public class ComputerPlayerMCTS extends ComputerPlayer {
      * @return a new game object with simulated players
      */
     protected Game createMCTSGame(Game game) {
+        return createMCTSGame(game, true);
+    }
+    protected Game createMCTSGame(Game game, boolean firstCall) {
         Game mcts = game.createSimulationForAI();
-
         for (Player copyPlayer : mcts.getState().getPlayers().values()) {
             Player origPlayer = game.getState().getPlayers().get(copyPlayer.getId());
             MCTSPlayer newPlayer = new MCTSPlayer(copyPlayer.getId());
             newPlayer.restore(origPlayer);
             newPlayer.setMatchPlayer(origPlayer.getMatchPlayer());
+            //dont shuffle here
+            mcts.getState().getPlayers().put(copyPlayer.getId(), newPlayer);
+        }
+        if(firstCall) {
+            mcts.setLastPriority(createMCTSGame(game.getLastPriority(), false));
+            assert (mcts.getLastPriority().getPlayer(playerId) instanceof MCTSPlayer);
+        }
+        mcts.resume();
+        return mcts;
+    }
+    public static void shuffleUnknowns(Game mcts, UUID playerId) {
+        for (Player newPlayer : mcts.getState().getPlayers().values()) {
             if (!newPlayer.getId().equals(playerId)) {
                 int handSize = newPlayer.getHand().size();
                 newPlayer.getLibrary().addAll(newPlayer.getHand().getCards(mcts), mcts);
@@ -316,18 +369,16 @@ public class ComputerPlayerMCTS extends ComputerPlayer {
                 newPlayer.getLibrary().shuffle();
                 for (int i = 0; i < handSize; i++) {
                     Card card = newPlayer.getLibrary().drawFromTop(mcts);
+                    assert (newPlayer.getLibrary().size() != 0);
+                    assert (card != null);
                     card.setZone(Zone.HAND, mcts);
                     newPlayer.getHand().add(card);
                 }
             } else {
                 newPlayer.getLibrary().shuffle();
             }
-            mcts.getState().getPlayers().put(copyPlayer.getId(), newPlayer);
         }
-        mcts.resume();
-        return mcts;
     }
-
     protected void displayMemory() {
         long heapSize = Runtime.getRuntime().totalMemory();
         long heapMaxSize = Runtime.getRuntime().maxMemory();
diff --git a/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/MCTSExecutor.java b/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/MCTSExecutor.java
index 467e4d6e05..aa7a7e3691 100644
--- a/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/MCTSExecutor.java
+++ b/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/MCTSExecutor.java
@@ -1,5 +1,7 @@
 package mage.player.ai;
 
+import java.util.ArrayList;
+import java.util.HashSet;
 import java.util.UUID;
 import java.util.concurrent.Callable;
 
@@ -14,6 +16,7 @@ public class MCTSExecutor implements Callable<Boolean> {
     protected UUID playerId;
     protected int simCount;
     public boolean reachedTerminalState = false;
+    private volatile boolean stateUpdatesComplete = false;
 
     private static final Logger logger = Logger.getLogger(ComputerPlayerMCTS.class);
 
@@ -22,6 +25,14 @@ public class MCTSExecutor implements Callable<Boolean> {
         this.thinkTime = thinkTime;
         this.simCount = 0;
         root = new MCTSNode(playerId, sim);
+        root.chooseTargetAction = new ArrayList<>(((MCTSPlayer) sim.getPlayer(playerId)).chooseTargetAction);
+    }
+    public MCTSExecutor(Game sim, UUID playerId, int thinkTime, MCTSNode givenRoot) {
+        this.playerId = playerId;
+        this.thinkTime = thinkTime;
+        this.simCount = 0;
+        root = new MCTSNode(playerId, sim);
+        if(givenRoot != null) root.chooseTargetAction = new ArrayList<>(givenRoot.chooseTargetAction);
     }
     public MCTSExecutor(UUID playerId, int thinkTime, MCTSNode givenRoot) {
         this.playerId = playerId;
@@ -36,48 +47,43 @@ public class MCTSExecutor implements Callable<Boolean> {
         this.reachedTerminalState = exec.reachedTerminalState;
         root = new MCTSNode(exec.root);
     }
+
     @Override
     public Boolean call() {
         //simCount = 0;
         MCTSNode current;
         // This loop termination is controlled externally by timeout.
-        while (true) {
-            if(simCount > 300) {
-                return true;
-            }
-            current = root;
+        long deadline = System.currentTimeMillis() + thinkTime * 1000L;
+        while (simCount <= 300 && !Thread.currentThread().isInterrupted()
+                && System.currentTimeMillis() < deadline) {
             simCount++;
-            // Selection: traverse until a leaf node is reached.
-            int testCount = 0;
-            while (!current.isLeaf()) {
-                current = current.select(this.playerId);
-                testCount++;
-                if(testCount > 1000) {
-                    System.out.println("stuck in selection");
+            synchronized (this) {
+                current = root;
+                // Selection: traverse until a leaf node is reached.
+                int testCount = 0;
+                while (!current.isLeaf()) {
+                    current = current.select(this.playerId);
+                    testCount++;
+                    if (testCount > 1000) {
+                        System.out.println("stuck in selection");
+                        break;
+                    }
                 }
+                double result;
+                if (!current.isTerminal()) {
+                    // Expansion:
+                    result = rollout(current);
+                    current.expand();
+                } else {
+                    reachedTerminalState = true;
+                    result = current.isWinner(this.playerId) ? 1 : -1;
+                }
+                // Backpropagation:
+                current.backpropagate(result);
+                this.stateUpdatesComplete = true;
             }
-            // Don't stop to eval state until stack is empty or limit reached
-//            int traverseCount = 0;
-//            while (!current.isTerminal() && traverseCount < 10
-//                    //&& (current.getNumChildren() == 1
-//                    //|| current.getGame().getTurnPhaseType() == TurnPhase.COMBAT
-//                    && !current.getGame().getStack().isEmpty()) {
-//                traverseCount++;
-//                current.expand();
-//                current = current.select(this.playerId);
-//            }
-            double result;
-            if (!current.isTerminal()) {
-                // Expansion:
-                result = rollout(current);
-                current.expand();
-            } else {
-                reachedTerminalState = true;
-                result = current.isWinner(this.playerId) ? 1 : -1;
-            }
-            // Backpropagation:
-            current.backpropagate(result);
         }
+        return true;
     }
 
     /**
@@ -88,7 +94,7 @@ public class MCTSExecutor implements Callable<Boolean> {
      * @return an integer evaluation of the node's state
      */
     protected double rollout(MCTSNode node) {
-        return node.simulate(this.playerId);//-1 or 1
+        return 0;//node.simulate(this.playerId);//-1 or 1
     }
 
     public MCTSNode getRoot() {
diff --git a/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/MCTSNextActionFactory.java b/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/MCTSNextActionFactory.java
index fb408fafa3..f5d85755f5 100644
--- a/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/MCTSNextActionFactory.java
+++ b/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/MCTSNextActionFactory.java
@@ -3,12 +3,13 @@ package mage.player.ai;
 import java.util.HashMap;
 
 public class MCTSNextActionFactory {
-    private static final HashMap<MCTSPlayer.NextAction, MCTSNodeNextAction> strategyMap = new HashMap<>();
+    public static final HashMap<MCTSPlayer.NextAction, MCTSNodeNextAction> strategyMap = new HashMap<>();
 
     static {
         strategyMap.put(MCTSPlayer.NextAction.PRIORITY, new PriorityNextAction());
         strategyMap.put(MCTSPlayer.NextAction.SELECT_BLOCKERS, new SelectBlockersNextAction());
         strategyMap.put(MCTSPlayer.NextAction.SELECT_ATTACKERS, new SelectAttackersNextAction());
+        strategyMap.put(MCTSPlayer.NextAction.CHOOSE_TARGET, new ChooseTargetNextAction());
     }
 
     public static MCTSNodeNextAction createNextAction(MCTSPlayer.NextAction nextAction) {
diff --git a/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/MCTSNode.java b/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/MCTSNode.java
index 682d2bcb95..8c86d33a83 100644
--- a/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/MCTSNode.java
+++ b/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/MCTSNode.java
@@ -12,11 +12,16 @@ import mage.abilities.PlayLandAbility;
 import mage.abilities.common.PassAbility;
 import mage.cards.Card;
 import mage.game.Game;
+import mage.game.GameState;
 import mage.game.combat.Combat;
 import mage.game.turn.Step.StepPart;
 import mage.players.Player;
 import mage.util.RandomUtil;
 import org.apache.log4j.Logger;
+import java.util.Random;
+import org.apache.commons.math3.distribution.GammaDistribution;
+import org.apache.commons.math3.distribution.GammaDistribution;
+import org.apache.commons.math3.random.JDKRandomGenerator;
 
 import static java.lang.Math.*;
 
@@ -31,19 +36,22 @@ public class MCTSNode {
     private static final double passRatioTolerance = 0.0;
     private static final Logger logger = Logger.getLogger(MCTSNode.class);
 
+
     private boolean stackIsEmpty = true;
 
     public int visits = 0;
     private int wins = 0;
-    private double score = 0;
-    private MCTSNode parent;
+    public double score = 0;
+    private MCTSNode parent = null;
     public final List<MCTSNode> children = new ArrayList<>();
-    private Ability action;
-    private Game game;
-    private Combat combat;
+    public Ability action;
+    public List<Set<UUID>> chooseTargetAction = new ArrayList<>();
+    private Game game;//only contains shared game
+
+    public Combat combat;
     private final String stateValue;
     private final String fullStateValue;
-    private UUID playerId;
+    public UUID playerId;
     private boolean terminal = false;
     public UUID targetPlayer;
     public int depth = 1;
@@ -59,6 +67,10 @@ public class MCTSNode {
         this.fullStateValue = game.getState().getValue(true, game);
         this.stackIsEmpty = game.getStack().isEmpty();
         this.terminal = game.checkIfGameIsOver();
+        this.action = game.getPlayer(game.getLastPriorityPlayerId()).getLastActivated();
+        if(this.action == null) {
+            logger.error("action in node is null\n");
+        }
         setPlayer();
         nodeCount = 1;
 //        logger.info(this.stateValue);
@@ -73,6 +85,7 @@ public class MCTSNode {
         this.terminal = game.checkIfGameIsOver();
         this.parent = parent;
         this.action = action;
+
         setPlayer();
         nodeCount++;
 //        logger.info(this.stateValue);
@@ -81,16 +94,19 @@ public class MCTSNode {
     protected MCTSNode(MCTSNode parent, Game game, Combat combat) {
         this.targetPlayer = parent.targetPlayer;
         this.game = game;
+        //this.gameState = game.getState().copy();
         this.combat = combat;
         this.stateValue = game.getState().getValue(game, targetPlayer);
         this.fullStateValue = game.getState().getValue(true, game);
         this.stackIsEmpty = game.getStack().isEmpty();
         this.terminal = game.checkIfGameIsOver();
         this.parent = parent;
+
         setPlayer();
         nodeCount++;
 //        logger.info(this.stateValue);
     }
+    //dont use
     protected MCTSNode(MCTSNode node) {
         combat = null; action = null; game = null;
         if(node.combat != null) combat = node.combat.copy();
@@ -118,54 +134,66 @@ public class MCTSNode {
 
     }
     private void setPlayer() {
-        if (game.getStep().getStepPart() == StepPart.PRIORITY) {
-            playerId = game.getPriorityPlayerId();
-        } else {
-            if (game.getTurnStepType() == PhaseStep.DECLARE_BLOCKERS) {
-                playerId = game.getCombat().getDefenders().iterator().next();
-            } else {
-                playerId = game.getActivePlayerId();
+        //System.out.println("this happening");
+        for (Player p : game.getPlayers().values()) {
+            MCTSPlayer mctsP = (MCTSPlayer) p;
+            if(mctsP.lastToAct) {
+                playerId = p.getId();
+                return;
             }
         }
+        if(game.checkIfGameIsOver()) {
+            logger.info("TERMINAL STATE\n");
+            return;
+        }
+        System.out.println("this should not happen");
+        assert (false);
+//        if (game.getStep().getStepPart() == StepPart.PRIORITY) {
+//            playerId = game.getPriorityPlayerId();
+//        } else {
+//            if (game.getTurnStepType() == PhaseStep.DECLARE_BLOCKERS) {
+//                playerId = game.getCombat().getDefenders().iterator().next();
+//            } else {
+//                playerId = game.getActivePlayerId();
+//            }
+//        }
     }
     public MCTSNode select(UUID targetPlayerId) {
-        double bestValue = Double.NEGATIVE_INFINITY;
-        double worstValue = Double.POSITIVE_INFINITY;
-        boolean isTarget = playerId.equals(targetPlayerId);
-        MCTSNode bestChild = null;
+        // Single‐child shortcut
         if (children.size() == 1) {
             return children.get(0);
         }
-        List<MCTSNode> unvisited = new ArrayList<>();
-        for (MCTSNode node: children) {
-            double uct;
-            if (node.visits > 0) {
-                uct = (node.score / (node.visits * 1.0));
-                if (isTarget) {
-                    uct += node.prior*(selectionCoefficient * Math.sqrt((visits*1.0)) / (1+node.visits));
-                    if (uct > bestValue) {
-                        bestChild = node;
-                        bestValue = uct;
-                    }
-                }
-                else {
-                    uct -= node.prior*(selectionCoefficient * Math.sqrt((visits*1.0)) / (1+node.visits));
-                    if (uct < worstValue) {
-                        bestChild = node;
-                        worstValue = uct;
-                    }
+
+        boolean isTarget = playerId.equals(targetPlayerId);
+        double sign = isTarget ? +1.0 : -1.0;
+
+        MCTSNode best    = null;
+        double bestVal = Double.NEGATIVE_INFINITY;
+
+        double sqrtN = Math.sqrt(visits);
+        double c = selectionCoefficient;
+        synchronized (children) {
+            for (MCTSNode child : children) {
+                // value term: 0 if unvisited, else average reward
+                double q = (child.visits > 0)
+                        ? (child.score / child.visits)
+                        : 0.0;
+                double passBonus = child.getAction() instanceof PassAbility ? 0.05 : 0;
+                // exploration term still blows up when visits==0
+                double u = 1 * (child.prior + 0.3 + passBonus) * (sqrtN / (1 + child.visits));
+
+                // combined PUCT
+                double val = sign * q + u;
+
+                if (val > bestVal) {
+                    bestVal = val;
+                    best = child;
                 }
             }
-            else {
-                // ensure that a random unvisited node is played first
-                unvisited.add(node);
-            }
-        }
-        if(!unvisited.isEmpty()) {
-            return unvisited.get(abs(RandomUtil.nextInt())%unvisited.size());
         }
-        assert (bestChild != null);
-        return bestChild;
+        // best should never be null once visits>0 on the root
+        assert best != null;
+        return best;
     }
 
     public void expand() {
@@ -173,37 +201,67 @@ public class MCTSNode {
         if (player.getNextAction() == null) {
             logger.fatal("next action is null");
         }
-        children.addAll(MCTSNextActionFactory.createNextAction(player.getNextAction()).performNextAction(this, player, game, fullStateValue));
-        for (MCTSNode node : children) {
-            node.depth = depth + 1;
-            node.prior = 1.0;///children.size();
-        }
-        if(policy != null) {
-            // 2) find max logit for numeric stability
-            double maxLogit = Double.NEGATIVE_INFINITY;
+        synchronized (children) {
+            children.addAll(MCTSNextActionFactory.createNextAction(player.getNextAction()).performNextAction(this, player, game, fullStateValue));
             for (MCTSNode node : children) {
-                if(node.action == null) continue;
-                int idx = ActionEncoder.addAction(node.getAction());
-                maxLogit = Math.max(maxLogit, policy[idx]);
+                node.depth = depth + 1;
+                node.prior = 1.0;///children.size();
             }
+            if (policy != null && player.getNextAction() != MCTSPlayer.NextAction.CHOOSE_TARGET) {
+                // 2) find max logit for numeric stability
+                double maxLogit = Double.NEGATIVE_INFINITY;
+                for (MCTSNode node : children) {
+                    if (node.action == null) continue;
+                    int idx = ActionEncoder.getAction(node.getAction());
+                    maxLogit = Math.max(maxLogit, policy[idx]);
+                }
 
-            // 3) compute raw exps and sum
-            double sumExp = 0;
-            for (MCTSNode node : children) {
-                if(node.action == null) continue;
-                int idx = ActionEncoder.addAction(node.action);
-                double raw = Math.exp(policy[idx] - maxLogit);
-                node.prior = raw;     // assume you’ve added `public double prior;` to MCTSNode
-                sumExp += raw;
-            }
+                // 3) compute raw exps and sum
+                double sumExp = 0;
+                for (MCTSNode node : children) {
+                    if (node.action == null) continue;
+                    int idx = ActionEncoder.getAction(node.action);
+                    double raw = Math.exp(policy[idx] - maxLogit);
+                    node.prior = raw;     // assume you’ve added `public double prior;` to MCTSNode
+                    sumExp += raw;
+                }
 
-            // 4) normalize in place
-            for (MCTSNode node : children) {
-                node.prior /= sumExp;
+                // 4) normalize in place
+                for (MCTSNode node : children) {
+                    node.prior /= sumExp;
+                }
+                long seed = player.dirichletSeed;
+                if (seed != 0) {
+                    double alpha = 0.03, eps = 0;//no noise for now
+                    int K = children.size();
+                    double[] dir = new double[K];
+                    double sum = 0;
+
+                    // 1) create a Commons-Math RNG and seed it
+                    JDKRandomGenerator rg = new JDKRandomGenerator();
+                    rg.setSeed(seed);
+
+                    // 2) pass it into the GammaDistribution
+                    GammaDistribution gd = new GammaDistribution(rg, alpha, 1.0);
+
+                    // 3) sample & mix exactly as before
+                    for (int i = 0; i < K; i++) {
+                        dir[i] = gd.sample();
+                        sum += dir[i];
+                    }
+                    for (int i = 0; i < K; i++) {
+                        dir[i] /= sum;
+                        children.get(i).prior = (1 - eps) * children.get(i).prior + eps * dir[i];
+                    }
+
+                    // 4) mark done
+                    player.dirichletSeed = 0;
+                }
+            }
+            if (!children.isEmpty()) {
+                game = null;
             }
         }
-
-        if(!children.isEmpty()) game = null;
     }
 
     public int simulate(UUID playerId) {
@@ -230,7 +288,9 @@ public class MCTSNode {
     }
 
     public boolean isLeaf() {
-        return children.isEmpty();
+        synchronized (children) {
+            return children.isEmpty();
+        }
     }
 
     public MCTSNode bestChild() {
@@ -241,8 +301,11 @@ public class MCTSNode {
         boolean bestIsPass = false;
         MCTSNode bestChild = null;
         System.out.print("actions: ");
+
         for (MCTSNode node: children) {
-            if(node.action != null) System.out.printf("[%s score: %.3f count: %d] ", node.action.toString(), node.getWinRatio(), node.visits);
+            if(node.action != null) {
+                System.out.printf("[%s score: %.3f count: %d] ", node.action.toString(), node.getWinRatio(), node.visits);
+            }
             if(node.combat != null && !node.combat.getAttackers().isEmpty()) System.out.printf("[%s score: %.3f count: %d] ", node.combat.toString(), node.getWinRatio(), node.visits);
             //favour passing vs any other action except for playing land if ratio is close
             if (node.visits > bestCount) {
@@ -377,14 +440,15 @@ public class MCTSNode {
      * @param state - the game state that we are looking for
      * @return the matching state or null if no match is found
      */
-    public MCTSNode getMatchingState(String state) {
+    public MCTSNode getMatchingState(String state, List<Set<UUID>> chosen) {
         ArrayDeque<MCTSNode> queue = new ArrayDeque<>();
         queue.add(this);
 
         while (!queue.isEmpty()) {
             MCTSNode current = queue.remove();
-            if (current.stateValue.equals(state))
+            if (current.stateValue.equals(state) && current.chooseTargetAction.equals(chosen))
                 return current;
+            //System.out.printf("MISMATCH: %s\n %s\n",current.stateValue, state);
             for (MCTSNode child: current.children) {
                 queue.add(child);
             }
@@ -394,7 +458,7 @@ public class MCTSNode {
 
     public void merge(MCTSNode merge) {
         // Check that states match; if not, no merge occurs.
-        if (!stateValue.equals(merge.stateValue)) {
+        if (!stateValue.equals(merge.stateValue) || !merge.chooseTargetAction.equals(chooseTargetAction)) {
             logger.info("mismatched merge states at root");
             return;
         }
@@ -423,7 +487,7 @@ public class MCTSNode {
                 for (MCTSNode child : tempChildren) {
                     if (mergeChild.action != null && child.action != null) {
                         if (mergeChild.action.toString().equals(child.action.toString())) {
-                            if (!mergeChild.stateValue.equals(child.stateValue)) {
+                            if (!mergeChild.stateValue.equals(child.stateValue) || !mergeChild.chooseTargetAction.equals(child.chooseTargetAction)) {
                                 // Record mismatch if needed; skip merge.
                             } else {
                                 // Recursively merge the matching child.
@@ -434,8 +498,9 @@ public class MCTSNode {
                         }
                     } else if (mergeChild.combat != null && child.combat != null &&
                             mergeChild.combat.getValue().equals(child.combat.getValue())) {
-                        if (!mergeChild.stateValue.equals(child.stateValue)) {
+                        if (!mergeChild.stateValue.equals(child.stateValue) || !mergeChild.chooseTargetAction.equals(child.chooseTargetAction)) {
                             // Record mismatch if needed.
+
                         } else {
                             child.merge(mergeChild);
                             merged = true;
@@ -574,32 +639,10 @@ public class MCTSNode {
         if(children.isEmpty()) return 0;
         return visits/children.size();
     }
-    public int maxVisits() {
-        int max = -1;
-        for(MCTSNode n : children) {
-            if(n.visits > max) {
-                max = n.visits;
-            }
-        }
-        return max;
-    }
-    public int diffVisits() {
-        int max = -1;
-        int max2 = -1;//second highest
-        for(MCTSNode n : children) {
-            if(n.visits > max) {
-                max2 = max;
-                max = n.visits;
-            } else if(n.visits > max2) {
-                max2 = n.visits;
-            }
-        }
-        return max-max2;
-    }
     public Game getGame() {
+        //game.getState().restore(gameState);
         return game;
     }
-
     public static void logHitMiss() {
         if (USE_ACTION_CACHE) {
             StringBuilder sb = new StringBuilder();
diff --git a/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/MCTSNodeNextAction.java b/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/MCTSNodeNextAction.java
index befa16c515..494912df8a 100644
--- a/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/MCTSNodeNextAction.java
+++ b/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/MCTSNodeNextAction.java
@@ -6,4 +6,5 @@ import java.util.List;
 
 public interface MCTSNodeNextAction {
     List<MCTSNode> performNextAction(MCTSNode node, MCTSPlayer player, Game game, String fullStateValue);
+    void applyAction(MCTSNode node, MCTSPlayer player, Game game);
 }
diff --git a/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/MCTSPlayer.java b/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/MCTSPlayer.java
index af18024b71..013cf14e11 100644
--- a/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/MCTSPlayer.java
+++ b/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/MCTSPlayer.java
@@ -6,17 +6,28 @@ import mage.Mana;
 import mage.abilities.Ability;
 import mage.abilities.ActivatedAbility;
 import mage.abilities.SpellAbility;
+import mage.abilities.TriggeredAbility;
 import mage.abilities.common.PassAbility;
 import mage.abilities.costs.Costs;
 import mage.abilities.costs.mana.GenericManaCost;
+import mage.abilities.costs.mana.ManaCost;
+import mage.abilities.costs.mana.ManaCostsImpl;
+import mage.abilities.costs.mana.VariableManaCost;
+import mage.abilities.effects.Effect;
 import mage.abilities.mana.ManaOptions;
+import mage.cards.Cards;
+import mage.constants.Outcome;
 import mage.constants.Zone;
 import mage.game.Game;
 import mage.game.permanent.Permanent;
 import mage.players.Player;
+import mage.target.Target;
+import mage.target.TargetCard;
 import org.apache.log4j.Logger;
 
+import java.io.Serializable;
 import java.util.*;
+import java.util.concurrent.ConcurrentLinkedQueue;
 
 /**
  * AI: server side bot with monte carlo logic (experimental, the latest version)
@@ -28,13 +39,21 @@ import java.util.*;
  */
 public class MCTSPlayer extends ComputerPlayer {
 
-    private static final Logger logger = Logger.getLogger(MCTSPlayer.class);
-
+    public boolean lastToAct =  false;
     private NextAction nextAction;
-    public boolean isRoot = false;
+    public long dirichletSeed = 0;
+    //public Set<Set<UUID>> chooseTargetOptions = new HashSet<>();
+    //public List<Set<UUID>> chooseTargetAction = new ArrayList<>();
+    //public Set<Set<UUID>> chooseTriggeredOptions = new HashSet<>();
+    //public List<Set<UUID>> chooseTriggeredAction = new ArrayList<>();
+
+    private int chooseTargetCount = 0;
+    public static boolean PRINT_CHOOSE_DIALOGUES = false;
+
+
 
     public enum NextAction {
-        PRIORITY, SELECT_ATTACKERS, SELECT_BLOCKERS
+                PRIORITY, SELECT_ATTACKERS, SELECT_BLOCKERS, CHOOSE_TARGET, CHOOSE_TRIGGERED_ABILITY
     }
 
     public MCTSPlayer(UUID id) {
@@ -51,38 +70,30 @@ public class MCTSPlayer extends ComputerPlayer {
         return new MCTSPlayer(this);
     }
 
+    public void copyDialogues(MCTSPlayer player) {
+        this.chooseTargetAction = new ArrayList<>(player.chooseTargetAction);
+    }
+
     protected List<ActivatedAbility> getPlayableAbilities(Game game) {
         List<ActivatedAbility> playables = getPlayable(game, true);
         ManaOptions availableMana = getManaAvailable(game);
+        List<ActivatedAbility> out = new ArrayList<>();
         //if only land tapping abilities - just return pass JUST FOR TESTING THIS CANT BE USED FOR TRAINING SINCE SOME DECKS CARE ABOUT THIS TODO:remove
         boolean onlyMana = true;
         for(ActivatedAbility aa : playables) {
-            if(!aa.isManaAbility()) onlyMana = false;
-        }
-        if(onlyMana) playables.clear();
-        List<ActivatedAbility> out = new ArrayList<>();
-        for(ActivatedAbility aa : playables) {
-
-            out.add(aa);
-
-            Set<Mana> possiblePayments = new HashSet<>();
-            for(Mana m : availableMana) {
-                Set<Mana> paySet = ManaOptions.getPossiblePayCombinations(aa.getManaCosts().getMana(), m);
-                possiblePayments.addAll(paySet);
-            }
-            if(false) {
-                System.out.printf("payment options for ability %s\n", aa.toString());
-                for(Mana m : possiblePayments) {
-                    System.out.printf("%s, ", m.toString());
-                }
+            if(!aa.isManaAbility()) {
+                onlyMana = false;
+                out.add(aa);
             }
         }
-
+        if(onlyMana) playables.clear();
+        playables.add(new PassAbility());
         out.add(new PassAbility());
         return out;
     }
 
     public List<Ability> getPlayableOptions(Game game) {
+        //if(true) return simulatePriority(game);
         List<Ability> all = new ArrayList<>();
         List<ActivatedAbility> playables = getPlayableAbilities(game);
         for (ActivatedAbility ability : playables) {
@@ -210,6 +221,7 @@ public class MCTSPlayer extends ComputerPlayer {
     @Override
     public boolean priority(Game game) {
         game.pause();
+        lastToAct = true;
         nextAction = NextAction.PRIORITY;
         return false;
     }
@@ -217,12 +229,61 @@ public class MCTSPlayer extends ComputerPlayer {
     @Override
     public void selectAttackers(Game game, UUID attackingPlayerId) {
         game.pause();
+        lastToAct = true;
         nextAction = NextAction.SELECT_ATTACKERS;
     }
 
     @Override
     public void selectBlockers(Ability source, Game game, UUID defendingPlayerId) {
         game.pause();
+        lastToAct = true;
         nextAction = NextAction.SELECT_BLOCKERS;
     }
+    public static void getAllPossible(Set<Set<UUID>> out, Set<UUID> possible, Target target, Ability source, Game game, UUID myID) {
+        if (target.isChosen(game)) out.add(new HashSet<>(target.getTargets()));
+        for(UUID id : possible) {
+            if (!target.canTarget(myID, id, source, game)) continue;
+            target.add(id, game);
+            if(out.contains(new HashSet<>(target.getTargets()))) {
+                target.remove(id);
+                continue;
+            }
+            Set<UUID> copy = new HashSet<>(possible);
+            copy.remove(id);
+            getAllPossible(out, copy, target, source, game, myID);
+            target.remove(id);
+        }
+    }
+    @Override
+    public boolean chooseTarget(Outcome outcome, Target target, Ability source, Game game) {
+        //System.out.println("chooseTarget: " + source.toString());
+        if(PRINT_CHOOSE_DIALOGUES) System.out.println("CALLING CHOOSE TARGET: " + (source == null ? "null" : source.toString()));
+        if(chooseTargetCount < chooseTargetAction.size()) {
+            for(UUID id : chooseTargetAction.get(chooseTargetCount)) {
+                if(!target.canTarget(getId(), id, source, game)) continue;
+                target.addTarget(id, source, game);
+                if(PRINT_CHOOSE_DIALOGUES) System.out.printf("tried target: %s ", game.getObject(id).toString());
+            }
+            if(PRINT_CHOOSE_DIALOGUES) System.out.println();
+            chooseTargetCount++;
+            return true;
+        }
+        Set<UUID> possible = target.possibleTargets(getId(), game);
+        getAllPossible(chooseTargetOptions, possible, target.copy(), source, game, getId());
+        game.pause();
+        lastToAct = true;
+        nextAction = NextAction.CHOOSE_TARGET;
+        return super.chooseTarget(outcome, target, source, game);
+    }
+    @Override
+    public boolean choose(Outcome outcome, Target target, Ability source, Game game, Map<String, Serializable> options) {
+        //reroute to chooseTarget
+        if(true) {
+            //reroute to mcts simulator
+            return chooseTarget(outcome, target, source, game);
+        } else {
+            //reroute to default
+            return super.choose(outcome, target, source, game, options);
+        }
+    }
 }
diff --git a/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/PriorityNextAction.java b/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/PriorityNextAction.java
index 353522c0a0..f176ea9d08 100644
--- a/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/PriorityNextAction.java
+++ b/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/PriorityNextAction.java
@@ -3,6 +3,7 @@ package mage.player.ai;
 import mage.abilities.Ability;
 import mage.abilities.ActivatedAbility;
 import mage.game.Game;
+import mage.game.GameState;
 
 import java.util.ArrayList;
 import java.util.List;
@@ -20,12 +21,21 @@ public class PriorityNextAction implements MCTSNodeNextAction{
         for (Ability ability: abilities) {
             Game sim = game.createSimulationForAI();
             MCTSPlayer simPlayer = (MCTSPlayer) sim.getPlayer(player.getId());
-            boolean success = simPlayer.activateAbility((ActivatedAbility)ability, sim);
-            if(!success) continue;//failsafe
+            boolean success = simPlayer.activateAbility((ActivatedAbility)ability.copy(), sim);
+            if(!success) {
+                if(MCTSPlayer.PRINT_CHOOSE_DIALOGUES) System.out.println("PRIORITY FAILSAFE TRIGGERED: " + ability.toString());
+                continue;//failsafe
+            }
             sim.resume();
-            children.add(new MCTSNode(node, sim, ability));
+            ComputerPlayerMCTS.shuffleUnknowns(sim, node.targetPlayer);
+            children.add(new MCTSNode(node, sim, ability.copy()));
         }
 
         return children;
     }
+
+    @Override
+    public void applyAction(MCTSNode node, MCTSPlayer player, Game game) {
+        player.activateAbility((ActivatedAbility) node.getAction(), game);
+    }
 }
diff --git a/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/SelectAttackersNextAction.java b/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/SelectAttackersNextAction.java
index 3a3919c948..bb1aba9393 100644
--- a/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/SelectAttackersNextAction.java
+++ b/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/SelectAttackersNextAction.java
@@ -4,6 +4,7 @@ import mage.game.Game;
 
 import java.util.ArrayList;
 import java.util.List;
+import java.util.Set;
 import java.util.UUID;
 
 import static mage.player.ai.MCTSNode.getAttacks;
@@ -30,4 +31,13 @@ public class SelectAttackersNextAction implements MCTSNodeNextAction{
 
         return children;
     }
+
+    @Override
+    public void applyAction(MCTSNode node, MCTSPlayer player, Game game) {
+        UUID defenderId = game.getOpponents(player.getId()).iterator().next();
+        Set<UUID> attack = node.combat.getAttackers();
+        for (UUID attackerId: attack) {
+            player.declareAttacker(attackerId, defenderId, game, false);
+        }
+    }
 }
diff --git a/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/SelectBlockersNextAction.java b/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/SelectBlockersNextAction.java
index def9823a49..a524d92397 100644
--- a/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/SelectBlockersNextAction.java
+++ b/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/SelectBlockersNextAction.java
@@ -23,6 +23,7 @@ public class SelectBlockersNextAction implements MCTSNodeNextAction{
             MCTSPlayer simPlayer = (MCTSPlayer) sim.getPlayer(player.getId());
             List<CombatGroup> groups = sim.getCombat().getGroups();
             for (int i = 0; i < groups.size(); i++) {
+                if(groups.get(i).getAttackers().isEmpty()) continue;//failsafe
                 if (i < block.size()) {
                     for (UUID blockerId : block.get(i)) {
                         simPlayer.declareBlocker(simPlayer.getId(), blockerId, groups.get(i).getAttackers().get(0), sim);
@@ -35,4 +36,18 @@ public class SelectBlockersNextAction implements MCTSNodeNextAction{
 
         return children;
     }
+
+    @Override
+    public void applyAction(MCTSNode node, MCTSPlayer player, Game game) {
+        List<CombatGroup> groups = game.getCombat().getGroups();
+        List<CombatGroup> block = node.combat.getGroups();
+        for (int i = 0; i < groups.size(); i++) {
+            if(groups.get(i).getAttackers().isEmpty()) continue;//failsafe
+            if (i < block.size()) {
+                for (UUID blockerId : block.get(i).getBlockers()) {
+                    player.declareBlocker(player.getId(), blockerId, groups.get(i).getAttackers().get(0), game);
+                }
+            }
+        }
+    }
 }
diff --git a/Mage.Tests/UWTempo.dck b/Mage.Tests/UWTempo.dck
new file mode 100644
index 0000000000..8aa53c714c
--- /dev/null
+++ b/Mage.Tests/UWTempo.dck
@@ -0,0 +1,30 @@
+4 [LCI:63] Malcolm, Alluring Scoundrel
+4 [MKM:273] Island
+4 [DSK:30] Sheltered by Ghosts
+4 [ONE:33] Skrelv, Defector Mite
+4 [DMU:44] Combat Research
+2 [DMU:252] Plaza of Heroes
+4 [MKM:221] No More Lies
+4 [DMU:243] Adarkar Wastes
+4 [ONE:258] Seachrome Coast
+2 [MKM:264] Meticulous Archive
+1 [ONE:254] Mirrex
+2 [DSK:29] Shardmage's Rescue
+3 [DSK:259] Floodfarm Verge
+2 [BRO:26] Soul Partition
+2 [STA:18] Negate
+4 [BLB:54] Kitsa, Otterball Elite
+4 [DFT:39] Bounce Off
+2 [BIG:23] Lost Jitte
+2 [NEO:80] Spell Pierce
+2 [WOE:66] Sleep-Cursed Faerie
+SB: 3 [MOM:13] Elspeth's Smite
+SB: 2 [AKR:33] Rest in Peace
+SB: 2 [MKM:13] Doorkeeper Thrull
+SB: 2 [NEO:80] Spell Pierce
+SB: 2 [LCI:81] Tishana's Tidebinder
+SB: 1 [STA:18] Negate
+SB: 1 [FDN:44] Kaito, Cunning Infiltrator
+SB: 2 [OTJ:4] Aven Interrupter
+LAYOUT MAIN:(1,1)(NONE,false,50)|([LCI:63],[LCI:63],[LCI:63],[LCI:63],[MKM:273],[MKM:273],[MKM:273],[MKM:273],[DSK:30],[DSK:30],[DSK:30],[DSK:30],[ONE:33],[ONE:33],[ONE:33],[ONE:33],[DMU:44],[DMU:44],[DMU:44],[DMU:44],[DMU:252],[DMU:252],[MKM:221],[MKM:221],[MKM:221],[MKM:221],[DMU:243],[DMU:243],[DMU:243],[DMU:243],[ONE:258],[ONE:258],[ONE:258],[ONE:258],[MKM:264],[MKM:264],[ONE:254],[DSK:29],[DSK:29],[DSK:259],[DSK:259],[DSK:259],[BRO:26],[BRO:26],[STA:18],[STA:18],[BLB:54],[BLB:54],[BLB:54],[BLB:54],[DFT:39],[DFT:39],[DFT:39],[DFT:39],[BIG:23],[BIG:23],[NEO:80],[NEO:80],[WOE:66],[WOE:66])
+LAYOUT SIDEBOARD:(1,1)(NONE,false,50)|([MOM:13],[MOM:13],[AKR:33],[MKM:13],[MKM:13],[NEO:80],[NEO:80],[MOM:13],[AKR:33],[LCI:81],[LCI:81],[STA:18],[FDN:44],[OTJ:4],[OTJ:4])
diff --git a/Mage.Tests/actions_mapping.ser b/Mage.Tests/actions_mapping.ser
index a9930abea6..0a511d4b1b 100644
Binary files a/Mage.Tests/actions_mapping.ser and b/Mage.Tests/actions_mapping.ser differ
diff --git a/Mage.Tests/features_mapping.ser b/Mage.Tests/features_mapping.ser
deleted file mode 100644
index 39ca7800b3..0000000000
Binary files a/Mage.Tests/features_mapping.ser and /dev/null differ
diff --git a/Mage.Tests/simplegreen.dck b/Mage.Tests/simplegreen.dck
new file mode 100644
index 0000000000..56c729ba45
--- /dev/null
+++ b/Mage.Tests/simplegreen.dck
@@ -0,0 +1,13 @@
+NAME:simplegreen
+4 [LCI:178] Cenote Scout
+24 [SNC:280] Forest
+4 [ONE:167] Evolving Adaptive
+4 [MKM:160] Flourishing Bloom-Kin
+4 [LCI:208] Pugnacious Hammerskull
+4 [DMU:161] Elfhame Wurm
+4 [LCI:191] Hulking Raptor
+4 [DFT:165] Hazard of the Dunes
+4 [ONE:170] Ichorspit Basilisk
+4 [J21:580] Grizzly Bears
+LAYOUT MAIN:(1,1)(NONE,false,50)|([LCI:178],[LCI:178],[LCI:178],[LCI:178],[SNC:280],[SNC:280],[SNC:280],[SNC:280],[SNC:280],[SNC:280],[SNC:280],[SNC:280],[SNC:280],[SNC:280],[SNC:280],[SNC:280],[SNC:280],[SNC:280],[SNC:280],[SNC:280],[SNC:280],[SNC:280],[SNC:280],[SNC:280],[SNC:280],[SNC:280],[SNC:280],[SNC:280],[ONE:167],[ONE:167],[ONE:167],[ONE:167],[MKM:160],[MKM:160],[MKM:160],[MKM:160],[LCI:208],[LCI:208],[LCI:208],[LCI:208],[DMU:161],[DMU:161],[DMU:161],[DMU:161],[LCI:191],[LCI:191],[LCI:191],[LCI:191],[DFT:165],[DFT:165],[DFT:165],[DFT:165],[ONE:170],[ONE:170],[ONE:170],[ONE:170],[J21:580],[J21:580],[J21:580],[J21:580])
+LAYOUT SIDEBOARD:(0,0)(NONE,false,50)|
diff --git a/Mage.Tests/src/test/java/org/mage/test/AI/RL/GenerateMappings.java b/Mage.Tests/src/test/java/org/mage/test/AI/RL/GenerateMappings.java
index faa2d0cb6f..861bac7b8f 100644
--- a/Mage.Tests/src/test/java/org/mage/test/AI/RL/GenerateMappings.java
+++ b/Mage.Tests/src/test/java/org/mage/test/AI/RL/GenerateMappings.java
@@ -22,30 +22,9 @@ import java.nio.file.Files;
 import java.nio.file.Paths;
 import java.util.*;
 
-public class GenerateMappings extends CardTestPlayerBaseAI {
-    private String deckNameA = "UWTempo.dck"; //simplegreen, UWTempo
-    private String deckNameB = "simplegreen.dck";
-    private StateEncoder encoder;
-    private int seed;
-    //private Set<Integer> ignore;
-    //private Map<String, Integer> actions;
-    // File where the persistent mapping is stored
-    private static final String MAPPING_FILE = "features_mapping.ser";
-    private static final String ACTIONS_FILE = "actions_mapping.ser";
+public class GenerateMappings extends MinimaxVectorExtractionTests {
 
 
-    @Override
-    public List<String> getFullSimulatedPlayers() {
-        return Arrays.asList("PlayerA", "PlayerB");
-    }
-
-    @Override
-    protected Game createNewGameAndPlayers() throws GameException, FileNotFoundException {
-        Game game = new TwoPlayerDuel(MultiplayerAttackOption.LEFT, RangeOfInfluence.ONE, MulliganType.GAME_DEFAULT.getMulligan(0), 60, 20, 7);
-        playerA = createPlayer(game, "PlayerA", "C:\\Users\\WillWroble\\Documents\\" + deckNameA);
-        playerB = createPlayer(game, "PlayerB", "C:\\Users\\WillWroble\\Documents\\" + deckNameB);
-        return game;
-    }
     @Override
     protected TestPlayer createPlayer(String name, RangeOfInfluence rangeOfInfluence) {
         if (getFullSimulatedPlayers().contains(name)) {
@@ -63,6 +42,7 @@ public class GenerateMappings extends CardTestPlayerBaseAI {
         }
         return super.createPlayer(name, rangeOfInfluence);
     }
+    @Override
     public void init_seed() {
         seed = RandomUtil.nextInt();
         //seed = -1421792887;
@@ -70,57 +50,20 @@ public class GenerateMappings extends CardTestPlayerBaseAI {
         System.out.printf("USING SEED: %d\n", seed);
         RandomUtil.setSeed(seed);
     }
-    @Before
-    public void init_encoder() {
-        init_seed();
-        System.out.println("Setting up encoder");
-        encoder = new StateEncoder();
-        //ignore = new HashSet<>();
-        //actions = new HashMap<>();
-        // Try to load the persistent mapping from file
-        File mappingFile = new File(MAPPING_FILE);
-        if (mappingFile.exists()) {
-            try {
-                encoder.loadMapping(MAPPING_FILE);
-                System.out.println("Loaded persistent mapping from " + MAPPING_FILE);
-            } catch (IOException | ClassNotFoundException e) {
-                System.out.println("Failed to load mapping. Starting with a fresh mapping.");
-            }
-        } else {
-            System.out.println("No persistent mapping found. Starting fresh.");
-        }
-        //try to load persistent action mappings from file
-        File actionsFile = new File(ACTIONS_FILE);
-        if (actionsFile.exists()) {
-            try {
-                ActionEncoder.actionMap = (Map<String, Integer>) loadObject(ACTIONS_FILE);
-                ActionEncoder.indexCount = ActionEncoder.actionMap.size();
-                System.out.println("Loaded persistent mapping from " + ACTIONS_FILE);
-            } catch (IOException | ClassNotFoundException e) {
-                System.out.println("Failed to load mapping. Starting with a fresh mapping.");
-            }
-        } else {
-            System.out.println("No persistent mapping found. Starting fresh.");
-        }
-
-        set_encoder();
-    }
+    @Override
     public void set_encoder() {
         ComputerPlayerPureMCTS pmc = (ComputerPlayerPureMCTS)playerA.getComputerPlayer();
         pmc.setEncoder(encoder);
         encoder.setAgent(playerA.getId());
         encoder.setOpponent(playerB.getId());
     }
-    public void reset_game() {
-        try {
-            reset();
-        } catch (FileNotFoundException e) {
-            throw new RuntimeException(e);
-        } catch (GameException e) {
-            throw new RuntimeException(e);
-        }
-        set_encoder();
-
+    @Test
+    public void print_current_ignore_list() {
+        System.out.printf("IGNORE LIST SIZE: %d\n", encoder.ignoreList.size());
+        System.out.printf("REDUCED VECTOR SIZE: %d\n", StateEncoder.indexCount - encoder.ignoreList.size());
+        System.out.print("RAW TO REDUCED MAPPING: ");
+        System.out.println();
+        System.out.println(encoder.ignoreList.toString());
     }
     /**
      * uses saved list of actions and states to make a labeled vector batch for training
@@ -130,15 +73,16 @@ public class GenerateMappings extends CardTestPlayerBaseAI {
     public void make_ignore_X_50() {
         int maxTurn = 50;
         Features.printOldFeatures = false;
-        for(int i = 0; i < 1; i++) {
+        for(int i = 0; i < 50; i++) {
             setStrictChooseMode(true);
             setStopAt(maxTurn, PhaseStep.END_TURN);
             execute();
             reset_game();
             System.out.printf("GAME #%d RESET... NEW GAME STARTING\n", i+1);
         }
-        System.out.println(encoder.macroStateVectors.size());
-        encoder.ignoreList = new HashSet<>(FeatureMerger.computeIgnoreList(encoder.macroStateVectors));
+        Set<Integer> newIgnore = new HashSet<>(FeatureMerger.computeIgnoreList(encoder.macroStateVectors));
+        Set<Integer> oldIgnore = new HashSet<>(encoder.ignoreList);
+        encoder.ignoreList = combine_ignore_lists(oldIgnore, newIgnore);
         //actions = new HashMap<>(ActionEncoder.actionMap);
         persistData();
         System.out.printf("IGNORE LIST SIZE: %d\n", encoder.ignoreList.size());
@@ -158,30 +102,4 @@ public class GenerateMappings extends CardTestPlayerBaseAI {
         }
         System.out.println();
     }
-    public void persistData() {
-        try {
-            encoder.persistMapping(MAPPING_FILE);
-            System.out.printf("Persisted feature mapping to %s\n", MAPPING_FILE);
-            //saveObject(ignore, IGNORE_FILE);
-            //System.out.printf("Persisted ignore list to %s\n", IGNORE_FILE);
-            saveObject(new HashMap<>(ActionEncoder.actionMap), ACTIONS_FILE);
-            System.out.printf("Persisted action mapping to %s\n", ACTIONS_FILE);
-        } catch (IOException e) {
-            e.printStackTrace();
-        }
-    }
-
-    // Method to save a Serializable object to a file
-    public static void saveObject(Object obj, String fileName) throws IOException {
-        try (ObjectOutputStream out = new ObjectOutputStream(Files.newOutputStream(Paths.get(fileName)))) {
-            out.writeObject(obj);
-        }
-    }
-
-    // Method to load a Serializable object from a file
-    public static Object loadObject(String fileName) throws IOException, ClassNotFoundException {
-        try (ObjectInputStream in = new ObjectInputStream(Files.newInputStream(Paths.get(fileName)))) {
-            return in.readObject();
-        }
-    }
 }
diff --git a/Mage.Tests/src/test/java/org/mage/test/AI/RL/MCTS2Tests.java b/Mage.Tests/src/test/java/org/mage/test/AI/RL/MCTS2Tests.java
index 7c941506cc..b9d287b47c 100644
--- a/Mage.Tests/src/test/java/org/mage/test/AI/RL/MCTS2Tests.java
+++ b/Mage.Tests/src/test/java/org/mage/test/AI/RL/MCTS2Tests.java
@@ -38,8 +38,8 @@ public class MCTS2Tests extends CardTestPlayerBaseAI {
     @Override
     protected Game createNewGameAndPlayers() throws GameException, FileNotFoundException {
         Game game = new TwoPlayerDuel(MultiplayerAttackOption.LEFT, RangeOfInfluence.ONE, MulliganType.GAME_DEFAULT.getMulligan(0), 60, 20, 7);
-        playerA = createPlayer(game, "PlayerA", "C:\\Users\\WillWroble\\Documents\\" + deckNameA);
-        playerB = createPlayer(game, "PlayerB", "C:\\Users\\WillWroble\\Documents\\" + deckNameB);
+        playerA = createPlayer(game, "PlayerA", "C:\\Users\\owner\\Documents\\" + deckNameA);
+        playerB = createPlayer(game, "PlayerB", "C:\\Users\\owner\\Documents\\" + deckNameB);
         return game;
     }
     @Override
diff --git a/Mage.Tests/src/test/java/org/mage/test/AI/RL/MCTS2WithNNTests.java b/Mage.Tests/src/test/java/org/mage/test/AI/RL/MCTS2WithNNTests.java
index e65fa19bb8..8c8ae2b94c 100644
--- a/Mage.Tests/src/test/java/org/mage/test/AI/RL/MCTS2WithNNTests.java
+++ b/Mage.Tests/src/test/java/org/mage/test/AI/RL/MCTS2WithNNTests.java
@@ -1,60 +1,30 @@
 package org.mage.test.AI.RL;
 
-import ai.onnxruntime.OrtException;
-import mage.constants.MultiplayerAttackOption;
 import mage.constants.PhaseStep;
 import mage.constants.RangeOfInfluence;
-import mage.game.Game;
-import mage.game.GameException;
-import mage.game.TwoPlayerDuel;
-import mage.game.mulligan.MulliganType;
+import mage.constants.Zone;
 import mage.player.ai.*;
 import mage.util.RandomUtil;
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
-import org.mage.test.player.TestComputerPlayer7;
-import org.mage.test.player.TestComputerPlayer8;
-import org.mage.test.player.TestComputerPlayerMonteCarlo2;
-import org.mage.test.player.TestPlayer;
-import org.mage.test.serverside.base.CardTestPlayerBaseAI;
+import org.mage.test.player.*;
 
 import java.io.*;
-import java.nio.file.Files;
-import java.nio.file.Paths;
 import java.util.*;
 
-public class MCTS2WithNNTests extends CardTestPlayerBaseAI {
-    private String deckNameA = "UWTempo.dck"; //simplegreen, UWTempo
-    private String deckNameB = "simplegreen.dck";
-    private List<LabeledState> labeledStates = new ArrayList<>();
-    private List<LabeledState> labeledStateBatch = new ArrayList<>();
-    private StateEncoder encoder;
-    //private Set<Integer> ignore;
-    //private Map<String, Integer> actions;
-    // File where the persistent mapping is stored
-    private static final String MAPPING_FILE = "features_mapping.ser";
-    private static final String ACTIONS_FILE = "actions_mapping.ser";
-    private static final String TRAIN_OUT_FILE = "training.bin";
-    private static final String TEST_OUT_FILE = "testing.bin";
-    private int seed;
+import static org.apache.commons.lang3.ObjectUtils.min;
 
+public class MCTS2WithNNTests extends MinimaxVectorExtractionTests {
 
+    public static final String REPLAY_BUFFER_FILE = "replay_buffer.ser";
+    public static final String PATH_TO_MODEL = "models/Model1.onnx";
+    public static final int REPLAY_BUFFER_CAPACITY = 10000; // e.g., holds states from ~50 games
+    public ReplayBuffer replayBuffer;
+    public int wins = 0;
+    public int total = 0;
+    private final boolean useReplayBuffer = false;
 
-    @Override
-    public List<String> getFullSimulatedPlayers() {
-        return Arrays.asList("PlayerA", "PlayerB");
-    }
-
-    @Override
-    protected Game createNewGameAndPlayers() throws GameException, FileNotFoundException {
-        ComputerPlayerMCTS2.PATH_TO_NN = "C:\\Users\\WillWroble\\Documents\\GitHub\\MageZero\\exports\\UWTempo\\UWTempo2.onnx";
-
-        Game game = new TwoPlayerDuel(MultiplayerAttackOption.LEFT, RangeOfInfluence.ONE, MulliganType.GAME_DEFAULT.getMulligan(0), 60, 20, 7);
-        playerA = createPlayer(game, "PlayerA", "C:\\Users\\WillWroble\\Documents\\" + deckNameA);
-        playerB = createPlayer(game, "PlayerB", "C:\\Users\\WillWroble\\Documents\\" + deckNameB);
-        return game;
-    }
     @Override
     protected TestPlayer createPlayer(String name, RangeOfInfluence rangeOfInfluence) {
         if (getFullSimulatedPlayers().contains(name)) {
@@ -64,21 +34,14 @@ public class MCTS2WithNNTests extends CardTestPlayerBaseAI {
                 testPlayer.setAIPlayer(true); // enable full AI support (game simulations) for all turns by default
                 return testPlayer;
             } else {
-                TestComputerPlayer7 t7 = new TestComputerPlayer7(name, RangeOfInfluence.ONE, getSkillLevel());
-                TestPlayer testPlayer = new TestPlayer(t7);
+                TestComputerPlayer8 t8 = new TestComputerPlayer8(name, RangeOfInfluence.ONE, getSkillLevel());
+                TestPlayer testPlayer = new TestPlayer(t8);
                 testPlayer.setAIPlayer(true); // enable full AI support (game simulations) for all turns by default
                 return testPlayer;
             }
         }
         return super.createPlayer(name, rangeOfInfluence);
     }
-    public void init_seed() {
-        seed = RandomUtil.nextInt();
-        //seed = -1421792887;
-        seed = 233400479;
-        System.out.printf("USING SEED: %d\n", seed);
-        RandomUtil.setSeed(seed);
-    }
     @Before
     public void init_encoder() {
         init_seed();
@@ -103,7 +66,6 @@ public class MCTS2WithNNTests extends CardTestPlayerBaseAI {
         if (actionsFile.exists()) {
             try {
                 ActionEncoder.actionMap = (Map<String, Integer>) loadObject(ACTIONS_FILE);
-                ActionEncoder.makeInverseMap();
                 ActionEncoder.indexCount = ActionEncoder.actionMap.size();
                 System.out.println("Loaded persistent mapping from " + ACTIONS_FILE);
             } catch (IOException | ClassNotFoundException e) {
@@ -112,100 +74,143 @@ public class MCTS2WithNNTests extends CardTestPlayerBaseAI {
         } else {
             System.out.println("No persistent mapping found. Starting fresh.");
         }
-
+        //also set up buffer
+        if(useReplayBuffer) {
+            File bufferFile = new File(REPLAY_BUFFER_FILE);
+            if (bufferFile.exists()) {
+                try {
+                    replayBuffer = (ReplayBuffer) loadObject(REPLAY_BUFFER_FILE);
+                    System.out.printf("Loaded Replay Buffer with %d states from %s%n", replayBuffer.size(), REPLAY_BUFFER_FILE);
+                } catch (IOException | ClassNotFoundException e) {
+                    System.out.println("Failed to load Replay Buffer. Starting with a fresh one.");
+                    replayBuffer = new ReplayBuffer(REPLAY_BUFFER_CAPACITY);
+                }
+            } else {
+                System.out.println("No Replay Buffer found. Starting fresh.");
+                replayBuffer = new ReplayBuffer(REPLAY_BUFFER_CAPACITY);
+            }
+        }
         set_encoder();
         labeledStates = new ArrayList<>();
     }
+    @Override
+    public void init_seed() {
+        seed = RandomUtil.nextInt();
+        //seed = -1421792887;
+        //seed = 233400479;
+        //seed = 1603827803;
+        //seed = -99205609;
+
+        //seed = 144516733;
+        //seed = 197732112;
+        //seed = -781685651;
+        //seed = 2036403658;
+        //seed = -1702733670;
+        //seed = 1617973009;
+        //seed = 1735298645;
+        //seed = -1943293127;
+        //-seed = -1018550371;
+        //seed = 67231982;
+        //seed = 1205983369;
+        System.out.printf("USING SEED: %d\n", seed);
+        RandomUtil.setSeed(seed);
+    }
+    @Override
     public void set_encoder() {
         ComputerPlayerMCTS2 mcts2 = (ComputerPlayerMCTS2) playerA.getComputerPlayer();
+        mcts2.clearTree();
+        MCTSNode.clearCaches();
+        ComputerPlayer8 c8 = (ComputerPlayer8)playerB.getComputerPlayer();
+        c8.setEncoder(encoder);
         mcts2.setEncoder(encoder);
+        mcts2.setBuffer(replayBuffer);
+        mcts2.initNN(PATH_TO_MODEL);
         encoder.setAgent(playerA.getId());
         encoder.setOpponent(playerB.getId());
     }
-    public void reset_game() {
-        try {
-            ((ComputerPlayerMCTS2)playerA.getComputerPlayer()).nn.close();
-        } catch (OrtException oe) {
-            oe.printStackTrace();
-        }
-        try {
-            reset();
-        } catch (FileNotFoundException e) {
-            throw new RuntimeException(e);
-        } catch (GameException e) {
-            throw new RuntimeException(e);
-        }
-        set_encoder();
-
-    }
-    public void reset_vectors() {
-        encoder.macroStateVectors.clear();
-        encoder.stateScores.clear();
-        ActionEncoder.actionVectors.clear();
-    }
-
-    /**
-     * uses saved list of actions and states to make a labeled vector batch for training
-     */
+    @Override
     public void create_labeled_states() {
+        total++;
+        if(playerA.hasWon()) wins++;
         int N = encoder.macroStateVectors.size();
         double γ = 0.99;          // discount factor
         double λ = 0.5;           // how much weight to give the minimax estimate vs. terminal
 
         labeledStateBatch.clear();
         for(int i = 0; i < N; i++) {
-            // 1) decompress your raw state and action bits (you already have this)
-            boolean[] state = encoder.getCompressedVector(encoder.macroStateVectors.get(i));
-            boolean[] action = ActionEncoder.actionVectors.get(i);
-
-            // 2) get your raw minimax score and normalize into [-1,+1]
-            double rawScore = encoder.stateScores.get(i);
-            //double normScore = rawScore / (double)Math.abs(GameStateEvaluator2.LOSE_GAME_SCORE);
-
-            double scale = 20000.0;              // or better yet: maxAbs(stateScores)
-            double normScore = Math.tanh(rawScore/scale);
+            Set<Integer> state = encoder.macroStateVectors.get(i);
+            double[] action = ActionEncoder.actionVectors.get(i);
+            double normScore = encoder.stateScores.get(i);
 
-
-            // 3) build your discounted terminal label in [-1,+1]
             boolean win = playerA.hasWon();
             double terminal = win ? +1.0 : -1.0;
             double discount = Math.pow(γ, N - i - 1);
 
-            // 4) blend them
             double blended = λ * normScore + (1.0 - λ) * terminal * discount;
 
-            // 5) store a single LabeledState with that double label
             labeledStateBatch.add(new LabeledState(state, action, blended));
         }
-
-        // shuffle before writing out / persisting
-        //Collections.shuffle(labeledStateBatch);
-
         reset_vectors();
     }
-    public void print_labeled_states() {
-        for (LabeledState ls : labeledStates) {
-            StringBuilder sb1 = new StringBuilder();
-            for (int i = 0; i < 100; i++) {
-                sb1.append(ls.stateVector[i] ? "1" : "0");
-                //sb1.append(", ");
-            }
-            StringBuilder sb2 = new StringBuilder();
-            for (int i = 0; i < 100; i++) {
-                sb2.append(ls.actionVector[i] ? "1" : "0");
-                //sb2.append(", ");
-            }
-            System.out.printf("State: %s, Action: %s, Result: %s\n", sb1.toString(), sb2.toString(), ls.resultLabel);
+    public void loadGame() {
+        if (replayBuffer.size() == 0) {
+            System.out.println("Replay buffer is empty, skipping state load.");
+            reset_game();
+            return;
         }
+        currentGame = replayBuffer.sample(1).get(0).copy();
+        TestPlayer newPlayerA = (TestPlayer) currentGame.getPlayer(playerA.getId());
+        TestPlayer newPlayerB = (TestPlayer) currentGame.getPlayer(playerB.getId());
+        newPlayerA.setMatchPlayer(playerA.getMatchPlayer());
+        newPlayerB.setMatchPlayer(playerB.getMatchPlayer());
+
+        //ComputerPlayerMCTS2 mcts2 = (ComputerPlayerMCTS2) newPlayerA.getComputerPlayer();
+        //mcts2.root = null;
+        //ComputerPlayerMCTS.macroState = ComputerPlayerMCTS.createCompleteMCTSGame(currentGame);
+
+        playerA.restore(newPlayerA);
+        playerB.restore(newPlayerB);
+        currentGame.getState().getPlayers().put(playerA.getId(), playerA);
+        currentGame.getState().getPlayers().put(playerB.getId(), playerB);
+        currentGame.setGameOptions(gameOptions);
+        set_encoder();
     }
     @Test
     public void test_1_game() {
         int maxTurn = 50;
         Features.printOldFeatures = false;
+        addCard(Zone.HAND, playerA, "Sheltered by ghosts");
+        //ComputerPlayer.PRINT_DECISION_FALLBACKS = true;
+        ComputerPlayerMCTS2.SHOW_THREAD_INFO = true;
+        setStrictChooseMode(false);
+        setStopAt(maxTurn, PhaseStep.END_TURN);
+        execute();
+    }
+    @Test
+    public void test_save_1_game_to_buffer() {
+        int maxTurn = 50;
+        Features.printOldFeatures = false;
+        ComputerPlayerMCTS2.SHOW_THREAD_INFO = true;
         setStrictChooseMode(true);
         setStopAt(maxTurn, PhaseStep.END_TURN);
         execute();
-
+        save_buffer();
+    }
+    @Test
+    public void test_1_game_from_buffer() {
+        loadGame();
+        int maxTurn = 50;
+        Features.printOldFeatures = false;
+        ComputerPlayerMCTS2.SHOW_THREAD_INFO = true;
+        setStrictChooseMode(true);
+        setStopAt(maxTurn, PhaseStep.END_TURN);
+        currentGame.resume();
+    }
+    @Test
+    public void print_data() {
+        System.out.printf("IGNORE LIST SIZE: %d\n", encoder.ignoreList.size());
+        System.out.printf("REDUCED VECTOR SIZE: %d\n", StateEncoder.indexCount - encoder.ignoreList.size());
+        System.out.printf("REPLAY BUFFER SIZE: %d\n", replayBuffer.size());
     }
     /**
      * make a training set of 50 games
@@ -214,8 +219,11 @@ public class MCTS2WithNNTests extends CardTestPlayerBaseAI {
     public void make_train_ds_X_50() {
         int maxTurn = 50;
         Features.printOldFeatures = false;
-        for(int i = 0; i < 50; i++) {
-            setStrictChooseMode(true);
+        ComputerPlayerMCTS2.SHOW_THREAD_INFO = true;
+        //MCTSPlayer.PRINT_CHOOSE_DIALOGUES = true;
+        //ComputerPlayer.PRINT_DECISION_FALLBACKS = true;
+        for(int i = 0; i < 250; i++) {
+            setStrictChooseMode(false);
             setStopAt(maxTurn, PhaseStep.END_TURN);
             execute();
             create_labeled_states();
@@ -224,87 +232,129 @@ public class MCTS2WithNNTests extends CardTestPlayerBaseAI {
             reset_game();
             System.out.printf("GAME #%d RESET... NEW GAME STARTING\n", i+1);
         }
-        //Collections.shuffle(labeledStates);
+        Set<Integer> newIgnore = new HashSet<>(FeatureMerger.computeIgnoreListFromLS(labeledStates));
+        Set<Integer> oldIgnore = new HashSet<>(encoder.ignoreList);
+        encoder.ignoreList = combine_ignore_lists(oldIgnore, newIgnore);
+        compress_labeled_states();
+
         print_labeled_states();
         persistLabeledStates(TRAIN_OUT_FILE);
         persistData();
+        //save_buffer();
+        System.out.printf("IGNORE LIST SIZE: %d\n", encoder.ignoreList.size());
+        System.out.printf("REDUCED VECTOR SIZE: %d\n", StateEncoder.indexCount - encoder.ignoreList.size());
+        System.out.printf("WINRATE: %f\n", wins*1.0/total);
     }
+    @Test
+    public void make_train_ds_50_from_buffer() {
+        int maxTurn = 50;
+        Features.printOldFeatures = false;
+        ComputerPlayerMCTS2.SHOW_THREAD_INFO = true;
+        for(int i = 0; i < 50; i++) {
+            loadGame();
+            setStrictChooseMode(false);
+            setStopAt(maxTurn, PhaseStep.END_TURN);
+            currentGame.resume();
+            create_labeled_states();
+            labeledStates.addAll(labeledStateBatch);
+            labeledStateBatch.clear();
+            reset_game();
+            System.out.printf("GAME #%d RESET... NEW GAME STARTING\n", i+1);
+        }
+        Set<Integer> newIgnore = new HashSet<>(FeatureMerger.computeIgnoreListFromLS(labeledStates));
+        Set<Integer> oldIgnore = new HashSet<>(encoder.ignoreList);
+        encoder.ignoreList = combine_ignore_lists(oldIgnore, newIgnore);
+        compress_labeled_states();
 
+        print_labeled_states();
+        persistLabeledStates(TRAIN_OUT_FILE);
+        persistData();
+        save_buffer();
+        System.out.printf("IGNORE LIST SIZE: %d\n", encoder.ignoreList.size());
+        System.out.printf("REDUCED VECTOR SIZE: %d\n", StateEncoder.indexCount - encoder.ignoreList.size());
+        System.out.printf("WINRATE: %f\n", wins*1.0/total);
+    }
     /**
-     * make a testing/validation set of 5 random states from each of 50 games
+     * make a testing/validation set of 20 random states from each of 20 games
      */
     @Test
-    public void make_test_ds_X_50() {
+    public void make_test_ds_X_20() {
         int maxTurn = 50;
         Features.printOldFeatures = false;
-        for(int i = 0; i < 50; i++) {
-            setStrictChooseMode(true);
+        ComputerPlayerMCTS2.SHOW_THREAD_INFO = true;
+        //ComputerPlayer.PRINT_DECISION_FALLBACKS = true;
+        for(int i = 0; i < 20; i++) {
+            setStrictChooseMode(false);
             setStopAt(maxTurn, PhaseStep.END_TURN);
             execute();
             create_labeled_states();
-            labeledStates.addAll(labeledStateBatch.subList(0, 5));
+            Collections.shuffle(labeledStateBatch);
+            labeledStates.addAll(labeledStateBatch.subList(0, min(20, labeledStateBatch.size())));
             labeledStateBatch.clear();
             reset_game();
             System.out.printf("GAME #%d RESET... NEW GAME STARTING\n", i+1);
         }
+        Set<Integer> newIgnore = new HashSet<>(FeatureMerger.computeIgnoreListFromLS(labeledStates));
+        Set<Integer> oldIgnore = new HashSet<>(encoder.ignoreList);
+        encoder.ignoreList = combine_ignore_lists(oldIgnore, newIgnore);
+        compress_labeled_states();
+
         print_labeled_states();
         persistLabeledStates(TEST_OUT_FILE);
         persistData();
+        System.out.printf("IGNORE LIST SIZE: %d\n", encoder.ignoreList.size());
+        System.out.printf("REDUCED VECTOR SIZE: %d\n", StateEncoder.indexCount - encoder.ignoreList.size());
+        System.out.printf("WINRATE: %f\n", wins*1.0/total);
     }
-    @After
-    public void print_vector_size() {
-        System.out.printf("FINAL (unreduced) VECTOR SIZE: %d\n", StateEncoder.indexCount);
-        System.out.printf("FINAL ACTION VECTOR SIZE: %d\n", ActionEncoder.indexCount);
-        for(String s : ActionEncoder.actionMap.keySet()) {
-            System.out.printf("[%s => %d] ", s, ActionEncoder.actionMap.get(s));
-        }
-        System.out.println();
-    }
-    private void persistLabeledStates(String filename) {
-        try (DataOutputStream out = new DataOutputStream(
-                new BufferedOutputStream(new FileOutputStream(filename)))) {
-            int n = labeledStates.size();
-            int S = labeledStates.get(0).stateVector.length;
-            int A = labeledStates.get(0).actionVector.length;
-            // Write header: #records, state-dim, action-dim
-            out.writeInt(n);
-            out.writeInt(S);
-            out.writeInt(A);
-            // Write raw data: one byte per boolean
-            for (LabeledState ls : labeledStates) {
-                for (boolean b : ls.stateVector) out.writeByte(b ? 1 : 0);
-                for (boolean b : ls.actionVector) out.writeByte(b ? 1 : 0);
-                out.writeDouble(ls.resultLabel);
-            }
-        } catch (IOException e) {
-            e.printStackTrace();
+    /**
+     * make a testing/validation set of 5 random states from each of 50 games (using replay buffer)
+     */
+    @Test
+    public void make_test_ds_from_buffer_X_50() {
+        int maxTurn = 50;
+        Features.printOldFeatures = false;
+        ComputerPlayerMCTS2.SHOW_THREAD_INFO = true;
+        //ComputerPlayer.PRINT_DECISION_FALLBACKS = true;
+        for(int i = 0; i < 50; i++) {
+            loadGame();
+            setStrictChooseMode(false);
+            setStopAt(maxTurn, PhaseStep.END_TURN);
+            currentGame.resume();
+            create_labeled_states();
+            Collections.shuffle(labeledStateBatch);
+            labeledStates.addAll(labeledStateBatch.subList(0, min(5, labeledStateBatch.size())));
+            labeledStateBatch.clear();
+            reset_game();
+            System.out.printf("GAME #%d RESET... NEW GAME STARTING\n", i+1);
         }
-    }
+        Set<Integer> newIgnore = new HashSet<>(FeatureMerger.computeIgnoreListFromLS(labeledStates));
+        Set<Integer> oldIgnore = new HashSet<>(encoder.ignoreList);
+        encoder.ignoreList = combine_ignore_lists(oldIgnore, newIgnore);
+        compress_labeled_states();
 
-    public void persistData() {
+        print_labeled_states();
+        persistLabeledStates(TEST_OUT_FILE);
+        persistData();
+        System.out.printf("IGNORE LIST SIZE: %d\n", encoder.ignoreList.size());
+        System.out.printf("REDUCED VECTOR SIZE: %d\n", StateEncoder.indexCount - encoder.ignoreList.size());
+        System.out.printf("WINRATE: %f\n", wins*1.0/total);
+    }
+    public void save_buffer() {
         try {
-            encoder.persistMapping(MAPPING_FILE);
-            System.out.printf("Persisted feature mapping to %s\n", MAPPING_FILE);
-            //saveObject(ignore, IGNORE_FILE);
-            //System.out.printf("Persisted ignore list to %s\n", IGNORE_FILE);
-            saveObject(new HashMap<>(ActionEncoder.actionMap), ACTIONS_FILE);
-            System.out.printf("Persisted action mapping to %s\n", ACTIONS_FILE);
+            saveObject(replayBuffer, REPLAY_BUFFER_FILE);
+            System.out.printf("Persisted replay buffer to %s%n", REPLAY_BUFFER_FILE);
         } catch (IOException e) {
             e.printStackTrace();
         }
     }
-
-    // Method to save a Serializable object to a file
-    public static void saveObject(Object obj, String fileName) throws IOException {
-        try (ObjectOutputStream out = new ObjectOutputStream(Files.newOutputStream(Paths.get(fileName)))) {
-            out.writeObject(obj);
-        }
-    }
-
-    // Method to load a Serializable object from a file
-    public static Object loadObject(String fileName) throws IOException, ClassNotFoundException {
-        try (ObjectInputStream in = new ObjectInputStream(Files.newInputStream(Paths.get(fileName)))) {
-            return in.readObject();
+    @After
+    public void print_vector_size() {
+        System.out.printf("FINAL (unreduced) VECTOR SIZE: %d\n", StateEncoder.indexCount);
+        System.out.printf("FINAL ACTION VECTOR SIZE: %d\n", ActionEncoder.indexCount);
+        if(replayBuffer != null) System.out.printf("REPLAY BUFFER SIZE: %d\n", replayBuffer.size());
+        for(String s : ActionEncoder.actionMap.keySet()) {
+            System.out.printf("[%s => %d] ", s, ActionEncoder.actionMap.get(s));
         }
+        System.out.println();
     }
 }
diff --git a/Mage.Tests/src/test/java/org/mage/test/AI/RL/MCTSEncoderTests.java b/Mage.Tests/src/test/java/org/mage/test/AI/RL/MCTSEncoderTests.java
index e41b4b39a4..f6b4018cda 100644
--- a/Mage.Tests/src/test/java/org/mage/test/AI/RL/MCTSEncoderTests.java
+++ b/Mage.Tests/src/test/java/org/mage/test/AI/RL/MCTSEncoderTests.java
@@ -39,8 +39,8 @@ public class MCTSEncoderTests extends CardTestPlayerBaseAI {
                 RangeOfInfluence.ONE,
                 MulliganType.GAME_DEFAULT.getMulligan(0),
                 60, 20, 7);
-        playerA = createPlayer(game, "PlayerA", "C:\\Users\\WillWroble\\Documents\\" + deckNameA);
-        playerB = createPlayer(game, "PlayerB", "C:\\Users\\WillWroble\\Documents\\" + deckNameB);
+        playerA = createPlayer(game, "PlayerA", "C:\\Users\\owner\\Documents\\" + deckNameA);
+        playerB = createPlayer(game, "PlayerB", "C:\\Users\\owner\\Documents\\" + deckNameB);
         return game;
     }
 
diff --git a/Mage.Tests/src/test/java/org/mage/test/AI/RL/MinimaxVectorExtractionTests.java b/Mage.Tests/src/test/java/org/mage/test/AI/RL/MinimaxVectorExtractionTests.java
index 4699cdb4d7..465f878a76 100644
--- a/Mage.Tests/src/test/java/org/mage/test/AI/RL/MinimaxVectorExtractionTests.java
+++ b/Mage.Tests/src/test/java/org/mage/test/AI/RL/MinimaxVectorExtractionTests.java
@@ -8,6 +8,7 @@ import mage.game.GameException;
 import mage.game.TwoPlayerDuel;
 import mage.game.mulligan.MulliganType;
 import mage.player.ai.*;
+import mage.util.RandomUtil;
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
@@ -21,19 +22,23 @@ import java.nio.file.Files;
 import java.nio.file.Paths;
 import java.util.*;
 
+import static java.lang.Integer.min;
+
 public class MinimaxVectorExtractionTests extends CardTestPlayerBaseAI {
     private String deckNameA = "UWTempo.dck"; //simplegreen, UWTempo
     private String deckNameB = "simplegreen.dck";
-    private List<LabeledState> labeledStates = new ArrayList<>();
-    private List<LabeledState> labeledStateBatch = new ArrayList<>();
-    private StateEncoder encoder;
+    public List<LabeledState> labeledStates = new ArrayList<>();
+    public List<LabeledState> labeledStateBatch = new ArrayList<>();
+    public StateEncoder encoder;
+    public int seed;
+
     //private Set<Integer> ignore;
     //private Map<String, Integer> actions;
     // File where the persistent mapping is stored
-    private static final String MAPPING_FILE = "features_mapping.ser";
-    private static final String ACTIONS_FILE = "actions_mapping.ser";
-    private static final String TRAIN_OUT_FILE = "training.bin";
-    private static final String TEST_OUT_FILE = "testing.bin";
+    public static final String MAPPING_FILE = "features_mapping.ser";
+    public static final String ACTIONS_FILE = "actions_mapping.ser";
+    public static final String TRAIN_OUT_FILE = "training.bin";
+    public static final String TEST_OUT_FILE = "testing.bin";
 
 
     @Override
@@ -44,8 +49,8 @@ public class MinimaxVectorExtractionTests extends CardTestPlayerBaseAI {
     @Override
     protected Game createNewGameAndPlayers() throws GameException, FileNotFoundException {
         Game game = new TwoPlayerDuel(MultiplayerAttackOption.LEFT, RangeOfInfluence.ONE, MulliganType.GAME_DEFAULT.getMulligan(0), 60, 20, 7);
-        playerA = createPlayer(game, "PlayerA", "C:\\Users\\WillWroble\\Documents\\" + deckNameA);
-        playerB = createPlayer(game, "PlayerB", "C:\\Users\\WillWroble\\Documents\\" + deckNameB);
+        playerA = createPlayer(game, "PlayerA",  deckNameA);
+        playerB = createPlayer(game, "PlayerB",  deckNameB);
         return game;
     }
     @Override
@@ -65,8 +70,14 @@ public class MinimaxVectorExtractionTests extends CardTestPlayerBaseAI {
         }
         return super.createPlayer(name, rangeOfInfluence);
     }
+    public void init_seed() {
+        seed = RandomUtil.nextInt();
+        System.out.printf("USING SEED: %d\n", seed);
+        RandomUtil.setSeed(seed);
+    }
     @Before
     public void init_encoder() {
+        init_seed();
         System.out.println("Setting up encoder");
         encoder = new StateEncoder();
         //ignore = new HashSet<>();
@@ -101,8 +112,8 @@ public class MinimaxVectorExtractionTests extends CardTestPlayerBaseAI {
         labeledStates = new ArrayList<>();
     }
     public void set_encoder() {
-        ComputerPlayer8 c8 = (ComputerPlayer8)playerA.getComputerPlayer();
-        c8.setEncoder(encoder);
+        ComputerPlayer8 c8 = (ComputerPlayer8)playerA.getComputerPlayer(); c8.setEncoder(encoder);
+        //c8 = (ComputerPlayer8)playerB.getComputerPlayer(); c8.setEncoder(encoder);
         encoder.setAgent(playerA.getId());
         encoder.setOpponent(playerB.getId());
     }
@@ -120,7 +131,7 @@ public class MinimaxVectorExtractionTests extends CardTestPlayerBaseAI {
     public void reset_vectors() {
         encoder.macroStateVectors.clear();
         encoder.stateScores.clear();
-        ActionEncoder.actionVectors.clear();
+        encoder.actionVectors.clear();
     }
 
     /**
@@ -133,77 +144,103 @@ public class MinimaxVectorExtractionTests extends CardTestPlayerBaseAI {
 
         labeledStateBatch.clear();
         for(int i = 0; i < N; i++) {
-            // 1) decompress your raw state and action bits (you already have this)
-            boolean[] state = encoder.getCompressedVector(encoder.macroStateVectors.get(i));
-            boolean[] action = ActionEncoder.actionVectors.get(i);
-
-            // 2) get your raw minimax score and normalize into [-1,+1]
-            double rawScore = encoder.stateScores.get(i);
-            //double normScore = rawScore / (double)Math.abs(GameStateEvaluator2.LOSE_GAME_SCORE);
-
-            double scale = 20000.0;              // or better yet: maxAbs(stateScores)
-            double normScore = Math.tanh(rawScore/scale);
+            Set<Integer> state = encoder.macroStateVectors.get(i);
+            double[] action = encoder.actionVectors.get(i);
+            double normScore = encoder.stateScores.get(i);
 
-
-            // 3) build your discounted terminal label in [-1,+1]
             boolean win = playerA.hasWon();
             double terminal = win ? +1.0 : -1.0;
             double discount = Math.pow(γ, N - i - 1);
 
-            // 4) blend them
             double blended = λ * normScore + (1.0 - λ) * terminal * discount;
 
-            // 5) store a single LabeledState with that double label
             labeledStateBatch.add(new LabeledState(state, action, blended));
         }
-
-        // shuffle before writing out / persisting
-        //Collections.shuffle(labeledStateBatch);
-
         reset_vectors();
     }
     public void print_labeled_states() {
         for (LabeledState ls : labeledStates) {
             StringBuilder sb1 = new StringBuilder();
-            for (int i = 0; i < 100; i++) {
-                sb1.append(ls.stateVector[i] ? "1" : "0");
-                //sb1.append(", ");
+            for (int i = 0; i < min(100, ls.stateVector.length); i++) {
+                sb1.append(ls.stateVector[i]);
+                sb1.append(" ");
+            }
+
+            System.out.printf("State: %s, Action: %s, Result: %s\n", sb1.toString(), Arrays.toString(ls.actionVector), ls.resultLabel);
+
+        }
+    }
+
+    /**
+     * can remove items from ignore list
+     * @param oldList
+     * @param newList
+     * @return
+     */
+    public Set<Integer> combine_ignore_lists(Set<Integer> oldList, Set<Integer> newList) {
+        Set<Integer> updatedIgnoreList = new HashSet<>();
+
+        int boundaryForOldFeatures = this.encoder.initialRawSize;
+
+
+        for (int i = 0; i < boundaryForOldFeatures; i++) {
+            if (oldList.contains(i) && newList.contains(i)) {
+                updatedIgnoreList.add(i);
             }
-            StringBuilder sb2 = new StringBuilder();
-            for (int i = 0; i < 100; i++) {
-                sb2.append(ls.actionVector[i] ? "1" : "0");
-                //sb2.append(", ");
+        }
+
+        for (Integer featureIndexInNewList : newList) {
+            if (featureIndexInNewList >= boundaryForOldFeatures) {
+                updatedIgnoreList.add(featureIndexInNewList);
             }
-            System.out.printf("State: %s, Action: %s, Result: %s\n", sb1.toString(), sb2.toString(), ls.resultLabel);
         }
+
+        return updatedIgnoreList;
+    }
+
+    /**
+     * use the current encoder's compression at the end so it can use the new ignore list
+     */
+    public void compress_labeled_states() {
+        for (LabeledState ls : labeledStates) {
+            ls.compress(encoder.getFeatures().ignoreList);
+        }
+    }
+    @Test
+    public void print_current_ignore_list() {
+        System.out.printf("IGNORE LIST SIZE: %d\n", encoder.getFeatures().ignoreList.size());
+        System.out.printf("REDUCED VECTOR SIZE: %d\n", encoder.getFeatures().localIndexCount.get() - encoder.getFeatures().ignoreList.size());
     }
     @Test
     public void make_ignore_X_50() {
         int maxTurn = 50;
         Features.printOldFeatures = false;
-        for(int i = 0; i < 50; i++) {
+        for(int i = 0; i < 10; i++) {
             setStrictChooseMode(true);
             setStopAt(maxTurn, PhaseStep.END_TURN);
             execute();
             reset_game();
             System.out.printf("GAME #%d RESET... NEW GAME STARTING\n", i+1);
         }
-        encoder.ignoreList = new HashSet<>(FeatureMerger.computeIgnoreList(encoder.macroStateVectors));
+        //assert(!encoder.getFeatures().ignoreList.isEmpty());
+        Set<Integer> newIgnore = new HashSet<>(FeatureMerger.computeIgnoreList(encoder.macroStateVectors));
+        Set<Integer> oldIgnore = new HashSet<>(encoder.getFeatures().ignoreList);
+        encoder.getFeatures().ignoreList = combine_ignore_lists(oldIgnore, newIgnore);
         //actions = new HashMap<>(ActionEncoder.actionMap);
         persistData();
-        System.out.printf("IGNORE LIST SIZE: %d\n", encoder.ignoreList.size());
-        System.out.printf("REDUCED VECTOR SIZE: %d\n", StateEncoder.indexCount - encoder.ignoreList.size());
-        //encoder.ignoreList = new HashSet<>(ignore);
+        System.out.printf("IGNORE LIST SIZE: %d\n", encoder.getFeatures().ignoreList.size());
+        System.out.printf("REDUCED VECTOR SIZE: %d\n", encoder.getFeatures().localIndexCount.get() - encoder.getFeatures().ignoreList.size());
+        //encoder.getFeatures().ignoreList = new HashSet<>(ignore);
 
     }
     /**
      * make a training set of 50 games
      */
     @Test
-    public void make_train_ds_X_50() {
+    public void make_train_ds_X_250() {
         int maxTurn = 50;
         Features.printOldFeatures = false;
-        for(int i = 0; i < 50; i++) {
+        for(int i = 0; i < 250; i++) {
             setStrictChooseMode(true);
             setStopAt(maxTurn, PhaseStep.END_TURN);
             execute();
@@ -213,10 +250,15 @@ public class MinimaxVectorExtractionTests extends CardTestPlayerBaseAI {
             reset_game();
             System.out.printf("GAME #%d RESET... NEW GAME STARTING\n", i+1);
         }
-        //Collections.shuffle(labeledStates);
+        //Set<Integer> oldIgnore = new HashSet<>(encoder.getFeatures().ignoreList);
+        encoder.getFeatures().ignoreList = new HashSet<>(FeatureMerger.computeIgnoreListFromLS(labeledStates, 0, encoder.getFeatures().localIndexCount.get()));
+        compress_labeled_states();
+
         print_labeled_states();
         persistLabeledStates(TRAIN_OUT_FILE);
         persistData();
+        System.out.printf("IGNORE LIST SIZE: %d\n", encoder.getFeatures().ignoreList.size());
+        System.out.printf("REDUCED VECTOR SIZE: %d\n", encoder.getFeatures().localIndexCount.get() - encoder.getFeatures().ignoreList.size());
     }
 
     /**
@@ -231,39 +273,55 @@ public class MinimaxVectorExtractionTests extends CardTestPlayerBaseAI {
             setStopAt(maxTurn, PhaseStep.END_TURN);
             execute();
             create_labeled_states();
-            labeledStates.addAll(labeledStateBatch.subList(0, 5));
+            //Collections.shuffle(labeledStateBatch);
+            labeledStates.addAll(labeledStateBatch);
             labeledStateBatch.clear();
             reset_game();
             System.out.printf("GAME #%d RESET... NEW GAME STARTING\n", i+1);
         }
+//        Set<Integer> newIgnore = new HashSet<>(FeatureMerger.computeIgnoreListFromLS(labeledStates));
+//        Set<Integer> oldIgnore = new HashSet<>(encoder.getFeatures().ignoreList);
+//        encoder.getFeatures().ignoreList = combine_ignore_lists(oldIgnore, newIgnore);
+        compress_labeled_states();
+
         print_labeled_states();
         persistLabeledStates(TEST_OUT_FILE);
         persistData();
+        System.out.printf("IGNORE LIST SIZE: %d\n", encoder.getFeatures().ignoreList.size());
+        System.out.printf("REDUCED VECTOR SIZE: %d\n", encoder.getFeatures().localIndexCount.get() - encoder.getFeatures().ignoreList.size());
     }
     @After
     public void print_vector_size() {
-        System.out.printf("FINAL (unreduced) VECTOR SIZE: %d\n", StateEncoder.indexCount);
+        System.out.printf("RAW VECTOR SIZE: %d\n", encoder.getFeatures().localIndexCount.get());
         System.out.printf("FINAL ACTION VECTOR SIZE: %d\n", ActionEncoder.indexCount);
         for(String s : ActionEncoder.actionMap.keySet()) {
             System.out.printf("[%s => %d] ", s, ActionEncoder.actionMap.get(s));
         }
         System.out.println();
     }
-    private void persistLabeledStates(String filename) {
-        try (DataOutputStream out = new DataOutputStream(
-                new BufferedOutputStream(new FileOutputStream(filename)))) {
+    public void persistLabeledStates(String filename) {
+        try (DataOutputStream out = new DataOutputStream(new BufferedOutputStream(Files.newOutputStream(Paths.get(filename))))) {
+
+            // 1) Header
             int n = labeledStates.size();
-            int S = labeledStates.get(0).stateVector.length;
-            int A = labeledStates.get(0).actionVector.length;
-            // Write header: #records, state-dim, action-dim
+
+            // 'S' now represents the TOTAL size of your global feature vocabulary.
+            // The constant should be updated to reflect this.
+            int S = encoder.getFeatures().localIndexCount.get();
+
+            // 'A' is still the size of the policy vector.
+            int A = 128;
+
+            // The new, simpler header:
             out.writeInt(n);
-            out.writeInt(S);
-            out.writeInt(A);
-            // Write raw data: one byte per boolean
+            out.writeInt(S); // Tells PyTorch num_embeddings for the EmbeddingBag
+            out.writeInt(A); // Tells PyTorch the size of the policy vector
+
+            // 2) Body
             for (LabeledState ls : labeledStates) {
-                for (boolean b : ls.stateVector) out.writeByte(b ? 1 : 0);
-                for (boolean b : ls.actionVector) out.writeByte(b ? 1 : 0);
-                out.writeDouble(ls.resultLabel);
+                // This now calls your MODIFIED LabeledState.persist() method,
+                // which writes a variable-length list of indices.
+                ls.persist(out);
             }
         } catch (IOException e) {
             e.printStackTrace();
diff --git a/Mage.Tests/src/test/java/org/mage/test/AI/RL/ParallelDataGenerator.java b/Mage.Tests/src/test/java/org/mage/test/AI/RL/ParallelDataGenerator.java
new file mode 100644
index 0000000000..121f7a1fc7
--- /dev/null
+++ b/Mage.Tests/src/test/java/org/mage/test/AI/RL/ParallelDataGenerator.java
@@ -0,0 +1,429 @@
+package org.mage.test.AI.RL;
+
+import mage.cards.decks.Deck;
+import mage.cards.decks.DeckCardLists;
+import mage.cards.decks.importer.DeckImporter;
+import mage.constants.*;
+import mage.game.*;
+import mage.game.match.Match;
+import mage.game.match.MatchOptions;
+import mage.game.mulligan.MulliganType;
+import mage.player.ai.*;
+import mage.util.RandomUtil;
+import org.junit.Test;
+import org.mage.test.player.TestComputerPlayer7;
+import org.mage.test.player.TestComputerPlayer8;
+import org.mage.test.player.TestPlayer;
+import org.mage.test.serverside.base.CardTestPlayerBaseAI;
+
+import java.io.*;
+import java.util.*;
+import java.util.concurrent.*;
+
+/**
+ * A dedicated, parallelized test class for generating training and testing data sets.
+ * This version is fully compatible with Java 1.8 and uses the correct, thread-safe
+ * game execution logic as defined by the test framework.
+ */
+public class ParallelDataGenerator extends CardTestPlayerBaseAI {
+
+    //region Configuration
+    // ============================ DATA GENERATION SETTINGS ============================
+    private static final int NUM_GAMES_TO_SIMULATE_TRAIN = 250;
+    private static final int NUM_GAMES_TO_SIMULATE_TEST = 50;
+    private static final int MAX_GAME_TURNS = 50;
+    private static final int MAX_CONCURRENT_GAMES = 8;
+
+    // =============================== DECK AND AI SETTINGS ===============================
+    private static final String DECK_A = "UWTempo.dck";
+    private static final String DECK_B = "simplegreen.dck";
+    private static final String MCTS_MODEL_PATH = "models/Model2.onnx";
+    private static final int MCTS_ROLLOUT_THREADS = 2;
+
+    // ================================== FILE PATHS ==================================
+    private static final String MAPPING_FILE = "features_mapping.ser";
+    private static final String ACTIONS_FILE = "actions_mapping.ser";
+    private static final String TRAIN_OUT_FILE = "training.bin";
+    private static final String TEST_OUT_FILE = "testing.bin";
+    // ================================== GLOBAL FIELDS ==================================
+    private Features finalFeatures;
+    private int initialRawSize;
+    private int previousRawSize;
+    //end region
+
+    /**
+     * A simple class to hold the results of a single game, compatible with Java 1.8.
+     */
+    private static class GameResult {
+        private final List<LabeledState> states;
+        private final boolean didPlayerAWin;
+
+        public GameResult(List<LabeledState> states, boolean didPlayerAWin) {
+            this.states = states;
+            this.didPlayerAWin = didPlayerAWin;
+        }
+
+        public List<LabeledState> getStates() {
+            return states;
+        }
+
+        public boolean didPlayerAWin() {
+            return didPlayerAWin;
+        }
+    }
+
+    @Test
+    public void print_mappings() {
+        //load base mapping
+        try {
+            finalFeatures = Features.loadMapping(MAPPING_FILE);
+            ActionEncoder.actionMap = (Map<String, Integer>) loadObject(ACTIONS_FILE);
+        } catch (IOException | ClassNotFoundException e) {
+            System.err.println("failed to load persistent mappings.");
+        }
+        finalFeatures.printFeatureTree(false);
+        System.out.println("Ignore list size: " + finalFeatures.ignoreList.size());
+        System.out.println("Ignore list:");
+        System.out.println(finalFeatures.ignoreList.toString());
+        System.out.println("Action map:");
+        String[] aMap = new String[ActionEncoder.actionMap.size()];
+        for (String s : ActionEncoder.actionMap.keySet()) {
+            //System.out.printf("[%s => %d] ", s, ActionEncoder.actionMap.get(s));
+            aMap[ActionEncoder.actionMap.get(s)] = s;
+        }
+        for (int i = 0; i < aMap.length; i++) {
+            System.out.println(i + " => " + aMap[i]);
+        }
+    }
+
+    @Test
+    public void generateTrainingAndTestingData() {
+
+        //load original mapping as starting point
+        finalFeatures = new Features();
+        initialRawSize = 0;
+        previousRawSize = 0;
+        //load base mapping
+        try {
+            finalFeatures = Features.loadMapping(MAPPING_FILE);
+            initialRawSize = finalFeatures.localIndexCount.get();
+            previousRawSize = finalFeatures.previousLocalIndexCount;
+        } catch (IOException | ClassNotFoundException e) {
+            System.err.println("failed to load persistent mappings.");
+        }
+        Features.printOldFeatures = false;
+        //Features.printNewFeatures = false;
+
+        System.out.println("\n=========================================");
+        System.out.println("    STARTING TESTING DATA GENERATION     ");
+        System.out.println("=========================================");
+
+        List<LabeledState> testingStates = runSimulations(NUM_GAMES_TO_SIMULATE_TEST);
+
+        System.out.println("=========================================");
+        System.out.println("   STARTING TRAINING DATA GENERATION     ");
+        System.out.println("=========================================");
+
+
+        List<LabeledState> trainingStates = runSimulations(NUM_GAMES_TO_SIMULATE_TRAIN);
+
+        //save both data files at once
+        processAndSaveData(trainingStates, testingStates);
+
+        System.out.println("\nData generation complete.");
+    }
+
+    private List<LabeledState> runSimulations(int numGames) {
+        int availableCores = Runtime.getRuntime().availableProcessors();
+        int poolSize = MAX_CONCURRENT_GAMES;
+        System.out.printf("Simulating %d games. Using thread pool of size %d on %d available cores.\n", numGames, poolSize, availableCores);
+
+        ExecutorService executor = Executors.newFixedThreadPool(poolSize);
+        List<Callable<GameResult>> tasks = new ArrayList<>();
+        for (int i = 0; i < numGames; i++) {
+            tasks.add(new Callable<GameResult>() {
+                @Override
+                public GameResult call() throws Exception {
+                    return runSingleGame();
+                }
+            });
+        }
+
+        List<LabeledState> allLabeledStates = new ArrayList<>();
+        int wins = 0;
+        int successfulGames = 0;
+        int failedGames = 0;
+        try {
+            List<Future<GameResult>> futures = executor.invokeAll(tasks);
+            executor.shutdown();
+
+            for (Future<GameResult> future : futures) {
+                try {
+                    // future.get() will block until the task is complete.
+                    GameResult result = future.get();
+                    allLabeledStates.addAll(result.getStates());
+                    if (result.didPlayerAWin()) {
+                        wins++;
+                    }
+                    successfulGames++;
+
+                } catch (ExecutionException e) {
+                    failedGames++;
+                    System.err.println("A game simulation failed and its result will be ignored. Cause: " + e.getCause());
+                    e.getCause().printStackTrace();
+                }
+                // The loop continues to the next future, ignoring the failed one.
+            }
+        } catch (InterruptedException e) {
+            System.err.println("Main simulation thread was interrupted. Shutting down.");
+            e.printStackTrace();
+            Thread.currentThread().interrupt();
+        }
+        System.out.printf("\n--- Simulation Summary ---\n");
+        System.out.printf("Total requested: %d games\n", numGames);
+        System.out.printf("Successful: %d\n", successfulGames);
+        System.out.printf("Failed: %d\n", failedGames);
+        System.out.printf("Player A win rate: %.2f%% (%d/%d)\n", (100.0 * wins / numGames), wins, numGames);
+        return allLabeledStates;
+    }
+
+    public void print_labeled_states(List<LabeledState> labeledStates) {
+        for (LabeledState ls : labeledStates) {
+            StringBuilder sb1 = new StringBuilder();
+            for (int i = 0; i < 100; i++) {
+                sb1.append(ls.stateVector[i]);
+                sb1.append(" ");
+            }
+
+            System.out.printf("State: %s, Action: %s, Result: %s\n", sb1.toString(), Arrays.toString(ls.actionVector), ls.resultLabel);
+
+        }
+    }
+
+    private void processAndSaveData(List<LabeledState> trainingStates, List<LabeledState> testingStates) {
+        List<LabeledState> allStates = new ArrayList<>(trainingStates);
+        allStates.addAll(testingStates);
+        if (allStates.isEmpty()) {
+            System.out.println("No states were generated, skipping file save for " + ParallelDataGenerator.TRAIN_OUT_FILE);
+            return;
+        }
+        //print_labeled_states(trainingStates);
+        System.out.println("Processing " + allStates.size() + " states.");
+        System.out.println("Previous Index Count: " + previousRawSize);
+        System.out.println("Initial Index Count: " + initialRawSize);
+        System.out.println("Final Index Count: " + finalFeatures.localIndexCount.get());
+        Set<Integer> oldIgnoreList = new HashSet<>(finalFeatures.ignoreList);
+        Set<Integer> newIgnoreListA = new HashSet<>(FeatureMerger.computeIgnoreListFromLS(allStates, 0, previousRawSize));
+        Set<Integer> newIgnoreListB = new HashSet<>(FeatureMerger.computeIgnoreListFromLS(allStates, previousRawSize, initialRawSize));
+        System.out.println("Computed " + newIgnoreListB.size() + " features to ignore from this batch.");
+        //intersect
+        newIgnoreListA.retainAll(oldIgnoreList);
+        //union
+        newIgnoreListA.addAll(newIgnoreListB);
+        finalFeatures.ignoreList = newIgnoreListA;
+        System.out.println("Final combined ignore list size: " + finalFeatures.ignoreList.size());
+
+        System.out.println("Compressing all states...");
+        for (LabeledState ls : allStates) {
+            ls.compress(finalFeatures.ignoreList);
+        }
+        System.out.println("Final Compressed Feature Vector Size: " + (finalFeatures.localIndexCount.get() - finalFeatures.ignoreList.size()));
+        persistLabeledStates(trainingStates, ParallelDataGenerator.TRAIN_OUT_FILE);
+        persistLabeledStates(testingStates, ParallelDataGenerator.TEST_OUT_FILE);
+        persistData();
+        System.out.println("Successfully saved data to " + ParallelDataGenerator.TRAIN_OUT_FILE + " and " + ParallelDataGenerator.TEST_OUT_FILE);
+    }
+
+    private GameResult runSingleGame() throws ExecutionException {
+        try {
+
+            Game game;
+            StateEncoder threadEncoder = new StateEncoder();
+
+            // Use a thread-safe random number generator for the seed.
+            long gameSeed = ThreadLocalRandom.current().nextLong();
+            RandomUtil.setSeed(gameSeed);
+
+
+            // All game objects are local to this thread to prevent race conditions.
+            MatchOptions matchOptions = new MatchOptions("test match", "test game type", true, 4);
+            Match localMatch = new FreeForAllMatch(matchOptions);
+            game = new TwoPlayerDuel(MultiplayerAttackOption.LEFT, RangeOfInfluence.ONE, MulliganType.GAME_DEFAULT.getMulligan(0), 60, 20, 7);
+            TestPlayer playerA = createLocalPlayer(game, "PlayerA", DECK_A, localMatch);
+            TestPlayer playerB = createLocalPlayer(game, "PlayerB", DECK_B, localMatch);
+
+            try {
+                threadEncoder.loadMapping(finalFeatures);
+                ActionEncoder.actionMap = (Map<String, Integer>) loadObject(ACTIONS_FILE);
+                ActionEncoder.indexCount = ActionEncoder.actionMap.size();
+            } catch (IOException | ClassNotFoundException e) {
+                System.err.println("Worker thread failed to load persistent mappings.");
+            }
+
+            configurePlayer(playerA, threadEncoder);
+            configurePlayer(playerB, threadEncoder);
+            threadEncoder.setAgent(playerA.getId());
+            threadEncoder.setOpponent(playerB.getId());
+
+            // Based on CardTestPlayerAPIImpl.java, this is the correct thread-safe
+            // way to configure and run a game simulation.
+            GameOptions options = new GameOptions();
+            options.testMode = true;
+            options.stopOnTurn = MAX_GAME_TURNS;
+            options.stopAtStep = PhaseStep.END_TURN;
+            game.setGameOptions(options);
+
+            // Start the game simulation. This is a blocking call that will run the game to completion.
+            game.start(playerA.getId());
+
+            // The rest of the logic is safe as it uses the local player objects.
+            boolean playerAWon = playerA.hasWon();
+            //merge to the final features
+            finalFeatures.merge(threadEncoder.getFeatures());
+            synchronized (finalFeatures) {
+                assert (finalFeatures.localIndexCount.get() >= threadEncoder.getFeatures().localIndexCount.get());
+            }
+            return new GameResult(generateLabeledStatesForGame(threadEncoder, playerAWon), playerAWon);
+        } catch (Exception e) {
+            System.err.println("Caught an internal AI/Game exception in a worker thread. Ignoring this game. Cause: " + e.getMessage());
+            throw new ExecutionException("Worker thread failed - ignoring", e);
+        }
+    }
+
+    private void configurePlayer(TestPlayer player, StateEncoder encoder) {
+        if (player.getComputerPlayer() instanceof ComputerPlayerMCTS2) {
+            ((ComputerPlayerMCTS2) player.getComputerPlayer()).setEncoder(encoder);
+            ((ComputerPlayerMCTS2) player.getComputerPlayer()).initNN(MCTS_MODEL_PATH);
+        } else if (player.getComputerPlayer() instanceof ComputerPlayer8) {
+            ((ComputerPlayer8) player.getComputerPlayer()).setEncoder(encoder);
+        } else if (player.getComputerPlayer() instanceof ComputerPlayerPureMCTS) {
+            ((ComputerPlayerPureMCTS) player.getComputerPlayer()).setEncoder(encoder);
+        }
+    }
+
+    private List<LabeledState> generateLabeledStatesForGame(StateEncoder encoder, boolean didPlayerAWin) {
+        synchronized (encoder) {
+            List<LabeledState> results = new ArrayList<>();
+            int N = encoder.macroStateVectors.size();
+            double gamma = 0.99;
+            double lambda = 0.5;
+
+            for (int i = 0; i < N; i++) {
+                Set<Integer> state = encoder.macroStateVectors.get(i);
+                double[] action = encoder.actionVectors.get(i);
+                double normScore = encoder.stateScores.get(i);
+                double terminal = didPlayerAWin ? +1.0 : -1.0;
+                double discount = Math.pow(gamma, N - i - 1);
+                double blended = lambda * normScore + (1.0 - lambda) * terminal * discount;
+                results.add(new LabeledState(state, action, blended));
+            }
+            return results;
+        }
+    }
+
+    //region Helper Methods
+    public Set<Integer> combine_ignore_lists(Set<Integer> oldList, Set<Integer> newList) {
+        Set<Integer> updatedIgnoreList = new HashSet<>();
+        int boundaryForOldFeatures = previousRawSize;
+
+        for (int i = 0; i < boundaryForOldFeatures; i++) {
+            if (oldList.contains(i) && newList.contains(i)) {
+                updatedIgnoreList.add(i);
+            }
+        }
+        for (Integer featureIndexInNewList : newList) {
+            if (featureIndexInNewList >= boundaryForOldFeatures) {
+                updatedIgnoreList.add(featureIndexInNewList);
+            }
+        }
+        return updatedIgnoreList;
+    }
+
+    public void persistData() {
+        try {
+            finalFeatures.previousLocalIndexCount = initialRawSize;
+            finalFeatures.version++;
+            finalFeatures.saveMapping(MAPPING_FILE);
+            System.out.printf("Persisted feature mapping (and ignore list) to %s%n", MAPPING_FILE);
+            saveObject(new HashMap<>(ActionEncoder.actionMap), ACTIONS_FILE);
+            System.out.printf("Persisted action mapping to %s%n", ACTIONS_FILE);
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+    }
+
+    private void persistLabeledStates(List<LabeledState> states, String filename) {
+        try (DataOutputStream out = new DataOutputStream(new BufferedOutputStream(new FileOutputStream(filename)))) {
+            out.writeInt(states.size());
+            out.writeInt(finalFeatures.localIndexCount.get());
+            out.writeInt(128); // Assuming policy vector size is constant
+
+            for (LabeledState ls : states) {
+                ls.persist(out, finalFeatures.localIndexCount.get());
+            }
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+    }
+
+    private static void saveObject(Object obj, String fileName) throws IOException {
+        try (ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(fileName))) {
+            out.writeObject(obj);
+        }
+    }
+
+    private static Object loadObject(String fileName) throws IOException, ClassNotFoundException {
+        try (ObjectInputStream in = new ObjectInputStream(new FileInputStream(fileName))) {
+            return in.readObject();
+        }
+    }
+
+    //endregion
+    @Override
+    public List<String> getFullSimulatedPlayers() {
+        return Arrays.asList("PlayerA", "PlayerB");
+    }
+
+    protected TestPlayer createLocalPlayer(Game game, String name, String deckName, Match match) throws GameException {
+        TestPlayer player = createNewPlayer(name, game.getRangeOfInfluence());
+        player.setTestMode(true);
+
+        logger.debug("Loading deck...");
+        DeckCardLists list;
+        if (loadedDecks.containsKey(deckName)) {
+            list = loadedDecks.get(deckName);
+        } else {
+            list = DeckImporter.importDeckFromFile(deckName, true);
+            loadedDecks.put(deckName, list);
+        }
+        Deck deck = Deck.load(list, false, false, loadedCardInfo);
+        logger.debug("Done!");
+        if (deck.getMaindeckCards().size() < 40) {
+            throw new IllegalArgumentException("Couldn't load deck, deck size=" + deck.getMaindeckCards().size());
+        }
+
+        game.loadCards(deck.getCards(), player.getId());
+        game.loadCards(deck.getSideboard(), player.getId());
+        game.addPlayer(player, deck);
+        match.addPlayer(player, deck); // fake match
+
+        return player;
+    }
+
+    // This is the correct override to use for creating players within our self-contained games.
+    @Override
+    protected TestPlayer createPlayer(String name, RangeOfInfluence rangeOfInfluence) {
+        if (name.equals("PlayerA")) {
+            TestComputerPlayer8 t8 = new TestComputerPlayer8(name, RangeOfInfluence.ONE, getSkillLevel());
+            TestPlayer testPlayer = new TestPlayer(t8);
+            testPlayer.setAIPlayer(true);
+            return testPlayer;
+        } else {
+            TestComputerPlayer7 t7 = new TestComputerPlayer7(name, RangeOfInfluence.ONE, getSkillLevel());
+            TestPlayer testPlayer = new TestPlayer(t7);
+            testPlayer.setAIPlayer(true);
+            return testPlayer;
+        }
+    }
+    //endregion
+}
\ No newline at end of file
diff --git a/Mage.Tests/src/test/java/org/mage/test/AI/RL/PureMCTSTests.java b/Mage.Tests/src/test/java/org/mage/test/AI/RL/PureMCTSTests.java
index 24027cfe92..edd4d4bbc8 100644
--- a/Mage.Tests/src/test/java/org/mage/test/AI/RL/PureMCTSTests.java
+++ b/Mage.Tests/src/test/java/org/mage/test/AI/RL/PureMCTSTests.java
@@ -44,8 +44,8 @@ public class PureMCTSTests extends CardTestPlayerBaseAI {
     @Override
     protected Game createNewGameAndPlayers() throws GameException, FileNotFoundException {
         Game game = new TwoPlayerDuel(MultiplayerAttackOption.LEFT, RangeOfInfluence.ONE, MulliganType.GAME_DEFAULT.getMulligan(0), 60, 20, 7);
-        playerA = createPlayer(game, "PlayerA", "C:\\Users\\WillWroble\\Documents\\" + deckNameA);
-        playerB = createPlayer(game, "PlayerB", "C:\\Users\\WillWroble\\Documents\\" + deckNameB);
+        playerA = createPlayer(game, "PlayerA", "C:\\Users\\owner\\Documents\\" + deckNameA);
+        playerB = createPlayer(game, "PlayerB", "C:\\Users\\owner\\Documents\\" + deckNameB);
         return game;
     }
     @Override
diff --git a/Mage.Tests/src/test/java/org/mage/test/AI/RL/RLEncodingTests.java b/Mage.Tests/src/test/java/org/mage/test/AI/RL/RLEncodingTests.java
index e9df3044fb..a18e896895 100644
--- a/Mage.Tests/src/test/java/org/mage/test/AI/RL/RLEncodingTests.java
+++ b/Mage.Tests/src/test/java/org/mage/test/AI/RL/RLEncodingTests.java
@@ -17,19 +17,22 @@ import org.mage.test.player.TestPlayer;
 import org.mage.test.serverside.base.CardTestPlayerBaseAI;
 
 import java.io.FileNotFoundException;
+import java.io.IOException;
 import java.util.Arrays;
-import java.util.BitSet;
+import java.util.HashMap;
 import java.util.List;
 import java.util.Set;
 
+import static org.mage.test.AI.RL.MinimaxVectorExtractionTests.MAPPING_FILE;
+
 /**
  * @author WillWroble
  */
 public class RLEncodingTests extends CardTestPlayerBaseAI {
     StateEncoder encoder;
-    private String deckNameA = "simplegreen.dck"; //simplegreen, UWTempo
-    private String deckNameB = "simplegreen.dck";
-
+    private String deckNameB = "UWTempo.dck"; //simplegreen, UWTempo
+    private String deckNameA = "simplegreen.dck";
+    Features old_features;
 
     @Override
     public List<String> getFullSimulatedPlayers() {
@@ -39,8 +42,8 @@ public class RLEncodingTests extends CardTestPlayerBaseAI {
     @Override
     protected Game createNewGameAndPlayers() throws GameException, FileNotFoundException {
         Game game = new TwoPlayerDuel(MultiplayerAttackOption.LEFT, RangeOfInfluence.ONE, MulliganType.GAME_DEFAULT.getMulligan(0), 60, 20, 7);
-        playerA = createPlayer(game, "PlayerA", "C:\\Users\\WillWroble\\Documents\\" + deckNameA);
-        playerB = createPlayer(game, "PlayerB", "C:\\Users\\WillWroble\\Documents\\" + deckNameB);
+        playerA = createPlayer(game, "PlayerA", "C:\\Users\\owner\\Documents\\" + deckNameA);
+        playerB = createPlayer(game, "PlayerB", "C:\\Users\\owner\\Documents\\" + deckNameB);
         return game;
     }
     @Override
@@ -67,10 +70,24 @@ public class RLEncodingTests extends CardTestPlayerBaseAI {
         set_encoder();
     }
     public void set_encoder() {
+        //if(true) return;
         ComputerPlayer8 c8 = (ComputerPlayer8)playerA.getComputerPlayer();
         c8.setEncoder(encoder);
         encoder.setAgent(playerA.getId());
         encoder.setOpponent(playerB.getId());
+        //if(true) return;
+        try {
+            old_features = Features.loadMapping(MAPPING_FILE);
+        } catch (IOException | ClassNotFoundException e) {
+            throw new RuntimeException("failed to load persistent mappings.", e);
+        }
+        if(true) return;
+        try {
+            encoder.loadMapping(MAPPING_FILE);
+        } catch (IOException | ClassNotFoundException e) {
+            throw new RuntimeException("failed to load persistent mappings.", e);
+        }
+
     }
     public void reset_game() {
         try {
@@ -86,14 +103,32 @@ public class RLEncodingTests extends CardTestPlayerBaseAI {
     //5 turns across 1 game
     @Test
     public void test_encoding_5_1() {
+        Features.printOldFeatures = false;
         // simple test of 5 turns
         int maxTurn = 5;
-
         //addCard(Zone.HAND, playerA, "Fauna Shaman", 3);
         setStrictChooseMode(true);
         setStopAt(maxTurn, PhaseStep.END_TURN);
         execute();
 
+//        try {
+//            encoder.getFeatures().saveMapping(MAPPING_FILE);
+//            System.out.printf("Persisted feature mapping (and ignore list) to %s%n", MAPPING_FILE);
+//        } catch (IOException e) {
+//            e.printStackTrace();
+//        }
+        //if(true) return;
+        logger.info(old_features.localIndexCount);
+        logger.info(encoder.getFeatures().localIndexCount);
+        old_features.merge(encoder.getFeatures());
+        logger.info(old_features.localIndexCount);
+
+        try {
+            old_features.saveMapping(MAPPING_FILE);
+            System.out.printf("Persisted feature mapping (and ignore list) to %s%n", MAPPING_FILE);
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
     }
     //20 turns across 1 game
     @Test
@@ -110,6 +145,7 @@ public class RLEncodingTests extends CardTestPlayerBaseAI {
     public void test_encoding_5_5() {
         int maxTurn = 5;
         Features.printOldFeatures = false;
+        Features.printNewFeatures  =false;
         for(int i = 0; i < 5; i++) {
             setStrictChooseMode(true);
             setStopAt(maxTurn, PhaseStep.END_TURN);
@@ -222,29 +258,7 @@ public class RLEncodingTests extends CardTestPlayerBaseAI {
         execute();
         System.out.println(ignore);
     }
-    @Test
-    public void test_state_consistency() {
-        int maxTurn = 10;
-        //removeAllCardsFromHand(playerA);
-        setStrictChooseMode(true);
-        setStopAt(maxTurn, PhaseStep.END_TURN);
-        execute();
-        //save state after 5 turns
-        int bookmarkedState = currentGame.bookmarkState();
-        BitSet savedVec = StateEncoder.featureVector;
-        reset_game();
-        //simulate another 5 turns
-        setStrictChooseMode(true);
-        setStopAt(maxTurn, PhaseStep.END_TURN);
-        execute();
-        //reload state and read it
-        currentGame.restoreState(bookmarkedState, "rolling_back_for_testing");
-        encoder.processState(currentGame);
-        BitSet newVec = StateEncoder.featureVector;
-        System.out.println(savedVec);
-        System.out.println(newVec);
-        assert (savedVec.equals(newVec));
-    }
+
     @After
     public void print_vector_size() {
         System.out.printf("FINAL (unreduced) VECTOR SIZE: %d\n", StateEncoder.indexCount);
diff --git a/Mage.Tests/src/test/java/org/mage/test/AI/RL/SimulateMCTS.java b/Mage.Tests/src/test/java/org/mage/test/AI/RL/SimulateMCTS.java
new file mode 100644
index 0000000000..ef94d9afbb
--- /dev/null
+++ b/Mage.Tests/src/test/java/org/mage/test/AI/RL/SimulateMCTS.java
@@ -0,0 +1,30 @@
+package org.mage.test.AI.RL;
+
+import mage.constants.RangeOfInfluence;
+import org.junit.Test;
+import org.mage.test.player.*;
+
+public class SimulateMCTS extends ParallelDataGenerator {
+
+
+    @Test
+    public void generateTrainingAndTestingData() {
+        super.generateTrainingAndTestingData();
+    }
+
+    // This is the correct override to use for creating players within our self-contained games.
+    @Override
+    protected TestPlayer createPlayer(String name, RangeOfInfluence rangeOfInfluence) {
+        if(name.equals("PlayerA")) {
+            TestComputerPlayerMonteCarlo2 mcts2 = new TestComputerPlayerMonteCarlo2(name, RangeOfInfluence.ONE, getSkillLevel());
+            TestPlayer testPlayer = new TestPlayer(mcts2);
+            testPlayer.setAIPlayer(true); // enable full AI support (game simulations) for all turns by default
+            return testPlayer;
+        } else {
+            TestComputerPlayer8 t8 = new TestComputerPlayer8(name, RangeOfInfluence.ONE, getSkillLevel());
+            TestPlayer testPlayer = new TestPlayer(t8);
+            testPlayer.setAIPlayer(true);
+            return testPlayer;
+        }
+    }
+}
diff --git a/Mage.Tests/src/test/java/org/mage/test/AI/RL/SimulatePureMCTS.java b/Mage.Tests/src/test/java/org/mage/test/AI/RL/SimulatePureMCTS.java
new file mode 100644
index 0000000000..18d6d36ecd
--- /dev/null
+++ b/Mage.Tests/src/test/java/org/mage/test/AI/RL/SimulatePureMCTS.java
@@ -0,0 +1,31 @@
+package org.mage.test.AI.RL;
+
+import mage.constants.RangeOfInfluence;
+import mage.player.ai.ComputerPlayerPureMCTS;
+import org.junit.Test;
+import org.mage.test.player.*;
+
+public class SimulatePureMCTS extends ParallelDataGenerator {
+
+
+    @Test
+    public void generateTrainingAndTestingData() {
+        super.generateTrainingAndTestingData();
+    }
+
+    // This is the correct override to use for creating players within our self-contained games.
+    @Override
+    protected TestPlayer createPlayer(String name, RangeOfInfluence rangeOfInfluence) {
+        if(name.equals("PlayerA")) {
+            TestComputerPlayerPureMonteCarlo pmcts = new TestComputerPlayerPureMonteCarlo(name, RangeOfInfluence.ONE, getSkillLevel());
+            TestPlayer testPlayer = new TestPlayer(pmcts);
+            testPlayer.setAIPlayer(true); // enable full AI support (game simulations) for all turns by default
+            return testPlayer;
+        } else {
+            TestComputerPlayer8 t8 = new TestComputerPlayer8(name, RangeOfInfluence.ONE, getSkillLevel());
+            TestPlayer testPlayer = new TestPlayer(t8);
+            testPlayer.setAIPlayer(true);
+            return testPlayer;
+        }
+    }
+}
diff --git a/Mage.Tests/src/test/java/org/mage/test/player/TestComputerPlayer7.java b/Mage.Tests/src/test/java/org/mage/test/player/TestComputerPlayer7.java
index 4e4aff6b5c..2d5fef98c5 100644
--- a/Mage.Tests/src/test/java/org/mage/test/player/TestComputerPlayer7.java
+++ b/Mage.Tests/src/test/java/org/mage/test/player/TestComputerPlayer7.java
@@ -7,6 +7,7 @@ import mage.constants.Outcome;
 import mage.constants.RangeOfInfluence;
 import mage.game.Game;
 import mage.player.ai.ComputerPlayer7;
+import mage.player.ai.ComputerPlayerMinimaxOpponent;
 import mage.target.Target;
 import mage.target.TargetCard;
 
@@ -18,7 +19,7 @@ import mage.target.TargetCard;
  * @author JayDi85
  */
 
-public final class TestComputerPlayer7 extends ComputerPlayer7 {
+public final class TestComputerPlayer7 extends ComputerPlayerMinimaxOpponent {
 
     private TestPlayer testPlayerLink;
 
diff --git a/Mage.Tests/src/test/java/org/mage/test/player/TestPlayer.java b/Mage.Tests/src/test/java/org/mage/test/player/TestPlayer.java
index e82d12ad8a..c45bcda1b2 100644
--- a/Mage.Tests/src/test/java/org/mage/test/player/TestPlayer.java
+++ b/Mage.Tests/src/test/java/org/mage/test/player/TestPlayer.java
@@ -169,6 +169,15 @@ public class TestPlayer implements Player {
         this.strictChooseMode = testPlayer.strictChooseMode;
     }
 
+    @Override
+    public Ability getLastActivated() {
+        return computerPlayer.getLastActivated();
+    }
+    @Override
+    public void setLastActivated(Ability a) {
+        computerPlayer.setLastActivated(a);
+    }
+
     public void addChoice(String choice) {
         // prepare face down
         // how-to fix:
diff --git a/Mage.Tests/testing.bin b/Mage.Tests/testing.bin
new file mode 100644
index 0000000000..2be2d05df1
Binary files /dev/null and b/Mage.Tests/testing.bin differ
diff --git a/Mage.Tests/training.bin b/Mage.Tests/training.bin
index 0fc6e5a2b2..36182be290 100644
Binary files a/Mage.Tests/training.bin and b/Mage.Tests/training.bin differ
diff --git a/Mage/src/main/java/mage/abilities/condition/common/SourceMatchesFilterCondition.java b/Mage/src/main/java/mage/abilities/condition/common/SourceMatchesFilterCondition.java
index 570ce68ed0..f91478cfe6 100644
--- a/Mage/src/main/java/mage/abilities/condition/common/SourceMatchesFilterCondition.java
+++ b/Mage/src/main/java/mage/abilities/condition/common/SourceMatchesFilterCondition.java
@@ -31,7 +31,7 @@ public class SourceMatchesFilterCondition implements Condition {
     @Override
     public boolean apply(Game game, Ability source) {
         Permanent permanent = source.getSourcePermanentOrLKI(game);
-        return filter.match(permanent, permanent.getControllerId(), source, game);
+        return filter.match(permanent, permanent == null ? source.getControllerId() : permanent.getControllerId(), source, game);
     }
 
     @Override
diff --git a/Mage/src/main/java/mage/abilities/mana/AnyColorPermanentTypesManaAbility.java b/Mage/src/main/java/mage/abilities/mana/AnyColorPermanentTypesManaAbility.java
index f6cd43bbfc..75d61936a7 100644
--- a/Mage/src/main/java/mage/abilities/mana/AnyColorPermanentTypesManaAbility.java
+++ b/Mage/src/main/java/mage/abilities/mana/AnyColorPermanentTypesManaAbility.java
@@ -58,7 +58,7 @@ class AnyColorPermanentTypesManaEffect extends ManaEffect {
 
     public AnyColorPermanentTypesManaEffect(TargetController targetController, FilterPermanent permanentTypes) {
         super();
-        filter = permanentTypes;
+        filter = permanentTypes.copy();
         filter.add(targetController.getControllerPredicate());
         staticText = "Add one mana of any color" +
                 " among " + permanentTypes.getMessage() + " " +
diff --git a/Mage/src/main/java/mage/cards/decks/DeckCardLayout.java b/Mage/src/main/java/mage/cards/decks/DeckCardLayout.java
index b12e9b7cee..966a8dceb8 100644
--- a/Mage/src/main/java/mage/cards/decks/DeckCardLayout.java
+++ b/Mage/src/main/java/mage/cards/decks/DeckCardLayout.java
@@ -2,13 +2,14 @@ package mage.cards.decks;
 
 import mage.util.Copyable;
 
+import java.io.Serializable;
 import java.util.ArrayList;
 import java.util.List;
 
 /**
  * Created by stravant@gmail.com on 2016-10-03.
  */
-public class DeckCardLayout implements Copyable<DeckCardLayout> {
+public class DeckCardLayout implements Copyable<DeckCardLayout>, Serializable {
 
     private final List<List<List<DeckCardInfo>>> cards;
     private final String settings;
diff --git a/Mage/src/main/java/mage/constants/PhaseStep.java b/Mage/src/main/java/mage/constants/PhaseStep.java
index 5b71c6e09b..3d94af36cc 100644
--- a/Mage/src/main/java/mage/constants/PhaseStep.java
+++ b/Mage/src/main/java/mage/constants/PhaseStep.java
@@ -47,11 +47,11 @@ public enum PhaseStep {
     public int getIndex() {
         return index;
     }
-
-    @Override
-    public String toString() {
-        return text;
-    }
+//
+//    @Override
+//    public String toString() {
+//        return text;
+//    }
 
     public static PhaseStep fromString(String needText) {
         return Arrays.stream(values())
diff --git a/Mage/src/main/java/mage/game/Exile.java b/Mage/src/main/java/mage/game/Exile.java
index 7d8b7bd566..813342e32f 100644
--- a/Mage/src/main/java/mage/game/Exile.java
+++ b/Mage/src/main/java/mage/game/Exile.java
@@ -14,7 +14,7 @@ import java.util.stream.Collectors;
  */
 public class Exile implements Serializable, Copyable<Exile> {
 
-    private static final UUID PERMANENT = UUID.randomUUID();
+    private final UUID PERMANENT = UUID.nameUUIDFromBytes("Permanent".getBytes());
 
     private final Map<UUID, ExileZone> exileZones = new HashMap<>();
 
diff --git a/Mage/src/main/java/mage/game/Game.java b/Mage/src/main/java/mage/game/Game.java
index 2df39b9016..4fabcbdb5a 100644
--- a/Mage/src/main/java/mage/game/Game.java
+++ b/Mage/src/main/java/mage/game/Game.java
@@ -46,6 +46,14 @@ import java.util.*;
 import java.util.stream.Collectors;
 
 public interface Game extends MageItem, Serializable, Copyable<Game> {
+//    void setMacroState(Game game);
+//    void setMacroPlayerId(UUID id);
+//    void setLastAction(Ability ability);
+    Game getLastPriority();
+    UUID getLastPriorityPlayerId();
+    Ability getLastPriorityAction();
+
+    void setLastPriority(Game game);
 
     MatchType getGameType();
 
@@ -640,6 +648,9 @@ public interface Game extends MageItem, Serializable, Copyable<Game> {
 
     boolean executingRollback();
 
+    void addCard(UUID cardId, Card card);
+
+
     /**
      * Add counters to permanent before ETB. Use it before put real permanent to battlefield.
      */
diff --git a/Mage/src/main/java/mage/game/GameImpl.java b/Mage/src/main/java/mage/game/GameImpl.java
index fcacee29f7..6217062e15 100644
--- a/Mage/src/main/java/mage/game/GameImpl.java
+++ b/Mage/src/main/java/mage/game/GameImpl.java
@@ -93,6 +93,10 @@ import java.util.stream.Collectors;
  * If it's a temporary/auto-generated data then mark that field as transient and comment in copy constructor.
  */
 public abstract class GameImpl implements Game {
+    //shallow game history for AI
+    private Game lastPriority = this;
+    private UUID lastPriorityPlayerId;
+    public Ability lastPriorityAction;
 
     private static final int ROLLBACK_TURNS_MAX = 4;
     private static final String UNIT_TESTS_ERROR_TEXT = "Error in unit tests";
@@ -182,6 +186,8 @@ public abstract class GameImpl implements Game {
     }
 
     protected GameImpl(final GameImpl game) {
+        this.lastPriorityAction = game.lastPriorityAction;
+        this.lastPriorityPlayerId = game.lastPriorityPlayerId;
         //this.customData = game.customData; // temporary data, no need on game copy
         //this.losingPlayer = game.losingPlayer; // temporary data, no need on game copy
         this.aiGame = game.aiGame;
@@ -247,6 +253,48 @@ public abstract class GameImpl implements Game {
          */
     }
 
+    /**
+     * @return the game object from right before the last priority
+     */
+    @Override
+    public Game getLastPriority() {
+        return lastPriority;
+    }
+
+    /**
+     * @return the id of the player who last had priority
+     */
+    @Override
+    public UUID getLastPriorityPlayerId() {
+        return lastPriorityPlayerId;
+    }
+
+    /**
+     * @return the action made during the last priority
+     */
+    @Override
+    public Ability getLastPriorityAction() {
+        return lastPriorityAction;
+    }
+    /**
+     * @return the action made during the last priority
+     */
+    @Override
+    public void setLastPriority(Game game) {
+        lastPriority = game;
+    }
+//    @Override
+//    public void setMacroState(Game game) {
+//        macroState = game;
+//    }
+//    @Override
+//    public void setMacroPlayerId(UUID id) {
+//        macroPlayerId = id;
+//    }
+//    @Override
+//    public void setLastAction(Ability ability) {
+//        lastAction = ability;
+//    }
     @Override
     public boolean isSimulation() {
         return simulation;
@@ -255,6 +303,7 @@ public abstract class GameImpl implements Game {
     @Override
     public Game createSimulationForAI() {
         Game res = this.copy();
+        ((GameImpl) res).lastPriority = lastPriority;
         ((GameImpl) res).simulation = true;
         ((GameImpl) res).aiGame = true;
         return res;
@@ -948,7 +997,14 @@ public abstract class GameImpl implements Game {
         }
         return savedStates.size();
     }
-
+    // In mage.game.GameImpl.java
+    @Override
+    public void addCard(UUID cardId, Card card) {
+        // This public method allows our reconstructor to populate the master card map.
+        if (cardId != null && card != null) {
+            this.gameCards.put(cardId, card);
+        }
+    }
     /**
      * Warning, for inner usage only, use player.restoreState as much as possible instead
      *
@@ -1459,13 +1515,13 @@ public abstract class GameImpl implements Game {
             // This is not a real emblem. Just a fake source for the
             // inherent trigger ability related to Rad counters
             // Faking a source just to display something on the stack ability.
-            state.addHelperEmblem(new RadiationEmblem(), playerId);
+            //state.addHelperEmblem(new RadiationEmblem(), playerId);
         }
 
         // global card hints for better UX
         for (UUID playerId : state.getPlayerList(startingPlayerId)) {
-            state.addHelperEmblem(new XmageHelperEmblem().withCardHint("storm counter", StormAbility.getHint()), playerId);
-            state.addHelperEmblem(new XmageHelperEmblem().withCardHint("day or night", DayNightHint.instance), playerId);
+            //state.addHelperEmblem(new XmageHelperEmblem().withCardHint("storm counter", StormAbility.getHint()), playerId);
+            //state.addHelperEmblem(new XmageHelperEmblem().withCardHint("day or night", DayNightHint.instance), playerId);
         }
     }
 
@@ -1713,8 +1769,11 @@ public abstract class GameImpl implements Game {
                                 if (isPaused() || checkIfGameIsOver()) {
                                     return;
                                 }
+                                lastPriority = this.copy();
+                                lastPriorityPlayerId = player.getId();
                                 // resetPassed should be called if player performs any action
                                 if (player.priority(this)) {
+                                    assert (player.getLastActivated()!= null);
                                     if (executingRollback()) {
                                         return;
                                     }
diff --git a/Mage/src/main/java/mage/players/Player.java b/Mage/src/main/java/mage/players/Player.java
index aed45f3a4a..7b4c2b826d 100644
--- a/Mage/src/main/java/mage/players/Player.java
+++ b/Mage/src/main/java/mage/players/Player.java
@@ -70,7 +70,8 @@ public interface Player extends MageItem, Copyable<Player> {
     enum PayLifeCostLevel {
         allAbilities, nonSpellnonActivatedAbilities, onlyManaAbilities, none
     }
-
+    Ability getLastActivated();
+    void setLastActivated(Ability a);
     /**
      * Current player is real life player (human). Try to use in GUI and network engine only.
      * <p>
diff --git a/Mage/src/main/java/mage/players/PlayerImpl.java b/Mage/src/main/java/mage/players/PlayerImpl.java
index 432b0917f0..2032ff68aa 100644
--- a/Mage/src/main/java/mage/players/PlayerImpl.java
+++ b/Mage/src/main/java/mage/players/PlayerImpl.java
@@ -83,6 +83,7 @@ public abstract class PlayerImpl implements Player, Serializable {
     static final Map<PhaseStep, Step.StepPart> SILENT_PHASES_STEPS = ImmutableMap.<PhaseStep, Step.StepPart>builder().
             put(PhaseStep.DECLARE_ATTACKERS, Step.StepPart.PRE).build();
 
+    private Ability lastActivated;
     /**
      * Used to cancel waiting requests send to the player
      */
@@ -200,7 +201,7 @@ public abstract class PlayerImpl implements Player, Serializable {
     protected final List<List<Mana>> availableTriggeredManaList = new ArrayList<>();
 
     protected PlayerImpl(String name, RangeOfInfluence range) {
-        this(UUID.randomUUID());
+        this(UUID.nameUUIDFromBytes(name.getBytes()));
         this.name = name;
         this.range = range;
         hand = new CardsImpl();
@@ -218,6 +219,9 @@ public abstract class PlayerImpl implements Player, Serializable {
     }
 
     protected PlayerImpl(final PlayerImpl player) {
+
+        this.lastActivated = player.lastActivated;
+
         this.abort = player.abort;
         this.playerId = player.playerId;
 
@@ -301,7 +305,12 @@ public abstract class PlayerImpl implements Player, Serializable {
         this.phyrexianColors = player.getPhyrexianColors() != null ? player.phyrexianColors.copy() : null;
         this.designations = CardUtil.deepCopyObject(player.designations);
     }
-
+    public Ability getLastActivated() {
+        return lastActivated;
+    }
+    public void setLastActivated(Ability a) {
+        lastActivated = a;
+    }
     /**
      * Restore on rollback
      *
@@ -312,7 +321,7 @@ public abstract class PlayerImpl implements Player, Serializable {
         if (!(player instanceof PlayerImpl)) {
             throw new IllegalArgumentException("Wrong code usage: can't restore from player class " + player.getClass().getName());
         }
-
+        this.lastActivated = player.getLastActivated();
         this.name = player.getName();
         this.human = player.isHuman();
         this.life = player.getLife();
@@ -1597,8 +1606,11 @@ public abstract class PlayerImpl implements Player, Serializable {
     @Override
     public boolean activateAbility(ActivatedAbility ability, Game game) {
         if (ability == null) {
+            logger.error("activating null ability");
             return false;
         }
+        //logger.info("last activated: " + (lastActivated == null ? "null" : this.lastActivated.toString()));
+        lastActivated = ability.copy();
         boolean result;
         if (ability instanceof PassAbility) {
             pass(game);
diff --git a/Mage/src/main/java/mage/target/TargetPermanent.java b/Mage/src/main/java/mage/target/TargetPermanent.java
index c97ea339e0..aae13f22fe 100644
--- a/Mage/src/main/java/mage/target/TargetPermanent.java
+++ b/Mage/src/main/java/mage/target/TargetPermanent.java
@@ -51,7 +51,7 @@ public class TargetPermanent extends TargetObject {
 
     @Override
     public boolean canTarget(UUID id, Ability source, Game game) {
-        return canTarget(source.getControllerId(), id, source, game);
+        return canTarget(source==null ? id : source.getControllerId(), id, source, game);
     }
 
     @Override
diff --git a/Mage/src/main/java/mage/target/common/TargetDiscard.java b/Mage/src/main/java/mage/target/common/TargetDiscard.java
index 854230c9ea..f2b436a0d0 100644
--- a/Mage/src/main/java/mage/target/common/TargetDiscard.java
+++ b/Mage/src/main/java/mage/target/common/TargetDiscard.java
@@ -47,7 +47,7 @@ public class TargetDiscard extends TargetCard {
     @Override
     public boolean canTarget(UUID id, Ability source, Game game) {
         Card card = game.getPlayer(playerId).getHand().get(id, game);
-        return filter.match(card, source.getControllerId(), game);
+        return filter.match(card, source == null ? playerId : source.getControllerId(), game);
     }
 
     @Override
diff --git a/my_changes.diff b/my_changes.diff
new file mode 100644
index 0000000000..8452a7a845
--- /dev/null
+++ b/my_changes.diff
@@ -0,0 +1,391 @@
+diff --git a/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/Features.java b/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/Features.java
+index 3cc053f64a..59dc18cc24 100644
+--- a/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/Features.java
++++ b/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/Features.java
+@@ -4,20 +4,22 @@ import java.io.*;
+ import java.nio.file.Files;
+ import java.nio.file.Paths;
+ import java.util.*;
++import java.util.concurrent.atomic.AtomicInteger;
+ 
+ /**
+- *this hierarchical structure represents the mapping of every possible relevant feature encountered from a game state to
+- * an index on a 200000 dimension binary vector. the reduced form of this vector (~6000) will be used as input for both a policy and
++ * This hierarchical structure represents the mapping of every possible relevant feature encountered from a game state to
++ * an index on a 200000 dimension binary vector. The reduced form of this vector (~5000) will be used as input for both a policy and
+  * value neural network. To see how game features are mapped look at StateEncoder.java this data structure only handles and stores the
+- * mappings
++ * mappings.
++ *
+  * @author willwroble
+  */
+-public class Features  implements Serializable {
+-    private static final long serialVersionUID = 1L;
+-    public int globalIndexCount;
+-    Set<Integer> ignoreList;
+-    Map<Integer, Integer> rawToReduced;
+-    int version;
++public class Features implements Serializable {
++    private static final long serialVersionUID = 2L; // Version updated for the structural change
++    public AtomicInteger localIndexCount; // a mutable, thread-safe counter
++    public int previousLocalIndexCount = 0;
++    public Set<Integer> ignoreList;
++    public int version = 0;
+ 
+     private final Map<String, Map<Integer, Features>> subFeatures;
+     private final Map<String, Map<Integer, Integer>> features;
+@@ -28,12 +30,13 @@ public class Features  implements Serializable {
+     private final Set<Features> categories; //resets every state represents temporary category features fall under
+     public boolean passToParent = true;
+ 
+-    private StateEncoder encoder;
++    private transient StateEncoder encoder;
+ 
+     private String featureName;
+-    private Features parent;
++    public Features parent;
+     public static boolean printOldFeatures = true;
+     public static boolean printNewFeatures = true;
++
+     public Features() {
+         //constructor
+         subFeatures = new HashMap<>();
+@@ -43,58 +46,82 @@ public class Features  implements Serializable {
+         numericOccurrences = new HashMap<>();
+         categoriesForChildren = new HashMap<>();
+         categories = new HashSet<>();
++        ignoreList = new HashSet<>();
++        localIndexCount = new AtomicInteger(0);
+         parent = null;
+         featureName = "root";
+     }
++
+     public Features(Features p, String name) {
+         this();
++        // Manually set fields instead of calling this(), to avoid creating a new AtomicInteger
+         parent = p;
+         featureName = name;
+         encoder = p.encoder;
++        localIndexCount = p.localIndexCount;
++    }
++
++    public Features(String name, StateEncoder e, AtomicInteger i) {
++        this();
++        featureName = name;
++        encoder = e;
++        localIndexCount = i;
+     }
+ 
+     public void setEncoder(StateEncoder encoder) {
+         this.encoder = encoder;
++        for (String n : subFeatures.keySet()) {
++            for (Integer i : subFeatures.get(n).keySet()) {
++                subFeatures.get(n).get(i).setEncoder(encoder);
++            }
++        }
++        for (String n : categoriesForChildren.keySet()) {
++            categoriesForChildren.get(n).setEncoder(encoder);
++        }
+     }
+ 
+     public Features getCategory(String name) {
+-
+-        if(categoriesForChildren.containsKey(name)) {//already contains category
++        if (categoriesForChildren.containsKey(name)) { //already contains category
+             return categoriesForChildren.get(name);
+-
+-        } else{//completely new
++        } else { //completely new
+             Features parentCategory = null;
+-            if(parent != null) parentCategory = parent.getCategory(name); //categories can have a parent
+-            Features newCat = new Features(parentCategory, name + "_" + featureName);
++            if (parent != null) parentCategory = parent.getCategory(name); //categories can have a parent
++            Features newCat;
++            if (parentCategory != null) {
++                newCat = new Features(parentCategory, name + "_" + featureName);
++            } else {
++                newCat = new Features(name + "_" + featureName, encoder, localIndexCount);
++            }
+             categoriesForChildren.put(name, newCat);
+             return newCat;
+         }
+-
+     }
+ 
+     /**
+      * gets subfeatures at name or creates them if they dont exist
++     *
+      * @param name
+      * @return subfeature at name (never returns null)
+      */
+     public Features getSubFeatures(String name) {
+         return getSubFeatures(name, true);
+     }
++
+     public Features getSubFeatures(String name, boolean passToParent) {
+         //added as normal binary feature
+         addFeature(name);
+ 
+         int n = occurrences.get(name);
+-        if(subFeatures.containsKey(name)) {//already contains feature
+-            if(subFeatures.get(name).containsKey(n)) {//contains count too
++        if (subFeatures.containsKey(name)) { //already contains feature
++            if (subFeatures.get(name).containsKey(n)) { //contains count too
+                 return subFeatures.get(name).get(n);
+-            } else {//new count
++            } else { //new count
+                 Map<Integer, Features> map = subFeatures.get(name);
+                 Features newSub = new Features(this, name + "_" + Integer.toString(n));
+                 map.put(n, newSub);
+                 return newSub;
+             }
+-        } else{//completely new
++        } else { //completely new
+             Map<Integer, Features> newMap = new HashMap<>();
+             Features newSub = new Features(this, name + "_1");
+             newMap.put(1, newSub);
+@@ -103,6 +130,7 @@ public class Features  implements Serializable {
+             return newSub;
+         }
+     }
++
+     /**
+      * similar to a subfeature a category will pool features within itself. however
+      * unlike subfeatures a feature can inherit multiple categories(ie card type and color).
+@@ -110,6 +138,7 @@ public class Features  implements Serializable {
+      * this function creates/finds the category with the given name and adds it as a
+      * category for this feature to pass up to, similar to the parent
+      * Categories should always be added before features
++     *
+      * @param name
+      */
+     public void addCategory(String name) {
+@@ -117,94 +146,105 @@ public class Features  implements Serializable {
+         Features categoryFeature = parent.getCategory(name);
+         categories.add(categoryFeature);
+     }
++
+     public void addFeature(String name) {
+         addFeature(name, true);
+     }
++
+     public void addFeature(String name, boolean callParent) {
+         //usually add feature to parent/categories
+-        if(parent != null && callParent && passToParent) {
++        if (parent != null && callParent && passToParent) {
+             parent.addFeature(name);
+-            for(Features c : categories) {
++            for (Features c : categories) {
+                 c.addFeature(name);
+             }
+         }
+ 
+-        if(features.containsKey(name)) {//has feature
+-            int count = occurrences.get(name)+1;
++        if (features.containsKey(name)) { //has feature
++            int count = occurrences.get(name) + 1;
+             occurrences.put(name, count);
+-            if(features.get(name).containsKey(count)) {//already contains feature at this count
+-                if(printOldFeatures) System.out.printf("Index %d is already reserved for feature %s at %d times in %s\n", features.get(name).get(count), name, count, featureName);
+-            } else {//contains feature but different count
+-                features.get(name).put(count, StateEncoder.indexCount++);
+-                if(printNewFeatures) System.out.printf("Feature %s exists but has not occurred %d times, reserving index %d for the %d occurrence of this feature in %s\n",
+-                        name, count, StateEncoder.indexCount-1, count, featureName);
++            if (features.get(name).containsKey(count)) { //already contains feature at this count
++                if (printOldFeatures)
++                    System.out.printf("Index %d is already reserved for feature %s at %d times in %s\n", features.get(name).get(count), name, count, featureName);
++            } else { //contains feature but different count
++                features.get(name).put(count, localIndexCount.getAndIncrement()); //  FIXED: Use atomic increment
++                if (printNewFeatures)
++                    System.out.printf("Feature %s exists but has not occurred %d times, reserving index %d for the %d occurrence of this feature in %s\n",
++                            name, count, localIndexCount.get() - 1, count, featureName);
+             }
+-        } else {//completely new feature
++        } else { //completely new feature
+             occurrences.put(name, 1);
+             Map<Integer, Integer> n = new HashMap<>();
+-            n.put(1, StateEncoder.indexCount++);
++            n.put(1, localIndexCount.getAndIncrement());
+             features.put(name, n);
+-            if(printNewFeatures) System.out.printf("New feature %s discovered in %s, reserving index %d for this feature\n", name, featureName, n.get(1));
++            if (printNewFeatures)
++                System.out.printf("New feature %s discovered in %s, reserving index %d for this feature\n", name, featureName, n.get(1));
+         }
+-        StateEncoder.featureVector.add(features.get(name).get(occurrences.get(name)));
++        encoder.featureVector.add(features.get(name).get(occurrences.get(name)));
+     }
++
+     public void addNumericFeature(String name, int num) {
+         addNumericFeature(name, num, true);
+     }
++
+     public void addNumericFeature(String name, int num, boolean callParent) {
+         //usually add feature to parent/categories
+-        if(parent != null && callParent && passToParent) {
++        if (parent != null && callParent && passToParent) {
+             parent.addNumericFeature(name, num);
+         }
+ 
+         //also adds copy to number right below this one which will recursively increment the occurrences of each lesser feature
+         //Integer nextHighest = numericFeatures.get(name).floorKey(num-1);
+-        if(num > 0) addNumericFeature(name, num-1, false);
++        if (num > 0) addNumericFeature(name, num - 1, false);
+ 
+-        if(numericFeatures.containsKey(name)) {
+-
+-            if(numericFeatures.get(name).containsKey(num)) {
+-                int count = numericOccurrences.get(name).get(num)+1;
++        if (numericFeatures.containsKey(name)) {
++            if (numericFeatures.get(name).containsKey(num)) {
++                int count = numericOccurrences.get(name).get(num) + 1;
+                 numericOccurrences.get(name).put(num, count);
+ 
+-                if(numericFeatures.get(name).get(num).containsKey(count)) {//already contains feature at this count
+-                    if(printOldFeatures) System.out.printf("Index %d is already reserved for numeric feature %s with %d at %d times in %s\n", numericFeatures.get(name).get(num).get(count), name, num, count, featureName);
+-                } else {//contains feature and num but different count
+-                    numericFeatures.get(name).get(num).put(count, StateEncoder.indexCount++);
+-                    if(printNewFeatures) System.out.printf("Numeric feature %s with %d exists but has not occurred %d times, reserving index %d for the %d occurrence of this feature in %s\n",
+-                            name, num, count, StateEncoder.indexCount-1, count, featureName);
++                if (numericFeatures.get(name).get(num).containsKey(count)) { //already contains feature at this count
++                    if (printOldFeatures)
++                        System.out.printf("Index %d is already reserved for numeric feature %s with %d at %d times in %s\n", numericFeatures.get(name).get(num).get(count), name, num, count, featureName);
++                } else { //contains feature and num but different count
++                    numericFeatures.get(name).get(num).put(count, localIndexCount.getAndIncrement());
++                    if (printNewFeatures)
++                        System.out.printf("Numeric feature %s with %d exists but has not occurred %d times, reserving index %d for the %d occurrence of this feature in %s\n",
++                                name, num, count, localIndexCount.get() - 1, count, featureName);
+                 }
+             } else { //contains category but not this number
+                 Map<Integer, Map<Integer, Integer>> map = numericFeatures.get(name);
+                 Map<Integer, Integer> subMap = new HashMap<>();
+-                subMap.put(1, StateEncoder.indexCount++);
++                subMap.put(1, localIndexCount.getAndIncrement());
+                 map.put(num, subMap);
+                 numericOccurrences.get(name).put(num, 1);
+-                if(printNewFeatures) System.out.printf("Numeric feature %s exists but has not occurred with %d, reserving index %d for this feature at %d in %s\n",
+-                        name, num, StateEncoder.indexCount-1, num, featureName);
++                if (printNewFeatures)
++                    System.out.printf("Numeric feature %s exists but has not occurred with %d, reserving index %d for this feature at %d in %s\n",
++                            name, num, localIndexCount.get() - 1, num, featureName);
+             }
+-        } else {//completely new feature category
++        } else { //completely new feature category
+             TreeMap<Integer, Map<Integer, Integer>> newMap = new TreeMap<>();
+             Map<Integer, Integer> subMap = new HashMap<>();
+-            subMap.put(1, StateEncoder.indexCount++);
++            subMap.put(1, localIndexCount.getAndIncrement());
+             newMap.put(num, subMap);
+             numericFeatures.put(name, newMap);
+             TreeMap<Integer, Integer> newTreeMap = new TreeMap<>();
+             newTreeMap.put(num, 1);
+             numericOccurrences.put(name, newTreeMap);
+-            if(printNewFeatures) System.out.printf("New numeric feature %s discovered with %d in %s, reserving index %d for this feature at %d\n", name,
+-                    num, featureName, StateEncoder.indexCount-1, num);
++            if (printNewFeatures)
++                System.out.printf("New numeric feature %s discovered with %d in %s, reserving index %d for this feature at %d\n", name,
++                        num, featureName, localIndexCount.get() - 1, num);
+         }
+-        StateEncoder.featureVector.add(numericFeatures.get(name).get(num).get(numericOccurrences.get(name).get(num)));
++        encoder.featureVector.add(numericFeatures.get(name).get(num).get(numericOccurrences.get(name).get(num)));
+     }
++
+     public void stateRefresh() {
+         categories.clear();
+         occurrences.replaceAll((k, v) -> 0);
+-        for(String c : numericOccurrences.keySet()) {
++        for (String c : numericOccurrences.keySet()) {
+             numericOccurrences.get(c).replaceAll((k, v) -> 0);
+         }
+-        for(String n : subFeatures.keySet()) {
+-            for(int i : subFeatures.get(n).keySet()) {
++        for (String n : subFeatures.keySet()) {
++            for (int i : subFeatures.get(n).keySet()) {
+                 subFeatures.get(n).get(i).stateRefresh();
+             }
+         }
+@@ -213,6 +253,78 @@ public class Features  implements Serializable {
+         }
+     }
+ 
++    /**
++     * always discard f after merging
++     *
++     * @param f object to merge with
++     */
++    public synchronized void merge(Features f) {
++        if (this == f) return;
++
++        // Normal features
++        for (String n : f.features.keySet()) {
++            Map<Integer, Integer> thisOccurrenceMap = this.features.computeIfAbsent(n, k -> new HashMap<>());
++            this.occurrences.putIfAbsent(n, 0);
++            for (int i : f.features.get(n).keySet()) {
++                if (!thisOccurrenceMap.containsKey(i)) {
++                    thisOccurrenceMap.put(i, this.localIndexCount.getAndIncrement());
++                }
++            }
++        }
++
++        // Numeric features
++        for (String n : f.numericFeatures.keySet()) {
++            TreeMap<Integer, Map<Integer, Integer>> thisNumericMap = this.numericFeatures.computeIfAbsent(n, k -> new TreeMap<>());
++            this.numericOccurrences.putIfAbsent(n, new TreeMap<>());
++            for (int num : f.numericFeatures.get(n).keySet()) {
++                Map<Integer, Integer> thisOccurrenceMap = thisNumericMap.computeIfAbsent(num, k -> new HashMap<>());
++                this.numericOccurrences.get(n).putIfAbsent(num, 0);
++                for (int i  : f.numericFeatures.get(n).get(num).keySet()) {
++                    if (!thisOccurrenceMap.containsKey(i)) {
++                        thisOccurrenceMap.put(i, this.localIndexCount.getAndIncrement());
++                    }
++                }
++            }
++        }
++        //subfeatures
++        for (String n : f.subFeatures.keySet()) {
++            Map<Integer, Features> thisSubMap = this.subFeatures.computeIfAbsent(n, k -> new HashMap<>());
++            for (int i : f.subFeatures.get(n).keySet()) {
++                Features thisSubFeature = thisSubMap.computeIfAbsent(i, k -> new Features(this, n + "_" + i));
++                thisSubFeature.merge(f.subFeatures.get(n).get(i));
++            }
++        }
++        //category labels
++        for (String n : f.categoriesForChildren.keySet()) {
++            if (!this.categoriesForChildren.containsKey(n)) {
++                this.categoriesForChildren.put(n, this.getCategory(n));
++            }
++            this.categoriesForChildren.get(n).merge(f.categoriesForChildren.get(n));
++        }
++    }
++    /**
++     * Creates a synchronized, deep copy of this Features object.
++     * By being synchronized, it ensures we get a clean snapshot and never
++     * copy the object while another thread is in the middle of merging.
++     * @return A new, completely independent deep copy of this object.
++     */
++    public synchronized Features createDeepCopy() {
++        try {
++            ByteArrayOutputStream byteOutput = new ByteArrayOutputStream();
++            ObjectOutputStream objectOutput = new ObjectOutputStream(byteOutput);
++            objectOutput.writeObject(this);
++            objectOutput.close();
++
++            ByteArrayInputStream byteInput = new ByteArrayInputStream(byteOutput.toByteArray());
++            ObjectInputStream objectInput = new ObjectInputStream(byteInput);
++            Features copy = (Features) objectInput.readObject();
++            objectInput.close();
++
++            return copy;
++        } catch (IOException | ClassNotFoundException e) {
++            throw new RuntimeException("Failed to create a deep copy of the Features object.", e);
++        }
++    }
+     // Helper method to persist the Features mapping to a file
+     public void saveMapping(String filename) throws IOException {
+         try (ObjectOutputStream oos = new ObjectOutputStream(Files.newOutputStream(Paths.get(filename)))) {
+@@ -226,4 +338,4 @@ public class Features  implements Serializable {
+             return (Features) ois.readObject();
+         }
+     }
+-}
++}
+\ No newline at end of file
