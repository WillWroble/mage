diff --git a/.gitignore b/.gitignore
index d35b250f77..e525ae285b 100644
--- a/.gitignore
+++ b/.gitignore
@@ -61,3 +61,9 @@ Utils/*implemented.txt
 # build tools
 mage-bundle.zip
 .env
+*.ser
+*.bin
+*.bin
+*.onnx
+Mage.Tests/training.bin
+Mage.Tests/testing.bin
diff --git a/Mage.Server.Plugins/Mage.Player.AI.MA/src/mage/player/ai/ComputerPlayer6.java b/Mage.Server.Plugins/Mage.Player.AI.MA/src/mage/player/ai/ComputerPlayer6.java
index d22e381cc8..98d36984fd 100644
--- a/Mage.Server.Plugins/Mage.Player.AI.MA/src/mage/player/ai/ComputerPlayer6.java
+++ b/Mage.Server.Plugins/Mage.Player.AI.MA/src/mage/player/ai/ComputerPlayer6.java
@@ -431,6 +431,7 @@ public class ComputerPlayer6 extends ComputerPlayer {
      */
     protected Integer addActionsTimed() {
         // run new game simulation in parallel thread
+        //assert (threadPoolSimulations != null);
         FutureTask<Integer> task = new FutureTask<>(() -> addActions(root, maxDepth, Integer.MIN_VALUE, Integer.MAX_VALUE));
         threadPoolSimulations.execute(task);
         try {
diff --git a/Mage.Server.Plugins/Mage.Player.AI.MA/src/mage/player/ai/GameStateEvaluator2.java b/Mage.Server.Plugins/Mage.Player.AI.MA/src/mage/player/ai/GameStateEvaluator2.java
index 7adc1cb429..3ec0de6bf9 100644
--- a/Mage.Server.Plugins/Mage.Player.AI.MA/src/mage/player/ai/GameStateEvaluator2.java
+++ b/Mage.Server.Plugins/Mage.Player.AI.MA/src/mage/player/ai/GameStateEvaluator2.java
@@ -154,6 +154,12 @@ public final class GameStateEvaluator2 {
                         + ":" + GameStateEvaluator2.evaluatePermanent(p, game, true))
                 .collect(Collectors.joining("; "));
         sb.append("-> Permanents: [").append(ownPermanentsInfo).append("]");
+        // graveyard
+        sb.setLength(0);
+        String ownGraveInfo = player.getGraveyard().stream()
+                .map(id -> game.getObject(id).getName())
+                .collect(Collectors.joining("; "));
+        sb.append("-> Graveyard: [").append(ownGraveInfo).append("]");
         logger.info(sb.toString());
     }
     public static int evaluatePermanent(Permanent permanent, Game game, boolean useCombatPermanentScore) {
diff --git a/Mage.Server.Plugins/Mage.Player.AI.RL/LegacyCode/DoublePolarityFeatures b/Mage.Server.Plugins/Mage.Player.AI.RL/LegacyCode/DoublePolarityFeatures
deleted file mode 100644
index 28e842459e..0000000000
--- a/Mage.Server.Plugins/Mage.Player.AI.RL/LegacyCode/DoublePolarityFeatures
+++ /dev/null
@@ -1,227 +0,0 @@
-package mage.player.ai;
-
-import java.util.*;
-
-
-public class Features {
-    private Map<String, Map<Integer, Features>> subFeatures;
-    private Map<String, Map<Integer, Integer>> features;
-    private Map<Boolean,Map<String, TreeMap<Integer, Map<Integer, Integer>>>> numericFeatures; //polarity->name->value->occurrences->index
-    private Map<String, Integer> occurances;
-    private Map<Boolean,Map<String, TreeMap<Integer, Integer>>> numericOccurences;
-    private Map<String, Features> categoriesForChildren; //isnt reset between states represent all possible categories for children
-    public Set<Features> categories; //resets every state represents temporary category features fall under
-
-    public String featureName;
-    public Features parent;
-    public static boolean printOldFeatures = true;
-    public static boolean printNewFeatures = true;
-    public Features() {
-        //constructor
-        subFeatures = new HashMap<>();
-        features = new HashMap<>();
-        occurances = new HashMap<>();
-        numericFeatures = new HashMap<>();
-        Map<String, TreeMap<Integer, Map<Integer, Integer>>> m1 = new HashMap<>();
-        Map<String, TreeMap<Integer, Map<Integer, Integer>>> m2 = new HashMap<>();
-        numericFeatures.put(false, m1); numericFeatures.put(true, m2);
-        numericOccurences = new HashMap<>();
-        Map<String, TreeMap<Integer, Integer>> m3 = new HashMap<>();
-        Map<String, TreeMap<Integer, Integer>> m4 = new HashMap<>();
-        numericOccurences.put(false, m3); numericOccurences.put(true, m4);
-        categoriesForChildren = new HashMap<>();
-        categories = new HashSet<>();
-        parent = null;
-        featureName = "root";
-    }
-    public Features(Features p, String name) {
-        this();
-        parent = p;
-        featureName = name;
-    }
-
-
-    public Features getCategory(String name) {
-
-        if(categoriesForChildren.containsKey(name)) {//already contains category
-            return categoriesForChildren.get(name);
-
-        } else{//completely new
-            Features parentCategory = null;
-            if(parent != null) parentCategory = parent.getCategory(name); //categories can have a parent
-            Features newCat = new Features(parentCategory, name+"_"+featureName);
-            categoriesForChildren.put(name, newCat);
-            return newCat;
-        }
-
-    }
-
-    /**
-     * gets subfeatures at given name or creates them if they dont exist
-     * @param name
-     * @return subfeature at name (never returns null)
-     */
-    public Features getSubFeatures(String name) {
-        //first add as a normal binary feature
-        addFeature(name);
-
-        int n = occurances.get(name);
-        if(subFeatures.containsKey(name)) {//already contains feature
-            if(subFeatures.get(name).containsKey(n)) {//conatins count too
-                return subFeatures.get(name).get(n);
-            } else {//new count
-                Map<Integer, Features> map = subFeatures.get(name);
-                Features newSub = new Features(this, name + "_" + Integer.toString(n));
-                map.put(n, newSub);
-                return newSub;
-            }
-        } else{//completely new
-            Map<Integer, Features> newMap = new HashMap<>();
-            Features newSub = new Features(this, name + "_1");
-            newMap.put(1, newSub);
-            subFeatures.put(name, newMap);
-            return newSub;
-        }
-    }
-    /**
-     * similar to a subfeature a category will pool features within itself. however
-     * unlike subfeatures a feature can inherit multiple categories(ie card type and color).
-     * you can think of subfeatures as abstract classes and categories as interfaces
-     * this function creates/finds the category with the given name and adds it as a
-     * category for this feature to pass up to, similar to the parent
-     * Categories should always be added before features
-     * @param name
-     */
-    public void addCategory(String name) {
-        addFeature(name); //first add as feature since every category is also a feature
-        Features categoryFeature = parent.getCategory(name);
-        categories.add(categoryFeature);
-    }
-    public void addFeature(String name) {
-        addFeature(name, true);
-    }
-    public void addFeature(String name, boolean callParent) {
-        //usually add feature to parent/categories
-        if(parent != null && callParent) {
-            parent.addFeature(name);
-            for(Features c : categories) {
-                c.addFeature(name);
-            }
-        }
-
-        if(features.containsKey(name)) {//has feature
-            int count = occurances.get(name)+1;
-            occurances.put(name, count);
-            if(features.get(name).containsKey(count)) {//already contains feature at this count
-                if(StateEncoder.ignoreList.contains(features.get(name).get(count))) return;
-                if(printOldFeatures) System.out.printf("Index %d is already reserved for feature %s at %d times in %s\n", features.get(name).get(count), name, count, featureName);
-            } else {//contains feature but different count
-                features.get(name).put(count, StateEncoder.indexCount++);
-                if(printNewFeatures) System.out.printf("Feature %s exists but has not occurred %d times, reserving index %d for the %d occurrence of this feature in %s\n",
-                        name, count, StateEncoder.indexCount-1, count, featureName);
-            }
-        } else {//completely new feature
-            occurances.put(name, 1);
-            Map<Integer, Integer> n = new HashMap<>();
-            n.put(1, StateEncoder.indexCount++);
-            features.put(name, n);
-            if(printNewFeatures) System.out.printf("New feature %s discovered in %s, reserving index %d for this feature\n", name, featureName, n.get(1));
-        }
-        StateEncoder.featureVector[features.get(name).get(occurances.get(name))] = true;
-    }
-    public void addNumericFeature(String name, int num) {
-        addNumericFeature(name, num, true, true, true);
-    }
-    public void addNumericFeature(String name, int num, boolean callParent, boolean atLeast, boolean atMost) {
-        //usually add feature to parent/categories
-        if (parent != null && callParent) {
-            parent.addNumericFeature(name, num, true, atLeast, atMost);
-            //keep track of numerical sum for parents
-            for (int j = 0; j < num; j++) {
-                parent.addFeature(name + "_SUM", false);
-            }
-            for (Features c : categories) {
-                c.addFeature(name);
-                //keep track of numerical sum for categories
-                for (int j = 0; j < num; j++) {
-                    c.addFeature(name + "_SUM", false);
-                }
-            }
-        }
-        //numeric features are stored for both greater than and less than thresholds
-        for(int i = 0; i < 2; i++) {
-            boolean polarity = (i==0); //positive polarity = true = at least
-            if(!((atMost && !polarity) || (atLeast && polarity))) {
-                continue;
-            }
-            //also adds copy to number right below for positive polarity features this one which will recursively increment the occurrences of each lesser feature (at least behavior)
-            if (polarity) {
-                //Integer nextLowest = numericFeatures.get(true).get(name).floorKey(num - 1);
-                int lowest = 0;//numericFeatures.get(true).get(name).firstKey();
-                if (num > lowest) addNumericFeature(name, num-1, false, true, false);
-            }
-            if (numericFeatures.get(polarity).containsKey(name)) {
-
-                //also adds copy to number right above for negative polarity features this one which will recursively increment the occurrences of each greater feature (at most behavior)
-                if (!polarity) {
-                    //Integer nextHighest = numericFeatures.get(false).get(name).ceilingKey(num + 1);
-                    int highest = numericFeatures.get(false).get(name).lastKey();
-                    if (num < highest) addNumericFeature(name, num+1, false, false, true);
-                }
-                if (numericFeatures.get(polarity).get(name).containsKey(num)) {
-                    int count = numericOccurences.get(polarity).get(name).get(num) + 1;
-                    numericOccurences.get(polarity).get(name).put(num, count);
-
-                    if (numericFeatures.get(polarity).get(name).get(num).containsKey(count)) {//already contains feature at this count
-                        if(StateEncoder.ignoreList.contains(numericFeatures.get(polarity).get(name).get(num).get(count))) return; //don't acknowledge if on ignore list
-
-                        if (printOldFeatures)
-                            System.out.printf("Index %d is already reserved for numeric feature %s with %s %d at %d times in %s\n", numericFeatures.get(polarity).get(name).get(num).get(count), name, polarity ? "at least" : "at most", num, count, featureName);
-                    } else {//contains feature and num but different count
-                        numericFeatures.get(polarity).get(name).get(num).put(count, StateEncoder.indexCount++);
-                        if(printNewFeatures) System.out.printf("Numeric feature %s with %s %d exists but has not occurred %d times, reserving index %d for the %d occurrence of this feature in %s\n",
-                                name, polarity ? "at least" : "at most", num, count, StateEncoder.indexCount - 1, count, featureName);
-                    }
-                } else { //contains category but not this number
-                    Map<Integer, Map<Integer, Integer>> map = numericFeatures.get(polarity).get(name);
-                    Map<Integer, Integer> subMap = new HashMap<>();
-                    subMap.put(1, StateEncoder.indexCount++);
-                    map.put(num, subMap);
-                    numericOccurences.get(polarity).get(name).put(num, 1);
-                    if(printNewFeatures) System.out.printf("Numeric feature %s exists but has not occurred with %s %d, reserving index %d for this feature at %d in %s\n",
-                            name, polarity ? "at least" : "at most", num, StateEncoder.indexCount - 1, num, featureName);
-                }
-            } else {//completely new feature category
-                TreeMap<Integer, Map<Integer, Integer>> newMap = new TreeMap<>();
-                Map<Integer, Integer> subMap = new HashMap<>();
-                subMap.put(1, StateEncoder.indexCount++);
-                newMap.put(num, subMap);
-                numericFeatures.get(polarity).put(name, newMap);
-                TreeMap<Integer, Integer> newTreeMap = new TreeMap<>();
-                newTreeMap.put(num, 1);
-                numericOccurences.get(polarity).put(name, newTreeMap);
-                if(printNewFeatures) System.out.printf("New numeric feature %s discovered with %s %d in %s, reserving index %d for this feature at %d\n", name,
-                        polarity ? "at least" : "at most", num, featureName, StateEncoder.indexCount - 1, num);
-            }
-            StateEncoder.featureVector[numericFeatures.get(polarity).get(name).get(num).get(numericOccurences.get(polarity).get(name).get(num))] = true;
-        }
-    }
-    public void stateRefresh() {
-        categories.clear();
-        occurances.replaceAll((k, v) -> 0);
-        for(int i = 0; i < 2; i++) {
-            boolean polarity = (i==0);
-            for (String c : numericOccurences.get(polarity).keySet()) {
-                numericOccurences.get(polarity).get(c).replaceAll((k, v) -> 0);
-            }
-        }
-        for(String n : subFeatures.keySet()) {
-            for(int i : subFeatures.get(n).keySet()) {
-                subFeatures.get(n).get(i).stateRefresh();
-            }
-        }
-        for (String n : categoriesForChildren.keySet()) {
-            categoriesForChildren.get(n).stateRefresh();
-        }
-    }
-}
diff --git a/Mage.Server.Plugins/Mage.Player.AI.RL/pom.xml b/Mage.Server.Plugins/Mage.Player.AI.RL/pom.xml
index 42ca950364..caaa9161cb 100644
--- a/Mage.Server.Plugins/Mage.Player.AI.RL/pom.xml
+++ b/Mage.Server.Plugins/Mage.Player.AI.RL/pom.xml
@@ -36,6 +36,11 @@
             <version>1.4.56</version>
             <scope>compile</scope>
         </dependency>
+        <dependency>
+            <groupId>com.microsoft.onnxruntime</groupId>
+            <artifactId>onnxruntime</artifactId>
+            <version>1.18.0</version>
+        </dependency>
     </dependencies>
 
     <build>
diff --git a/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/ActionEncoder.java b/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/ActionEncoder.java
deleted file mode 100644
index d2d9d9fabb..0000000000
--- a/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/ActionEncoder.java
+++ /dev/null
@@ -1,35 +0,0 @@
-package mage.player.ai;
-
-import mage.abilities.Ability;
-import mage.abilities.SpellAbility;
-import mage.interfaces.Action;
-import sun.security.util.ArrayUtil;
-
-import java.io.IOException;
-import java.io.ObjectInputStream;
-import java.io.ObjectOutputStream;
-import java.io.Serializable;
-import java.nio.file.Files;
-import java.nio.file.Paths;
-import java.util.*;
-
-public class ActionEncoder {
-    public static int indexCount = 0;
-    public static List<boolean[]> actionVectors = new ArrayList<>();
-    //public static boolean[] actionVector = new boolean[1000];
-    public static Map<String, Integer> actionMap = new HashMap<>();
-    public static boolean[] addAction(Ability sa) {
-        String name = sa.toString();
-        boolean[] actionVector = new boolean[1000]; //inits with false's
-        if(actionMap.containsKey(name)) {//already contains action
-            System.out.printf("Action: %s already maps to index %d\n", name, actionMap.get(name));
-        } else {
-            actionMap.put(name, indexCount++);
-            System.out.printf("New action: %s discovered, reserving index %d for this action\n", name, actionMap.get(name));
-        }
-        actionVector[actionMap.get(name)] = true;
-        actionVectors.add(Arrays.copyOf(actionVector, 1000));
-        System.out.println(Arrays.toString(actionVector));
-        return actionVector;
-    }
-}
diff --git a/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/CardState.java b/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/CardState.java
deleted file mode 100644
index 6f95147620..0000000000
--- a/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/CardState.java
+++ /dev/null
@@ -1,131 +0,0 @@
-package mage.player.ai;
-
-import java.util.*;
-
-public class CardState {
-
-    public final String cardName;
-    private Set<CardState> attachedCards = new HashSet<>();
-    private Map<String, Integer> counters = new HashMap<>();
-    boolean can_attack = false;
-    boolean can_activate = false;
-    boolean can_block = false;
-    public CardState(String name) {
-        cardName = name;
-    }
-    public CardState(String name, Set<CardState> at, Map<String, Integer> cou, boolean att, boolean act, boolean blo) {
-        cardName = name;
-        attachedCards = at;
-        counters = cou;
-        can_attack = att;
-        can_activate = act;
-        can_block = blo;
-    }
-
-    public boolean equals(CardState s) {
-        return cardName.equals(s.cardName);
-        /*
-        return (attachedCards.equals(s.attachedCards) &&
-                counters.equals(s.counters) &&
-                cardName.equals(s.cardName) &&
-                can_attack == s.can_attack &&
-                can_activate == s.can_activate &&
-                can_block == s.can_block);
-
-         */
-    }
-
-    public boolean isChildOf(CardState c) {
-        if(!attachedCards.containsAll(c.attachedCards)) return false;
-        if(!counters.keySet().containsAll(c.counters.keySet())) return false;
-        if(!can_attack && c.can_attack) return false;
-        if(!can_activate && c.can_activate) return false;
-        if(!can_block && c.can_block) return false;
-
-        return true;
-    }
-
-    public static CardState getIntersection(CardState a, CardState b) {
-        Map<String, Integer> xCounters = new HashMap<>();
-        for(String counterType : a.counters.keySet()) {
-            if(b.counters.containsKey(counterType)) {
-                xCounters.put(counterType, Math.min(a.counters.get(counterType), b.counters.get(counterType)));
-            }
-        }
-        Set<CardState> xAttachedCards = new HashSet<>(a.attachedCards);
-        xAttachedCards.retainAll(b.attachedCards);
-        CardState out = new CardState(a.cardName, xAttachedCards, xCounters, a.can_attack && b.can_attack,
-                a.can_activate && b.can_activate, a.can_block && b.can_block);
-        return out;
-
-    }
-    public static CardState getDifference(CardState a, CardState b) {
-        Map<String, Integer> dCounters = new HashMap<>();
-        for(String counterType : a.counters.keySet()) {
-            int countersLeft = a.counters.get(counterType) - b.counters.get(counterType);
-            if(countersLeft > 0) {
-                dCounters.put(counterType, countersLeft);
-            }
-        }
-        Set<CardState> dAttachedCards = new HashSet<>(a.attachedCards);
-        dAttachedCards.removeAll(b.attachedCards);
-        CardState out = new CardState(a.cardName, dAttachedCards, dCounters, a.can_attack ^ b.can_attack,
-                a.can_activate ^ b.can_activate, a.can_block ^ b.can_block);
-        return out;
-    }
-
-    /**
-     * returns the pairing cost of an intersection between 2 Card States the better they pair, the lower the cost
-     * if no attributes are lost (the pairs are identical) the cost is zero. Cost is inversely proportional to intersection
-     * @param a
-     * @return
-     */
-    public static int getCost(CardState a, CardState b) {
-
-        CardState intersection = getIntersection(a, b);
-        CardState a_diff = getDifference(a, intersection);
-        CardState b_diff = getDifference(b, intersection);
-        int num = a_diff.attachedCards.size()*10 + b_diff.attachedCards.size()*10;
-        num += (a_diff.can_attack ^ b_diff.can_attack) ? 10 : 0;
-        num += (a_diff.can_activate ^ b_diff.can_activate) ? 10 : 0;
-        num += (a_diff.can_block ^ b_diff.can_block) ? 10 : 0;
-        for(String counterType : a_diff.counters.keySet()) {
-            num += a_diff.counters.get(counterType)*2;
-        }
-        for(String counterType : b_diff.counters.keySet()) {
-            num += b_diff.counters.get(counterType)*2;
-        }
-        return num;
-    }
-
-    /**
-     * uses hungarian algorithm to determine best pairing
-     * @param A
-     * @param B
-     * @return
-     */
-    public static List<CardState> bestPairing(List<CardState> A, List<CardState> B) {
-        List<CardState> out = new ArrayList<>();
-        double[][] costs = new double[A.size()][B.size()];
-
-        for(int i = 0; i < A.size(); i++) {
-            CardState best = null;
-            for(int j = 0; j < B.size(); j++) {
-                costs[i][j] = getCost(A.get(i), B.get(j));
-            }
-        }
-        HungarianAlgorithm ha = new HungarianAlgorithm(costs);
-        int[] matching = ha.execute();
-        for(int i = 0; i<A.size(); i++) {
-            if(matching[i] > 0) {
-                out.add(getIntersection(A.get(i), B.get(matching[i])));
-            }
-        }
-        return out;
-    }
-    @Override
-    public int hashCode()
-    {
-        return this.cardName.hashCode();
-    }
-}
diff --git a/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/ComputerPlayer8.java b/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/ComputerPlayer8.java
index e19777295d..b94f825eb7 100644
--- a/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/ComputerPlayer8.java
+++ b/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/ComputerPlayer8.java
@@ -11,7 +11,8 @@ import mage.target.Target;
 import java.util.UUID;
 
 public class ComputerPlayer8 extends ComputerPlayer7{
-    private StateEncoder encoder;
+    //public static boolean saveMinimaxScore = true;
+    private transient StateEncoder encoder;
     public ComputerPlayer8(ComputerPlayer7 player) {
         super(player);
     }
@@ -114,6 +115,11 @@ public class ComputerPlayer8 extends ComputerPlayer7{
         }
         return false;
     }
+    double [] getActionVec(Ability a) {
+        double[] out = new double[128];
+        out[ActionEncoder.getAction(a)] = 1.0;
+        return out;
+    }
     @Override
     protected void act(Game game) {
         if (actions == null
@@ -129,11 +135,12 @@ public class ComputerPlayer8 extends ComputerPlayer7{
                         getAbilityAndSourceInfo(game, ability, true)
                 ));
                 //save action vector
-                ActionEncoder.addAction(ability);
+                encoder.addAction(getActionVec(ability));
                 //save state vector
-                encoder.processState(game);
+                encoder.processMacroState(game, getId());
                 //add scores
-                encoder.stateScores.add(root.score);
+                double perspectiveFactor = getId() == encoder.getMyPlayerID() ? 1.0 : -1.0;
+                encoder.stateScores.add(perspectiveFactor*Math.tanh(root.score*1.0/20000));
                 if (!ability.getTargets().isEmpty()) {
                     for (Target target : ability.getTargets()) {
                         for (UUID id : target.getTargets()) {
diff --git a/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/ComputerPlayerMCTS2.java b/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/ComputerPlayerMCTS2.java
index d56e80c93b..38cd6837cc 100644
--- a/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/ComputerPlayerMCTS2.java
+++ b/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/ComputerPlayerMCTS2.java
@@ -1,23 +1,17 @@
 package mage.player.ai;
 
-import mage.abilities.Ability;
-import mage.abilities.ActivatedAbility;
-import mage.abilities.common.PassAbility;
+import ai.onnxruntime.OrtException;
 import mage.constants.PhaseStep;
 import mage.constants.RangeOfInfluence;
 import mage.game.Game;
-import mage.game.combat.Combat;
-import mage.game.combat.CombatGroup;
-import mage.game.turn.Phase;
+import mage.game.GameState;
 import mage.player.ai.MCTSPlayer.NextAction;
-import mage.players.Player;
+import mage.util.RandomUtil;
 import mage.util.ThreadUtils;
 import mage.util.XmageThreadFactory;
 import org.apache.log4j.Logger;
 
-import java.util.ArrayList;
-import java.util.List;
-import java.util.UUID;
+import java.util.*;
 import java.util.concurrent.*;
 
 /**
@@ -28,11 +22,17 @@ public class ComputerPlayerMCTS2 extends ComputerPlayerMCTS {
 
     private static final Logger logger = Logger.getLogger(ComputerPlayerMCTS2.class);
 
-    private StateEncoder encoder;
-    private static final int MAX_MCTS_CYCLES = 5;//number of additional cycles the search is allowed to run
-    private static final int BASE_THREAD_TIMEOUT = 3;
-    private static final int MIN_TREE_VISITS = 500;
+    private transient StateEncoder encoder = null;
+    private transient ReplayBuffer buffer = null;
+    private static final int MAX_MCTS_CYCLES = 6;//number of additional cycles the search is allowed to run
+    private static final int BASE_THREAD_TIMEOUT = 1;//seconds
+    private static final int MIN_TREE_VISITS = 50;//per child per thread
+
     public static boolean SHOW_THREAD_INFO = false;
+    public transient NeuralNetEvaluator nn;
+
+
+
 
 
     public ComputerPlayerMCTS2(String name, RangeOfInfluence range, int skill) {
@@ -44,7 +44,8 @@ public class ComputerPlayerMCTS2 extends ComputerPlayerMCTS {
     }
 
     public ComputerPlayerMCTS2(final ComputerPlayerMCTS2 player) {
-        super(player);
+        super(player); nn = player.nn;
+        encoder = player.encoder;
     }
 
     @Override
@@ -53,27 +54,48 @@ public class ComputerPlayerMCTS2 extends ComputerPlayerMCTS {
     }
 
     /**
-     * Evaluate the game state for the given player.
-     * Replace this placeholder with your actual value network call.
+     * Evaluates a node's game state using the neural network.
+     * This method encodes the state into sparse global indices, runs inference,
+     * and updates the node's policy prior.
      *
-     * @param game     the game state to evaluate
-     * @param playerId the player's UUID
-     * @return an integer evaluation (positive for favorable, negative otherwise)
+     * @param node The MCTSNode to evaluate.
+     * @return The value of the game state as predicted by the neural network's value head.
      */
-    protected int evaluateState(Game game, UUID playerId) {
-        // TODO: Integrate your value network here.
-        // For now, return heuristic value
-        return GameStateEvaluator2.evaluate(playerId, game).getTotalScore();
+    protected double evaluateState(MCTSNode node) {
+
+        int[] activeGlobalIndices;
+
+        encoder.processState(node.getGame(), getId());
+        activeGlobalIndices = encoder.getFinalActiveGlobalIndicesArray();
+
+
+        long[] onnxIndices = new long[activeGlobalIndices.length];
+
+        for (int i = 0; i < activeGlobalIndices.length; i++) {
+            onnxIndices[i] = activeGlobalIndices[i];
+        }
+
+        NeuralNetEvaluator.InferenceResult out = nn.infer(onnxIndices);
+        node.policy = out.policy;
+
+        return out.value;
     }
 
     public void setEncoder(StateEncoder enc) {
         encoder = enc;
     }
-
-    public StateEncoder getEncoder() {
-        return encoder;
+    public void setBuffer(ReplayBuffer buf) {
+        buffer = buf;
     }
-    public int diffVisits(List<Integer> children) {
+    public void initNN(String path) {
+        try {
+            nn = new NeuralNetEvaluator(path);
+        } catch (OrtException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    public double diffVisits(List<Integer> children) {
         int max = -1;
         int max2 = -1;//second highest
         for(int n : children) {
@@ -84,21 +106,23 @@ public class ComputerPlayerMCTS2 extends ComputerPlayerMCTS {
                 max2 = n;
             }
         }
-        return max-max2;
+        return (max*1.0)/max2;
+    }
+    public int averageVisits(List<Integer> children) {
+        int sum = 0;
+        if(children.isEmpty()) return 0;
+        for(int c : children) {
+            sum += c;
+        }
+        return sum/children.size();
     }
     @Override
     public boolean priority(Game game) {
         if (game.getTurnStepType() == PhaseStep.END_TURN) {
-            if (game.getActivePlayerId() == getId()) {
-                if (encoder != null) {
-                    System.out.println("ENCODING STATE...");
-                    encoder.processState(game);
-                }
-            }
             GameStateEvaluator2.printBattlefield(game, game.getActivePlayerId());
         }
         boolean out = super.priority(game);
-        ActionEncoder.addAction(root.getAction());
+        //ActionEncoder.addAction(root.getAction());
         return out;
     }
 
@@ -107,14 +131,14 @@ public class ComputerPlayerMCTS2 extends ComputerPlayerMCTS {
      */
     @Override
     protected void applyMCTS(final Game game, final NextAction action) {
-
-        if(root.getNumChildren() > 0 && root.visits/root.getNumChildren() > 1500) return;
-        if(root.visits/(root.getNumChildren()+1) < 300) root.reset(); //better to start fresh if existing tree is too shallow
-        if(SHOW_THREAD_INFO) System.out.printf("STARTING ROOT VISITS: %d\n", root.visits);
-        int thinkTime = BASE_THREAD_TIMEOUT;//calculateThinkTime(game, action);
+        int initialVisits = root.getAverageVisits();
+        //if(initialVisits > MAX_TREE_VISITS) return;//just keep using tree
+        if(SHOW_THREAD_INFO) System.out.printf("STARTING ROOT VISITS: %d\n", initialVisits);
+        int thinkTime = BASE_THREAD_TIMEOUT;
 
 
         if (this.threadPoolSimulations == null) {
+            System.out.println(poolSize);
             this.threadPoolSimulations = new ThreadPoolExecutor(
                     poolSize,
                     poolSize,
@@ -125,32 +149,34 @@ public class ComputerPlayerMCTS2 extends ComputerPlayerMCTS {
             );
         }
         List<MCTSExecutor> tasks = new ArrayList<>();
+        long seed = RandomUtil.nextInt();
         for (int i = 0; i < poolSize; i++) {
             Game sim = createMCTSGame(game);
             MCTSPlayer player = (MCTSPlayer) sim.getPlayer(playerId);
             player.setNextAction(action);
+            player.dirichletSeed = seed;
             // Create an executor that overrides rollout() to use evaluateState().
             MCTSExecutor exec = new MCTSExecutor(sim, playerId, thinkTime) {
                 @Override
-                protected int rollout(MCTSNode node) {
+                protected double rollout(MCTSNode node) {
                     // Instead of a full simulation, evaluate the leaf state with our value function.
-                    return evaluateState(node.getGame(), playerId);
+                    return evaluateState(node);
                 }
             };
-            if(i < 2 && root.getNumChildren() > 0) {//reserve first 2 threads to build off existing root
-                //exec.root = new MCTSNode(root);
-            }
             tasks.add(exec);
         }
         //runs mcts sims until the root has been visited enough times
-        int diffVisits = 0;
+        List<Integer> childVisits = new ArrayList<>();
         int cycleCounter = 0;
+        int fullTime = 0;
 
-        while (diffVisits < MIN_TREE_VISITS) {//use max visits of children as indicator
+        while (averageVisits(childVisits)+initialVisits < MIN_TREE_VISITS*poolSize) {//use max visits of children as indicator
 
-            if (cycleCounter > MAX_MCTS_CYCLES) break;
-            cycleCounter++;
+            if (cycleCounter > MAX_MCTS_CYCLES) break; //early exit
+
+            if(diffVisits(childVisits) > 2.5 && averageVisits(childVisits) > MIN_TREE_VISITS*poolSize*0.5) break;
 
+            cycleCounter++;
             try {
                 List<Future<Boolean>> runningTasks = threadPoolSimulations.invokeAll(tasks, thinkTime, TimeUnit.SECONDS);
                 for (Future<Boolean> runningTask : runningTasks) {
@@ -163,44 +189,101 @@ public class ComputerPlayerMCTS2 extends ComputerPlayerMCTS {
                     throw new IllegalStateException("One of the simulated games raised an error: " + e, e);
                 }
             }
-            if (SHOW_THREAD_INFO) System.out.printf("CYCLE %d: %d threads were created\n", cycleCounter, tasks.size());
 
-            List<Integer> childVisits = new ArrayList<>();
+            childVisits = getChildVisits(tasks);
 
-            for(int i = 0; i <  tasks.get(7).root.children.size(); i++) {
-                int visitSum = 0;
-                for(int j = 0; j < 8; j++) {
-                    visitSum += tasks.get(j).root.children.get(i).visits;
-                }
-                childVisits.add(visitSum);
-            }
-            diffVisits = diffVisits(childVisits);
             if (SHOW_THREAD_INFO) {
-                System.out.printf("COMPOSITE CHILDREN: %s\n", childVisits.toString());
-                System.out.printf("MAX DIFF OF CHILDREN: %d\n", diffVisits);
+                System.out.printf("CYCLE %d: %d threads were created\n", cycleCounter, tasks.size());
+                for (MCTSExecutor task : tasks) {
+                    if (task.reachedTerminalState && SHOW_THREAD_INFO)
+                        System.out.print("-task reached a terminal state-");
+                    if (SHOW_THREAD_INFO) System.out.printf("%d ", task.simCount);
+                }
+                System.out.printf("\nCOMPOSITE CHILDREN: %s\n", childVisits.toString());
             }
-            thinkTime += 1;
+            fullTime += thinkTime;
         }
-
         int simCount = 0;
         for (MCTSExecutor task : tasks) {
-            if (task.reachedTerminalState && SHOW_THREAD_INFO)
-                System.out.print("-task reached a terminal state-");
-            if (SHOW_THREAD_INFO) System.out.printf("%d ", task.simCount);
             simCount += task.getSimCount();
             root.merge(task.getRoot());
             task.clear();
         }
-        if (SHOW_THREAD_INFO) System.out.println();
         tasks.clear();
-        totalThinkTime += thinkTime;
+        totalThinkTime += fullTime;
         totalSimulations += simCount;
         if (SHOW_THREAD_INFO) {
-            logger.info("Player: " + name + " simulated " + simCount + " evaluations in " + thinkTime
+            logger.info("Player: " + name + " simulated " + simCount + " evaluations in " + fullTime
                     + " seconds - nodes in tree: " + root.size());
             logger.info("Total: simulated " + totalSimulations + " evaluations in " + totalThinkTime
                     + " seconds - Average: " + totalSimulations / totalThinkTime);
         }
         MCTSNode.logHitMiss();
     }
+    double[] getActionVec() {
+        double tau = 1.0;            // your temperature hyperparam
+        int    A   = 128;
+        double[] out = new double[A];
+        double   sum = 0;
+        // 1) accumulate visits^(1/tau)
+        for (MCTSNode child : root.children) {
+            if (child.getAction() != null) {
+                int idx = ActionEncoder.getAction(child.getAction());
+                double v = child.visits;
+                // apply temperature
+                double vt = Math.pow(v, 1.0 / tau);
+                out[idx] = vt;
+                sum += vt;
+            }
+        }
+
+        // 2) normalize into a proper distribution
+        if (sum > 0) {
+            for (int i = 0; i < A; i++) {
+                out[i] = out[i] / sum;
+            }
+        }
+        return out;
+    }
+    @Override
+    protected void calculateActions(Game game, NextAction action) {
+        if (root == null) {
+            Game sim = createMCTSGame(game);
+            MCTSPlayer player = (MCTSPlayer) sim.getPlayer(playerId);
+            player.setNextAction(action);
+            root = new MCTSNode(playerId, sim);
+            root.chooseTargetAction = new ArrayList<>(chooseTargetAction);
+        }
+        applyMCTS(game, action);
+        if (root != null) {
+            MCTSNode best = root.bestChild();
+            if(best == null) return;
+
+            encoder.processMacroState(game, getId());
+            encoder.addAction(getActionVec());
+            encoder.stateScores.add(root.getWinRatio());
+            Game copiedState = game.copy();
+            if(buffer != null)
+                buffer.add(copiedState);
+
+            root = best;
+            root.emancipate();
+        }
+    }
+    private List<Integer> getChildVisits(List<MCTSExecutor> tasks) {
+        List<Integer> childVisits = new ArrayList<>();
+        int min = Integer.MAX_VALUE;
+        for(MCTSExecutor task : tasks) {
+            if(task.root.children.size()< min) min = task.root.children.size();
+        }
+
+        for(int i = 0; i <  min; i++) {
+            int visitSum = 0;
+            for(int j = 0; j < poolSize; j++) {
+                visitSum += tasks.get(j).root.children.get(i).visits;
+            }
+            childVisits.add(visitSum);
+        }
+        return childVisits;
+    }
 }
\ No newline at end of file
diff --git a/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/ComputerPlayerMinimaxOpponent.java b/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/ComputerPlayerMinimaxOpponent.java
new file mode 100644
index 0000000000..d7c56d7862
--- /dev/null
+++ b/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/ComputerPlayerMinimaxOpponent.java
@@ -0,0 +1,145 @@
+package mage.player.ai;
+
+import mage.abilities.Ability;
+import mage.abilities.ActivatedAbility;
+import mage.constants.RangeOfInfluence;
+import mage.game.Game;
+import mage.game.events.GameEvent;
+import mage.target.Target;
+
+import java.util.UUID;
+
+public class ComputerPlayerMinimaxOpponent extends ComputerPlayer7{
+
+    public ComputerPlayerMinimaxOpponent(ComputerPlayer7 player) {
+        super(player);
+    }
+
+    public ComputerPlayerMinimaxOpponent(String name, RangeOfInfluence range, int skill) {
+        super(name, range, skill);
+    }
+
+
+
+    @Override
+    public boolean priority(Game game) {
+        game.resumeTimer(getTurnControlledBy());
+        boolean result = priorityPlay(game);
+        game.pauseTimer(getTurnControlledBy());
+        return result;
+    }
+    private boolean priorityPlay(Game game) {
+        game.getState().setPriorityPlayerId(playerId);
+        game.firePriorityEvent(playerId);
+
+
+        switch (game.getTurnStepType()) {
+            case UPKEEP:
+
+            case DRAW:
+                pass(game);
+                return false;
+            case PRECOMBAT_MAIN:
+                // 09.03.2020:
+                // in old version it passes opponent's pre-combat step (game.isActivePlayer(playerId) -> pass(game))
+                // why?!
+
+
+                //printBattlefieldScore(game, "Sim PRIORITY on MAIN 1");
+
+                if (actions.isEmpty()) {
+                    calculateActions(game);
+                } else {
+                    // TODO: is it possible non empty actions without calculation?!
+                    throw new IllegalStateException("wtf");
+                }
+                act(game);
+                return true;
+            case BEGIN_COMBAT:
+                pass(game);
+                return false;
+            case DECLARE_ATTACKERS:
+                //printBattlefieldScore(game, "Sim PRIORITY on DECLARE ATTACKERS");
+                if (actions.isEmpty()) {
+                    calculateActions(game);
+                } else {
+                    // TODO: is it possible non empty actions without calculation?!
+                    throw new IllegalStateException("wtf");
+                }
+                act(game);
+                return true;
+            case DECLARE_BLOCKERS:
+                //printBattlefieldScore(game, "Sim PRIORITY on DECLARE BLOCKERS");
+                if (actions.isEmpty()) {
+                    calculateActions(game);
+                } else {
+                    // TODO: is it possible non empty actions without calculation?!
+                    throw new IllegalStateException("wtf");
+                }
+                act(game);
+                return true;
+            case FIRST_COMBAT_DAMAGE:
+            case COMBAT_DAMAGE:
+            case END_COMBAT:
+                pass(game);
+                return false;
+            case POSTCOMBAT_MAIN:
+                //printBattlefieldScore(game, "Sim PRIORITY on MAIN 2");
+                if (actions.isEmpty()) {
+                    calculateActions(game);
+                } else {
+                    // TODO: is it possible non empty actions without calculation?!
+                    throw new IllegalStateException("wtf");
+                }
+                act(game);
+                return true;
+            case END_TURN:
+                //state learning testing only check state at end of its turns
+                if(game.getActivePlayerId() == getId()) {
+                    printBattlefieldScore(game, "END STEP====================");
+                }
+            case CLEANUP:
+                actionCache.clear();
+                pass(game);
+                return false;
+        }
+        return false;
+    }
+    @Override
+    protected void act(Game game) {
+        if (actions == null
+                || actions.isEmpty()) {
+            pass(game);
+        } else {
+            boolean usedStack = false;
+            while (actions.peek() != null) {
+                Ability ability = actions.poll();
+                // example: ===> SELECTED ACTION for PlayerA: Play Swamp
+                System.out.println(String.format("===> SELECTED ACTION for %s: %s",
+                        getName(),
+                        getAbilityAndSourceInfo(game, ability, true)
+                ));
+                if (!ability.getTargets().isEmpty()) {
+                    for (Target target : ability.getTargets()) {
+                        for (UUID id : target.getTargets()) {
+                            target.updateTarget(id, game);
+                            if (!target.isNotTarget()) {
+                                game.addSimultaneousEvent(GameEvent.getEvent(GameEvent.EventType.TARGETED, id, ability, ability.getControllerId()));
+                            }
+                        }
+                    }
+                }
+                //ComputerPlayerMCTS.macroState = ComputerPlayerMCTS.createCompleteMCTSGame(game);
+                //ComputerPlayerMCTS.macroPlayerId = getId();
+                //ComputerPlayerMCTS.lastAction = ability.copy();
+                this.activateAbility((ActivatedAbility) ability, game);
+                if (ability.isUsesStack()) {
+                    usedStack = true;
+                }
+            }
+            if (usedStack) {
+                pass(game);
+            }
+        }
+    }
+}
diff --git a/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/ComputerPlayerPureMCTS.java b/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/ComputerPlayerPureMCTS.java
new file mode 100644
index 0000000000..16210cbb92
--- /dev/null
+++ b/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/ComputerPlayerPureMCTS.java
@@ -0,0 +1,246 @@
+package mage.player.ai;
+
+import ai.onnxruntime.OrtException;
+import mage.constants.PhaseStep;
+import mage.constants.RangeOfInfluence;
+import mage.game.Game;
+import mage.game.GameState;
+import mage.player.ai.MCTSPlayer.NextAction;
+import mage.util.RandomUtil;
+import mage.util.ThreadUtils;
+import mage.util.XmageThreadFactory;
+import org.apache.log4j.Logger;
+
+import java.util.*;
+import java.util.concurrent.*;
+
+/**
+ * ComputerPlayerPureMCTS extends ComputerPlayerMCTS and always returns 0 at leaf nodes.
+ * It is designed as a purely random chaotic agent for feature discovery
+ */
+public class ComputerPlayerPureMCTS extends ComputerPlayerMCTS {
+
+    private static final Logger logger = Logger.getLogger(ComputerPlayerPureMCTS.class);
+
+    private transient StateEncoder encoder = null;
+    private transient ReplayBuffer buffer = null;
+    private static final int MAX_MCTS_CYCLES = 6;//number of additional cycles the search is allowed to run
+    private static final int BASE_THREAD_TIMEOUT = 1;//seconds
+    private static final int MIN_TREE_VISITS = 50;//per child per thread
+
+    public static boolean SHOW_THREAD_INFO = false;
+
+
+
+
+    public ComputerPlayerPureMCTS(String name, RangeOfInfluence range, int skill) {
+        super(name, range, skill);
+    }
+
+    protected ComputerPlayerPureMCTS(UUID id) {
+        super(id);
+    }
+
+    public ComputerPlayerPureMCTS(final ComputerPlayerPureMCTS player) {
+        super(player);
+        encoder = player.encoder;
+    }
+
+    @Override
+    public ComputerPlayerPureMCTS copy() {
+        return new ComputerPlayerPureMCTS(this);
+    }
+
+    /**
+     * just meaningless exploration
+     * @param node
+     * @return
+     */
+    protected double evaluateState(MCTSNode node) {
+        encoder.processMacroState(node.getGame(), getId());
+        encoder.addAction(getActionVec());
+        encoder.stateScores.add(0.0);
+        return 0;
+    }
+    public void setEncoder(StateEncoder enc) {
+        encoder = enc;
+    }
+    public void setBuffer(ReplayBuffer buf) {
+        buffer = buf;
+    }
+    public int averageVisits(List<Integer> children) {
+        int sum = 0;
+        if(children.isEmpty()) return 0;
+        for(int c : children) {
+            sum += c;
+        }
+        return sum/children.size();
+    }
+    @Override
+    public boolean priority(Game game) {
+        if (game.getTurnStepType() == PhaseStep.END_TURN) {
+            GameStateEvaluator2.printBattlefield(game, game.getActivePlayerId());
+        }
+        boolean out = super.priority(game);
+        //ActionEncoder.addAction(root.getAction());
+        return out;
+    }
+
+    /**
+     * Overrides applyMCTS to use the value function at leaf nodes.
+     */
+    @Override
+    protected void applyMCTS(final Game game, final NextAction action) {
+        int initialVisits = root.getAverageVisits();
+        //if(initialVisits > MAX_TREE_VISITS) return;//just keep using tree
+        if(SHOW_THREAD_INFO) System.out.printf("STARTING ROOT VISITS: %d\n", initialVisits);
+        int thinkTime = BASE_THREAD_TIMEOUT;
+
+
+        if (this.threadPoolSimulations == null) {
+            System.out.println(poolSize);
+            this.threadPoolSimulations = new ThreadPoolExecutor(
+                    poolSize,
+                    poolSize,
+                    0L,
+                    TimeUnit.MILLISECONDS,
+                    new LinkedBlockingQueue<>(),
+                    new XmageThreadFactory(ThreadUtils.THREAD_PREFIX_AI_SIMULATION_MCTS)
+            );
+        }
+        List<MCTSExecutor> tasks = new ArrayList<>();
+        long seed = RandomUtil.nextInt();
+        for (int i = 0; i < poolSize; i++) {
+            Game sim = createMCTSGame(game);
+            MCTSPlayer player = (MCTSPlayer) sim.getPlayer(playerId);
+            player.setNextAction(action);
+            player.dirichletSeed = seed;
+            // Create an executor that overrides rollout() to use evaluateState().
+            MCTSExecutor exec = new MCTSExecutor(sim, playerId, thinkTime) {
+                @Override
+                protected double rollout(MCTSNode node) {
+                    // Instead of a full simulation, evaluate the leaf state with our value function.
+                    return evaluateState(node);
+                }
+            };
+            tasks.add(exec);
+        }
+        //runs mcts sims until the root has been visited enough times
+        List<Integer> childVisits = new ArrayList<>();
+        int cycleCounter = 0;
+        int fullTime = 0;
+
+        while (averageVisits(childVisits)+initialVisits < MIN_TREE_VISITS*poolSize) {//use max visits of children as indicator
+
+            if (cycleCounter > MAX_MCTS_CYCLES) break; //early exit
+
+            //if(diffVisits(childVisits) > 2.5 && averageVisits(childVisits) > MIN_TREE_VISITS*poolSize*0.5) break;
+
+            cycleCounter++;
+            try {
+                List<Future<Boolean>> runningTasks = threadPoolSimulations.invokeAll(tasks, thinkTime, TimeUnit.SECONDS);
+                for (Future<Boolean> runningTask : runningTasks) {
+                    runningTask.get();
+                }
+            } catch (InterruptedException | CancellationException e) {
+                if (SHOW_THREAD_INFO) logger.warn("applyMCTS timeout");
+            } catch (ExecutionException e) {
+                if (this.isTestsMode()) {
+                    throw new IllegalStateException("One of the simulated games raised an error: " + e, e);
+                }
+            }
+
+            childVisits = getChildVisits(tasks);
+
+            if (SHOW_THREAD_INFO) {
+                System.out.printf("CYCLE %d: %d threads were created\n", cycleCounter, tasks.size());
+                for (MCTSExecutor task : tasks) {
+                    if (task.reachedTerminalState && SHOW_THREAD_INFO)
+                        System.out.print("-task reached a terminal state-");
+                    if (SHOW_THREAD_INFO) System.out.printf("%d ", task.simCount);
+                }
+                System.out.printf("\nCOMPOSITE CHILDREN: %s\n", childVisits.toString());
+            }
+            fullTime += thinkTime;
+        }
+        int simCount = 0;
+        for (MCTSExecutor task : tasks) {
+            simCount += task.getSimCount();
+            root.merge(task.getRoot());
+            task.clear();
+        }
+        tasks.clear();
+        totalThinkTime += fullTime;
+        totalSimulations += simCount;
+        if (SHOW_THREAD_INFO) {
+            logger.info("Player: " + name + " simulated " + simCount + " evaluations in " + fullTime
+                    + " seconds - nodes in tree: " + root.size());
+            logger.info("Total: simulated " + totalSimulations + " evaluations in " + totalThinkTime
+                    + " seconds - Average: " + totalSimulations / totalThinkTime);
+        }
+        MCTSNode.logHitMiss();
+    }
+    double[] getActionVec() {
+        double tau = 1.0;            // your temperature hyperparam
+        int    A   = 128;
+        double[] out = new double[A];
+        double   sum = 0;
+        // 1) accumulate visits^(1/tau)
+        for (MCTSNode child : root.children) {
+            if (child.getAction() != null) {
+                int idx = ActionEncoder.getAction(child.getAction());
+                double v = child.visits;
+                // apply temperature
+                double vt = Math.pow(v, 1.0 / tau);
+                out[idx] = vt;
+                sum += vt;
+            }
+        }
+
+        // 2) normalize into a proper distribution
+        if (sum > 0) {
+            for (int i = 0; i < A; i++) {
+                out[i] = out[i] / sum;
+            }
+        }
+        return out;
+    }
+    @Override
+    protected void calculateActions(Game game, NextAction action) {
+        if (root == null) {
+            Game sim = createMCTSGame(game);
+            MCTSPlayer player = (MCTSPlayer) sim.getPlayer(playerId);
+            player.setNextAction(action);
+            root = new MCTSNode(playerId, sim);
+            root.chooseTargetAction = new ArrayList<>(chooseTargetAction);
+        }
+        applyMCTS(game, action);
+        if (root != null) {
+            MCTSNode best = root.bestChild();
+            if(best == null) return;
+
+            encoder.processMacroState(game, getId());
+            encoder.addAction(getActionVec());
+            encoder.stateScores.add(root.getWinRatio());
+
+            root = best;
+            root.emancipate();
+        }
+    }
+    private List<Integer> getChildVisits(List<MCTSExecutor> tasks) {
+        List<Integer> childVisits = new ArrayList<>();
+        int min = Integer.MAX_VALUE;
+        for(MCTSExecutor task : tasks) {
+            if(task.root.children.size()< min) min = task.root.children.size();
+        }
+
+        for(int i = 0; i <  min; i++) {
+            int visitSum = 0;
+            for(int j = 0; j < poolSize; j++) {
+                visitSum += tasks.get(j).root.children.get(i).visits;
+            }
+            childVisits.add(visitSum);
+        }
+        return childVisits;
+    }
+}
\ No newline at end of file
diff --git a/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/DeckLearner.java b/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/DeckLearner.java
deleted file mode 100644
index 70b8919db5..0000000000
--- a/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/DeckLearner.java
+++ /dev/null
@@ -1,37 +0,0 @@
-package mage.player.ai;
-
-import mage.cards.decks.DeckCardLists;
-import mage.game.Game;
-import mage.game.GameState;
-import org.apache.log4j.Logger;
-
-/**
- * Generates State graph for given deck and handles training cycles to tune RL parameters
- *
- * @author willwroble
- */
-public class DeckLearner {
-    private DeckCardLists deckList;
-    private ComputerPlayer player;
-    private GameStateGraphNode stateTreeRoot;
-    private Game game;
-    private static Logger logger;
-    public DeckLearner(ComputerPlayer p, DeckCardLists d) {
-        player = p;
-        deckList = d;
-        logger = org.apache.log4j.Logger.getLogger(DeckLearner.class);
-    }
-    public GameStateGraphNode readGameState() {
-        GameState state = game.getState();
-        return null;
-
-    }
-    //generates skeleton state tree with one of each one card state
-    public void GenerateInitialStateTree() {
-
-
-    }
-    public void AddGameStateNode(GameStateGraphNode n) {
-
-    }
-}
diff --git a/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/FeatureHierarchy.java b/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/FeatureHierarchy.java
deleted file mode 100644
index 9bf72d21ce..0000000000
--- a/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/FeatureHierarchy.java
+++ /dev/null
@@ -1,18 +0,0 @@
-package mage.player.ai;
-
-import java.util.HashSet;
-import java.util.Set;
-import java.util.Vector;
-
-/**
- * responsible for storing the vector hierarchy that will be processed by deepsets
- */
-public class FeatureHierarchy {
-    Vector<Integer> features;
-    Set<FeatureHierarchy> subFeatures;
-
-    public FeatureHierarchy() {
-        features = new Vector<>();
-        subFeatures = new HashSet<>();
-    }
-}
diff --git a/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/FeatureMerger.java b/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/FeatureMerger.java
index 417b914656..108e887937 100644
--- a/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/FeatureMerger.java
+++ b/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/FeatureMerger.java
@@ -1,61 +1,190 @@
 package mage.player.ai;
 
+import com.j256.ormlite.stmt.query.In;
+
 import java.util.*;
 
 public class FeatureMerger {
-
     /**
-     * Computes an ignore list of feature indices that are nearly always co-occurring.
+     * Computes an ignore list for features.
+     * Drops features that perfectly co-occurred with another feature (and fired at least once).
+     * Also drops features that never occurred at all.
      *
-     * @param stateVectors A list of boolean arrays, each representing the binary feature vector for one state.
-     * @param threshold The minimum co-occurrence ratio (e.g., 0.95) above which one feature can be ignored.
-     * @return A set of feature indices to ignore.
+     * @param stateVectorsSet List of Sets of Integers, where each Set contains the active global feature indices for a state.
+     * @return A Set of feature indices to ignore.
      */
-    public static Set<Integer> computeIgnoreList(List<boolean[]> stateVectors, double threshold) {
-        Set<Integer> ignoreList = new HashSet<>();
-        if (stateVectors.isEmpty()) {
-            return ignoreList;
-        }
-        int vectorLength = stateVectors.get(0).length;
-        int numStates = stateVectors.size();
-
-        // Count how many times each feature is active.
-        int[] featureCounts = new int[vectorLength];
-        // Count co-occurrence between each pair of features.
-        int[][] coOccurrence = new int[vectorLength][vectorLength];
-
-        for (boolean[] vector : stateVectors) {
-            for (int i = 0; i < vectorLength; i++) {
-                if (vector[i]) {
-                    featureCounts[i]++;
-                    for (int j = i + 1; j < vectorLength; j++) {
-                        if (vector[j]) {
-                            coOccurrence[i][j]++;
-                            coOccurrence[j][i]++;
-                        }
+    public static Set<Integer> computeIgnoreList(List<Set<Integer>> stateVectorsSet) {
+        int S = StateEncoder.indexCount;
+        int M = stateVectorsSet.size();
+        if (M == 0) {
+            return Collections.emptySet();
+        }
+
+        // patterns[f] will be a BitSet indicating in which of the M stateVectors feature 'f' occurred.
+        BitSet[] patterns = new BitSet[S];
+        for (int f = 0; f < S; f++) {
+            patterns[f] = new BitSet(M);
+        }
+
+        for (int row = 0; row < M; row++) {
+            Set<Integer> activeIndices = stateVectorsSet.get(row);
+            if (activeIndices != null) { // Check for null set if that's possible in your data
+                for (Integer activeFeatureIndex : activeIndices) { // Iterating over Integer objects
+                    // Ensure the index is within the bounds of our patterns array
+                    if (activeFeatureIndex != null && activeFeatureIndex >= 0 && activeFeatureIndex < S) {
+                        patterns[activeFeatureIndex].set(row);
+                    } else {
+                        // Log or handle out-of-bounds or null index if necessary
+                        // System.err.println("Warning: Feature index " + activeFeatureIndex + " is out of bounds/null for S=" + S);
                     }
                 }
             }
         }
 
-        // For each pair of features, check if they nearly always appear together.
-        // If so, mark the one with the lower frequency as redundant.
-        for (int i = 0; i < vectorLength; i++) {
-            for (int j = i + 1; j < vectorLength; j++) {
-                if (featureCounts[i] > 0 && featureCounts[j] > 0) {
-                    double coRatioI = (double) coOccurrence[i][j] / featureCounts[i];
-                    double coRatioJ = (double) coOccurrence[i][j] / featureCounts[j];
-                    if (coRatioI >= threshold && coRatioJ >= threshold) {
-                        // They co-occur almost always.
-                        if (featureCounts[i] <= featureCounts[j]) {
-                            ignoreList.add(i);
-                        } else {
-                            ignoreList.add(j);
-                        }
-                    }
+        Map<BitSet, Integer> representative = new HashMap<>(S);
+        Set<Integer> ignoreList = new HashSet<>();
+
+        for (int f = 0; f < S; f++) {
+            BitSet pattern = patterns[f];
+            if (pattern.isEmpty()) {
+                // Feature f never occurred in any stateVector - add to ignore list
+                ignoreList.add(f);
+                continue;
+            }
+
+            BitSet key = (BitSet) pattern.clone();
+            Integer firstFeatureWithThisPattern = representative.get(key);
+
+            if (firstFeatureWithThisPattern == null) {
+                representative.put(key, f);
+            } else {
+                ignoreList.add(f);
+            }
+        }
+        return ignoreList;
+    }
+
+    /**
+     * Computes an ignore list for features using LabeledState objects.
+     * Assumes LabeledState.activeGlobalIndices is an int[] of active global feature indices.
+     *
+     * @param labeledStates List of LabeledState objects.
+     * @return A Set of feature indices to ignore.
+     */
+    public static Set<Integer> computeIgnoreListFromLS(List<LabeledState> labeledStates) {
+        int M = labeledStates.size();
+        int S = StateEncoder.indexCount;
+        if (M == 0) {
+            return Collections.emptySet();
+        }
+
+        BitSet[] patterns = new BitSet[S];
+        for (int f = 0; f < S; f++) {
+            patterns[f] = new BitSet(M);
+        }
+
+        for (int row = 0; row < M; row++) {
+            // Assuming LabeledState now has a field like 'activeGlobalIndices' of type int[]
+            int[] activeIndices = labeledStates.get(row).stateVector;
+            for (int activeFeatureIndex : activeIndices) {
+                if (activeFeatureIndex >= 0 && activeFeatureIndex < S) {
+                    patterns[activeFeatureIndex].set(row);
+                } else {
+                    // Log or handle out-of-bounds index
                 }
             }
         }
+
+        // The rest of the logic is identical to computeIgnoreList
+        Map<BitSet, Integer> representative = new HashMap<>(S);
+        Set<Integer> ignoreList = new HashSet<>();
+
+        for (int f = 0; f < S; f++) {
+            BitSet pattern = patterns[f];
+            if (pattern.isEmpty()) {
+                ignoreList.add(f);
+                continue;
+            }
+            BitSet key = (BitSet) pattern.clone();
+            Integer first = representative.get(key);
+            if (first == null) {
+                representative.put(key, f);
+            } else {
+                ignoreList.add(f);
+            }
+        }
         return ignoreList;
     }
-}
+    /**
+     * Computes an ignore list for features using LabeledState objects.
+     * Assumes LabeledState.activeGlobalIndices is an int[] of active global feature indices.
+     * @param endIndex max index to use
+     * @param labeledStates List of LabeledState objects.
+     * @return A Set of feature indices to ignore.
+     */
+    public static Set<Integer> computeIgnoreListFromLS(List<LabeledState> labeledStates, int startIndex, int endIndex) {
+        int M = labeledStates.size();
+        if (M == 0) {
+            return Collections.emptySet();
+        }
+
+        BitSet[] patterns = new BitSet[endIndex];
+        for (int f = startIndex; f < endIndex; f++) {
+            patterns[f] = new BitSet(M);
+        }
+
+        for (int row = 0; row < M; row++) {
+            // Assuming LabeledState now has a field like 'activeGlobalIndices' of type int[]
+            int[] activeIndices = labeledStates.get(row).stateVector;
+            for (int activeFeatureIndex : activeIndices) {
+                if (activeFeatureIndex >= startIndex && activeFeatureIndex < endIndex) {
+                    patterns[activeFeatureIndex].set(row);
+                } else {
+                    // Log or handle out-of-bounds index
+                }
+            }
+        }
+
+        // The rest of the logic is identical to computeIgnoreList
+        Map<BitSet, Integer> representative = new HashMap<>(endIndex);
+        Set<Integer> ignoreList = new HashSet<>();
+
+        for (int f = startIndex; f < endIndex; f++) {
+            BitSet pattern = patterns[f];
+            if (pattern.isEmpty()) {
+                ignoreList.add(f);
+                continue;
+            }
+            BitSet key = (BitSet) pattern.clone();
+            Integer first = representative.get(key);
+            if (first == null) {
+                representative.put(key, f);
+            } else {
+                ignoreList.add(f);
+            }
+        }
+        return ignoreList;
+    }
+    /**
+     * Compresses a raw feature vector by removing any indices present in the ignore set.
+     * @param ignore The Set of feature indices to remove.
+     * @param stateVector The uncompressed array of feature indices.
+     * @return A new, compressed array of feature indices.
+     */
+    public static int[] getCompressedVectorArray(Set<Integer> ignore, int[] stateVector) {
+        // Use a List to dynamically store the features that are kept.
+        List<Integer> compressedList = new ArrayList<>();
+        for (int featureIndex : stateVector) {
+            if (!ignore.contains(featureIndex)) {
+                compressedList.add(featureIndex);
+            }
+        }
+
+        // Convert the List to a primitive int array for final storage.
+        int[] out = new int[compressedList.size()];
+        for (int i = 0; i < compressedList.size(); i++) {
+            out[i] = compressedList.get(i);
+        }
+        return out;
+    }
+}
\ No newline at end of file
diff --git a/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/Features.java b/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/Features.java
index c288236d8e..0fd9dcdf12 100644
--- a/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/Features.java
+++ b/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/Features.java
@@ -4,31 +4,39 @@ import java.io.*;
 import java.nio.file.Files;
 import java.nio.file.Paths;
 import java.util.*;
+import java.util.concurrent.atomic.AtomicInteger;
 
 /**
- *this hierarchical structure represents the mapping of every possible relevant feature encountered from a game state to
- * an index on a 200000 dimension binary vector. the reduced form of this vector (4000) will be used as input for both a policy and
+ * This hierarchical structure represents the mapping of every possible relevant feature encountered from a game state to
+ * an index on a 200000 dimension binary vector. The reduced form of this vector (~5000) will be used as input for both a policy and
  * value neural network. To see how game features are mapped look at StateEncoder.java this data structure only handles and stores the
- * mappings
+ * mappings.
+ *
  * @author willwroble
  */
-public class Features  implements Serializable {
-    private static final long serialVersionUID = 1L;
-    public int globalIndexCount;
-    Set<Integer> ignoreList;
+public class Features implements Serializable {
+    private static final long serialVersionUID = 2L; // Version updated for the structural change
+    public AtomicInteger localIndexCount; // a mutable, thread-safe counter
+    public int previousLocalIndexCount = 0;
+    public Set<Integer> ignoreList;
+    public int version = 0;
 
     private final Map<String, Map<Integer, Features>> subFeatures;
     private final Map<String, Map<Integer, Integer>> features;
     private final Map<String, TreeMap<Integer, Map<Integer, Integer>>> numericFeatures; //name->value->occurrences
     private final Map<String, Integer> occurrences;
     private final Map<String, TreeMap<Integer, Integer>> numericOccurrences;
-    private final Map<String, Features> categoriesForChildren; //isnt reset between states represent all possible categories for children
-    public Set<Features> categories; //resets every state represents temporary category features fall under
+    private final Map<String, Features> categoriesForChildren; //isn't reset between states, represents all possible categories for children
+    private final Set<Features> categories; //resets every state represents temporary category features fall under
+    public boolean passToParent = true;
 
-    public String featureName;
+    private transient StateEncoder encoder;
+
+    private String featureName;
     public Features parent;
     public static boolean printOldFeatures = true;
     public static boolean printNewFeatures = true;
+
     public Features() {
         //constructor
         subFeatures = new HashMap<>();
@@ -38,58 +46,93 @@ public class Features  implements Serializable {
         numericOccurrences = new HashMap<>();
         categoriesForChildren = new HashMap<>();
         categories = new HashSet<>();
+        ignoreList = new HashSet<>();
+        localIndexCount = new AtomicInteger(0);
         parent = null;
         featureName = "root";
     }
+
     public Features(Features p, String name) {
         this();
+        // Manually set fields instead of calling this(), to avoid creating a new AtomicInteger
         parent = p;
         featureName = name;
+        encoder = p.encoder;
+        localIndexCount = p.localIndexCount;
     }
 
+    public Features(String name, StateEncoder e, AtomicInteger i) {
+        this();
+        featureName = name;
+        encoder = e;
+        localIndexCount = i;
+    }
 
-    public Features getCategory(String name) {
+    public void setEncoder(StateEncoder encoder) {
+        this.encoder = encoder;
+        for (String n : subFeatures.keySet()) {
+            for (Integer i : subFeatures.get(n).keySet()) {
+                subFeatures.get(n).get(i).setEncoder(encoder);
+            }
+        }
+        for (String n : categoriesForChildren.keySet()) {
+            categoriesForChildren.get(n).setEncoder(encoder);
+        }
+    }
 
-        if(categoriesForChildren.containsKey(name)) {//already contains category
+    public Features getCategory(String name) {
+        if(name.isEmpty()) return null;
+        if (categoriesForChildren.containsKey(name)) { //already contains category
             return categoriesForChildren.get(name);
-
-        } else{//completely new
+        } else { //completely new
             Features parentCategory = null;
-            if(parent != null) parentCategory = parent.getCategory(name); //categories can have a parent
-            Features newCat = new Features(parentCategory, name + "_" + featureName);
+            if (parent != null) parentCategory = parent.getCategory(name); //categories can have a parent
+            Features newCat;
+            if (parentCategory != null) {
+                newCat = new Features(parentCategory, name + "_" + featureName);
+            } else {
+                newCat = new Features(name + "_" + featureName, encoder, localIndexCount);
+            }
             categoriesForChildren.put(name, newCat);
             return newCat;
         }
-
     }
 
     /**
      * gets subfeatures at name or creates them if they dont exist
+     *
      * @param name
      * @return subfeature at name (never returns null)
      */
     public Features getSubFeatures(String name) {
-        //first add as a normal binary feature
+        return getSubFeatures(name, true);
+    }
+
+    public Features getSubFeatures(String name, boolean passToParent) {
+        if(name.isEmpty()) return null;
+        //added as normal binary feature
         addFeature(name);
 
         int n = occurrences.get(name);
-        if(subFeatures.containsKey(name)) {//already contains feature
-            if(subFeatures.get(name).containsKey(n)) {//contains count too
+        if (subFeatures.containsKey(name)) { //already contains feature
+            if (subFeatures.get(name).containsKey(n)) { //contains count too
                 return subFeatures.get(name).get(n);
-            } else {//new count
+            } else { //new count
                 Map<Integer, Features> map = subFeatures.get(name);
                 Features newSub = new Features(this, name + "_" + Integer.toString(n));
                 map.put(n, newSub);
                 return newSub;
             }
-        } else{//completely new
+        } else { //completely new
             Map<Integer, Features> newMap = new HashMap<>();
             Features newSub = new Features(this, name + "_1");
             newMap.put(1, newSub);
             subFeatures.put(name, newMap);
+            newSub.passToParent = passToParent;
             return newSub;
         }
     }
+
     /**
      * similar to a subfeature a category will pool features within itself. however
      * unlike subfeatures a feature can inherit multiple categories(ie card type and color).
@@ -97,112 +140,116 @@ public class Features  implements Serializable {
      * this function creates/finds the category with the given name and adds it as a
      * category for this feature to pass up to, similar to the parent
      * Categories should always be added before features
+     *
      * @param name
      */
     public void addCategory(String name) {
+        if(name.isEmpty()) return;
         addFeature(name); //first add as feature since every category is also a feature
         Features categoryFeature = parent.getCategory(name);
         categories.add(categoryFeature);
     }
+
     public void addFeature(String name) {
         addFeature(name, true);
     }
+
     public void addFeature(String name, boolean callParent) {
+        if(name.isEmpty()) return;
         //usually add feature to parent/categories
-        if(parent != null && callParent) {
+        if (parent != null && callParent && passToParent) {
             parent.addFeature(name);
-            for(Features c : categories) {
+            for (Features c : categories) {
                 c.addFeature(name);
             }
         }
 
-        if(features.containsKey(name)) {//has feature
-            int count = occurrences.get(name)+1;
+        if (features.containsKey(name)) { //has feature
+            int count = occurrences.get(name) + 1;
             occurrences.put(name, count);
-            if(features.get(name).containsKey(count)) {//already contains feature at this count
-                if(printOldFeatures) System.out.printf("Index %d is already reserved for feature %s at %d times in %s\n", features.get(name).get(count), name, count, featureName);
-            } else {//contains feature but different count
-                features.get(name).put(count, StateEncoder.indexCount++);
-                if(printNewFeatures) System.out.printf("Feature %s exists but has not occurred %d times, reserving index %d for the %d occurrence of this feature in %s\n",
-                        name, count, StateEncoder.indexCount-1, count, featureName);
+            if (features.get(name).containsKey(count)) { //already contains feature at this count
+                if (printOldFeatures)
+                    System.out.printf("Index %d is already reserved for feature %s at %d times in %s\n", features.get(name).get(count), name, count, featureName);
+            } else { //contains feature but different count
+                features.get(name).put(count, localIndexCount.getAndIncrement()); //  FIXED: Use atomic increment
+                if (printNewFeatures)
+                    System.out.printf("Feature %s exists but has not occurred %d times, reserving index %d for the %d occurrence of this feature in %s\n",
+                            name, count, localIndexCount.get() - 1, count, featureName);
             }
-        } else {//completely new feature
+        } else { //completely new feature
             occurrences.put(name, 1);
             Map<Integer, Integer> n = new HashMap<>();
-            n.put(1, StateEncoder.indexCount++);
+            n.put(1, localIndexCount.getAndIncrement());
             features.put(name, n);
-            if(printNewFeatures) System.out.printf("New feature %s discovered in %s, reserving index %d for this feature\n", name, featureName, n.get(1));
+            if (printNewFeatures)
+                System.out.printf("New feature %s discovered in %s, reserving index %d for this feature\n", name, featureName, n.get(1));
         }
-        StateEncoder.featureVector[features.get(name).get(occurrences.get(name))] = true;
+        encoder.featureVector.add(features.get(name).get(occurrences.get(name)));
     }
+
     public void addNumericFeature(String name, int num) {
         addNumericFeature(name, num, true);
     }
+
     public void addNumericFeature(String name, int num, boolean callParent) {
+        if(name.isEmpty()) return;
         //usually add feature to parent/categories
-        if(parent != null && callParent) {
+        if (parent != null && callParent && passToParent) {
             parent.addNumericFeature(name, num);
-            //keep track of numerical sum for parents
-            for(int i = 0; i < num; i++) {
-                parent.addFeature(name + "_SUM", false);
-            }
-            for(Features c : categories) {
-                c.addFeature(name);
-                //keep track of numerical sum for categories
-                for(int i = 0; i < num; i++) {
-                    c.addFeature(name + "_SUM", false);
-                }
-            }
         }
 
         //also adds copy to number right below this one which will recursively increment the occurrences of each lesser feature
         //Integer nextHighest = numericFeatures.get(name).floorKey(num-1);
-        if(num > 0) addNumericFeature(name, num-1, false);
+        if (num > 0) addNumericFeature(name, num - 1, false);
 
-        if(numericFeatures.containsKey(name)) {
-
-            if(numericFeatures.get(name).containsKey(num)) {
-                int count = numericOccurrences.get(name).get(num)+1;
+        if (numericFeatures.containsKey(name)) {
+            if (numericFeatures.get(name).containsKey(num)) {
+                int count = numericOccurrences.get(name).get(num) + 1;
                 numericOccurrences.get(name).put(num, count);
 
-                if(numericFeatures.get(name).get(num).containsKey(count)) {//already contains feature at this count
-                    if(printOldFeatures) System.out.printf("Index %d is already reserved for numeric feature %s with %d at %d times in %s\n", numericFeatures.get(name).get(num).get(count), name, num, count, featureName);
-                } else {//contains feature and num but different count
-                    numericFeatures.get(name).get(num).put(count, StateEncoder.indexCount++);
-                    if(printNewFeatures) System.out.printf("Numeric feature %s with %d exists but has not occurred %d times, reserving index %d for the %d occurrence of this feature in %s\n",
-                            name, num, count, StateEncoder.indexCount-1, count, featureName);
+                if (numericFeatures.get(name).get(num).containsKey(count)) { //already contains feature at this count
+                    if (printOldFeatures)
+                        System.out.printf("Index %d is already reserved for numeric feature %s with %d at %d times in %s\n", numericFeatures.get(name).get(num).get(count), name, num, count, featureName);
+                } else { //contains feature and num but different count
+                    numericFeatures.get(name).get(num).put(count, localIndexCount.getAndIncrement());
+                    if (printNewFeatures)
+                        System.out.printf("Numeric feature %s with %d exists but has not occurred %d times, reserving index %d for the %d occurrence of this feature in %s\n",
+                                name, num, count, localIndexCount.get() - 1, count, featureName);
                 }
             } else { //contains category but not this number
                 Map<Integer, Map<Integer, Integer>> map = numericFeatures.get(name);
                 Map<Integer, Integer> subMap = new HashMap<>();
-                subMap.put(1, StateEncoder.indexCount++);
+                subMap.put(1, localIndexCount.getAndIncrement());
                 map.put(num, subMap);
                 numericOccurrences.get(name).put(num, 1);
-                if(printNewFeatures) System.out.printf("Numeric feature %s exists but has not occurred with %d, reserving index %d for this feature at %d in %s\n",
-                        name, num, StateEncoder.indexCount-1, num, featureName);
+                if (printNewFeatures)
+                    System.out.printf("Numeric feature %s exists but has not occurred with %d, reserving index %d for this feature at %d in %s\n",
+                            name, num, localIndexCount.get() - 1, num, featureName);
             }
-        } else {//completely new feature category
+        } else { //completely new feature category
             TreeMap<Integer, Map<Integer, Integer>> newMap = new TreeMap<>();
             Map<Integer, Integer> subMap = new HashMap<>();
-            subMap.put(1, StateEncoder.indexCount++);
+            subMap.put(1, localIndexCount.getAndIncrement());
             newMap.put(num, subMap);
             numericFeatures.put(name, newMap);
             TreeMap<Integer, Integer> newTreeMap = new TreeMap<>();
             newTreeMap.put(num, 1);
             numericOccurrences.put(name, newTreeMap);
-            if(printNewFeatures) System.out.printf("New numeric feature %s discovered with %d in %s, reserving index %d for this feature at %d\n", name,
-                    num, featureName, StateEncoder.indexCount-1, num);
+            if (printNewFeatures)
+                System.out.printf("New numeric feature %s discovered with %d in %s, reserving index %d for this feature at %d\n", name,
+                        num, featureName, localIndexCount.get() - 1, num);
         }
-        StateEncoder.featureVector[numericFeatures.get(name).get(num).get(numericOccurrences.get(name).get(num))] = true;
+        encoder.featureVector.add(numericFeatures.get(name).get(num).get(numericOccurrences.get(name).get(num)));
     }
+
     public void stateRefresh() {
         categories.clear();
         occurrences.replaceAll((k, v) -> 0);
-        for(String c : numericOccurrences.keySet()) {
+        for (String c : numericOccurrences.keySet()) {
             numericOccurrences.get(c).replaceAll((k, v) -> 0);
         }
-        for(String n : subFeatures.keySet()) {
-            for(int i : subFeatures.get(n).keySet()) {
+        for (String n : subFeatures.keySet()) {
+            for (int i : subFeatures.get(n).keySet()) {
                 subFeatures.get(n).get(i).stateRefresh();
             }
         }
@@ -211,6 +258,164 @@ public class Features  implements Serializable {
         }
     }
 
+    /**
+     * always discard f after merging
+     *
+     * @param f object to merge with
+     */
+    public synchronized void merge(Features f) {
+        if (this == f) return;
+
+        // Normal features
+        for (String n : f.features.keySet()) {
+            Map<Integer, Integer> thisOccurrenceMap = this.features.computeIfAbsent(n, k -> new HashMap<>());
+            this.occurrences.putIfAbsent(n, 0);
+            for (int i : f.features.get(n).keySet()) {
+                if (!thisOccurrenceMap.containsKey(i)) {
+                    thisOccurrenceMap.put(i, this.localIndexCount.getAndIncrement());
+                }
+            }
+        }
+
+        // Numeric features
+        for (String n : f.numericFeatures.keySet()) {
+            TreeMap<Integer, Map<Integer, Integer>> thisNumericMap = this.numericFeatures.computeIfAbsent(n, k -> new TreeMap<>());
+            this.numericOccurrences.putIfAbsent(n, new TreeMap<>());
+            for (int num : f.numericFeatures.get(n).keySet()) {
+                Map<Integer, Integer> thisOccurrenceMap = thisNumericMap.computeIfAbsent(num, k -> new HashMap<>());
+                this.numericOccurrences.get(n).putIfAbsent(num, 0);
+                for (int i  : f.numericFeatures.get(n).get(num).keySet()) {
+                    if (!thisOccurrenceMap.containsKey(i)) {
+                        thisOccurrenceMap.put(i, this.localIndexCount.getAndIncrement());
+                    }
+                }
+            }
+        }
+        //subfeatures
+        for (String n : f.subFeatures.keySet()) {
+            Map<Integer, Features> thisSubMap = this.subFeatures.computeIfAbsent(n, k -> new HashMap<>());
+            for (int i : f.subFeatures.get(n).keySet()) {
+                Features thisSubFeature = thisSubMap.computeIfAbsent(i, k -> new Features(this, n + "_" + i));
+                thisSubFeature.merge(f.subFeatures.get(n).get(i));
+            }
+        }
+        //category labels
+        for (String n : f.categoriesForChildren.keySet()) {
+            if (!this.categoriesForChildren.containsKey(n)) {
+                this.categoriesForChildren.put(n, this.getCategory(n));
+            }
+            this.categoriesForChildren.get(n).merge(f.categoriesForChildren.get(n));
+        }
+    }
+    /**
+     * Creates a synchronized, deep copy of this Features object.
+     * By being synchronized, it ensures we get a clean snapshot and never
+     * copy the object while another thread is in the middle of merging.
+     * @return A new, completely independent deep copy of this object.
+     */
+    public synchronized Features createDeepCopy() {
+        try {
+            ByteArrayOutputStream byteOutput = new ByteArrayOutputStream();
+            ObjectOutputStream objectOutput = new ObjectOutputStream(byteOutput);
+            objectOutput.writeObject(this);
+            objectOutput.close();
+
+            ByteArrayInputStream byteInput = new ByteArrayInputStream(byteOutput.toByteArray());
+            ObjectInputStream objectInput = new ObjectInputStream(byteInput);
+            Features copy = (Features) objectInput.readObject();
+            objectInput.close();
+
+            return copy;
+        } catch (IOException | ClassNotFoundException e) {
+            throw new RuntimeException("Failed to create a deep copy of the Features object.", e);
+        }
+    }
+    /**
+     * Prints the entire feature tree, hiding features on the ignore list by default.
+     */
+    public void printFeatureTree() {
+        // Default behavior: do not print ignored features.
+        printFeatureTree(false);
+    }
+
+    /**
+     * Prints the entire feature tree in a hierarchical format.
+     *
+     * @param showIgnored If true, all features will be printed. If false, features
+     * whose indices are in the ignoreList will not be printed.
+     */
+    public void printFeatureTree(boolean showIgnored) {
+        // Start the recursion, passing the root's ignoreList down the tree.
+        printTreeRecursive(this.featureName, showIgnored, this.ignoreList);
+    }
+
+    /**
+     * Helper function to recursively traverse and print the feature tree.
+     *
+     * @param prefix        The current hierarchical path of the feature.
+     * @param showIgnored   If false, features on the ignore list are skipped.
+     * @param masterIgnoreList The single ignoreList from the root object to check against.
+     */
+    private void printTreeRecursive(String prefix, boolean showIgnored, Set<Integer> masterIgnoreList) {
+        // The conditional check for printing.
+        final boolean shouldPrintAll = showIgnored;
+
+        // Print the direct "leaf" features of the current node
+        if (this.features != null) {
+            for (Map.Entry<String, Map<Integer, Integer>> featureEntry : this.features.entrySet()) {
+                String featureName = featureEntry.getKey();
+                Map<Integer, Integer> occurrenceMap = featureEntry.getValue();
+                for (Map.Entry<Integer, Integer> occurrenceEntry : occurrenceMap.entrySet()) {
+                    Integer occurrence = occurrenceEntry.getKey();
+                    Integer index = occurrenceEntry.getValue();
+                    if (shouldPrintAll || !masterIgnoreList.contains(index)) {
+                        System.out.println(prefix + "/" + featureName + "/" + occurrence + "=>" + index);
+                    }
+                }
+            }
+        }
+
+        // Print the direct numeric "leaf" features of the current node
+        if (this.numericFeatures != null) {
+            for (Map.Entry<String, TreeMap<Integer, Map<Integer, Integer>>> numericEntry : this.numericFeatures.entrySet()) {
+                String featureName = numericEntry.getKey();
+                for (Map.Entry<Integer, Map<Integer, Integer>> valueEntry : numericEntry.getValue().entrySet()) {
+                    int numValue = valueEntry.getKey();
+                    for (Map.Entry<Integer, Integer> occurrenceEntry : valueEntry.getValue().entrySet()) {
+                        Integer occurrence = occurrenceEntry.getKey();
+                        Integer index = occurrenceEntry.getValue();
+                        if (shouldPrintAll || !masterIgnoreList.contains(index)) {
+                            System.out.println(prefix + "/" + featureName + "_val" + numValue + "/" + occurrence + "=>" + index);
+                        }
+                    }
+                }
+            }
+        }
+
+        // Recurse into sub-features, passing the master list along
+        if (this.subFeatures != null) {
+            for (Map.Entry<String, Map<Integer, Features>> subEntry : this.subFeatures.entrySet()) {
+                String subFeatureName = subEntry.getKey();
+                Map<Integer, Features> occurrenceMap = subEntry.getValue();
+                for (Map.Entry<Integer, Features> occurrenceEntry : occurrenceMap.entrySet()) {
+                    Integer occurrence = occurrenceEntry.getKey();
+                    Features subFeatureInstance = occurrenceEntry.getValue();
+                    String newPrefix = prefix + "/" + subFeatureName + "/" + occurrence;
+                    subFeatureInstance.printTreeRecursive(newPrefix, showIgnored, masterIgnoreList);
+                }
+            }
+        }
+
+        // Recurse into categories, passing the master list along
+        if (this.categoriesForChildren != null) {
+            for (Map.Entry<String, Features> categoryEntry : this.categoriesForChildren.entrySet()) {
+                String categoryName = categoryEntry.getKey();
+                Features categoryFeature = categoryEntry.getValue();
+                String newPrefix = prefix + "/" + categoryName;
+                categoryFeature.printTreeRecursive(newPrefix, showIgnored, masterIgnoreList);
+            }
+        }
+    }
     // Helper method to persist the Features mapping to a file
     public void saveMapping(String filename) throws IOException {
         try (ObjectOutputStream oos = new ObjectOutputStream(Files.newOutputStream(Paths.get(filename)))) {
@@ -224,4 +429,4 @@ public class Features  implements Serializable {
             return (Features) ois.readObject();
         }
     }
-}
+}
\ No newline at end of file
diff --git a/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/Features2.java b/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/Features2.java
deleted file mode 100644
index 58a46e6f10..0000000000
--- a/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/Features2.java
+++ /dev/null
@@ -1,58 +0,0 @@
-package mage.player.ai;
-
-import com.j256.ormlite.stmt.query.In;
-
-import java.util.HashMap;
-import java.util.Map;
-import java.util.Set;
-
-public class Features2 {
-    private Map<Class<?>, Map<Class<?>, Map<Integer, Integer>>> globalFeatureMapping;
-    private Map<Class<?>, Integer> vectorLengths;
-    private Map<Class<?>, Integer> occurances;
-    public Features2() {
-        //constructor
-        vectorLengths = new HashMap<>();
-        globalFeatureMapping = new HashMap<>();
-        occurances = new HashMap<>();
-    }
-    public int getIndexOfFeature(Class<?> c, Class<?> parent) {
-        int count = occurances.get(c);
-        return globalFeatureMapping.get(parent).get(c).get(count);
-    }
-    public void addFeatureMapping(Class<?> c, Class<?> parent) {
-        if(globalFeatureMapping.containsKey(parent)) {//has feature
-            Map<Class<?>, Map<Integer, Integer>> features = globalFeatureMapping.get(parent);
-            if(features.containsKey(c)) {//has feature
-                int count = occurances.get(c)+1;
-                occurances.put(c, count);
-                if(features.get(c).containsKey(count)) {//already contains feature
-                    return;
-                } else {//contains feature but different count
-                    Integer i = vectorLengths.get(parent);
-                    i++;
-                    features.get(c).put(count, i);
-                }
-            } else {//completely new feature
-                occurances.put(c, 1);
-                Map<Integer, Integer> n = new HashMap<>();
-                Integer i = vectorLengths.get(parent);
-                i++;
-                n.put(1, i);
-                features.put(c, n);
-            }
-        } else {//completely new feature category
-            Map<Class<?>, Map<Integer, Integer>> newMapping = new HashMap<>();
-            Map<Integer, Integer> subMapping = new HashMap<>();
-            subMapping.put(1, 0);
-            vectorLengths.put(parent, 0);
-            newMapping.put(c, subMapping);
-            globalFeatureMapping.put(parent, newMapping);
-        }
-    }
-
-    public void resetOccurances() {
-        occurances.replaceAll((c, v) -> 0);
-
-    }
-}
diff --git a/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/GameStateGraphNode.java b/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/GameStateGraphNode.java
deleted file mode 100644
index 01cb77e0c7..0000000000
--- a/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/GameStateGraphNode.java
+++ /dev/null
@@ -1,371 +0,0 @@
-package mage.player.ai;
-
-
-import mage.game.permanent.Battlefield;
-
-import java.util.*;
-/**
- * Node for the Game state graph which is the main engine behind state evaluation.
- * The game state graph is a massive Hasse Diagram containing all relevant set intersections between provided game states
- * this graph is weighted in tuned to produce deck-specific evaluation scores
- *
- * @author willwroble
- */
-public class GameStateGraphNode implements Comparable{
-
-
-    private Battlefield battlefield;
-
-
-    GameStateGraphNode opponentNode;
-    private HashedZone cardsStack = new HashedZone();
-    public HashedZone cardsHand = new HashedZone();
-    public HashedZone cardsBattleField = new HashedZone();
-    public HashedZone cardsGraveyard = new HashedZone();
-    private HashedZone cardsExile = new HashedZone();
-    private HashedZone cardsLibrary = new HashedZone();
-    private final Map<GameStateGraphNode, Float> parents = new HashMap<>();
-    private final Set<GameStateGraphNode> parentsShouldNotCompare = new HashSet<>();
-    
-
-    private final Map<GameStateGraphNode, Float> children = new HashMap<GameStateGraphNode, Float>();
-    public static GameStateGraphNode ROOT;
-   
-
-
-    private int lifeTotal = 0;
-    private int numParents = 0;
-    private int numChildren = 0;
-
-    public GameStateGraphNode() {
-        cardsBattleField = new HashedZone();
-        cardsHand = new HashedZone();
-        cardsGraveyard = new HashedZone();
-        cardsLibrary = new HashedZone();
-        cardsExile = new HashedZone();
-        cardsStack = new HashedZone();
-        opponentNode = null;
-        lifeTotal = 0;
-        parentsShouldNotCompare.add(this);
-    }
-    public GameStateGraphNode(HashedZone stack, HashedZone hand, HashedZone battlefield, HashedZone graveyard,
-                       HashedZone exile, HashedZone library, int life, GameStateGraphNode opponent) {
-        cardsStack = stack;
-        cardsHand = hand;
-        cardsBattleField = battlefield;
-        cardsGraveyard = graveyard;
-        cardsExile = exile;
-        cardsLibrary = library;
-        opponentNode = opponent;
-        lifeTotal = life;
-        parentsShouldNotCompare.add(this);
-
-    }
-    public static GameStateGraphNode GetLargestSharedSubset(GameStateGraphNode A, GameStateGraphNode B) {
-        HashedZone sharedBattleField = HashedZone.getIntersection(A.cardsBattleField, B.cardsBattleField);
-        HashedZone sharedHand = HashedZone.getIntersection(A.cardsHand, B.cardsHand);
-        HashedZone sharedGraveyard = HashedZone.getIntersection(A.cardsGraveyard, B.cardsGraveyard);
-        HashedZone sharedLibrary = HashedZone.getIntersection(A.cardsLibrary, B.cardsLibrary);
-        HashedZone sharedExile = HashedZone.getIntersection(A.cardsExile, B.cardsExile);
-        HashedZone sharedStack = HashedZone.getIntersection(A.cardsStack, B.cardsStack);
-
-        int lowestLife = Math.min(A.lifeTotal, B.lifeTotal);
-        /*
-        HashedZone opponentCombinedBattlefield = new HashedZone(A.opponentNode.cardsBattleField);
-        opponentCombinedBattlefield.addAll(B.opponentNode.cardsBattleField);
-        HashedZone opponentCombinedHand = new HashedZone(A.opponentNode.cardsHand);
-        opponentCombinedHand.addAll(B.opponentNode.cardsHand);
-        HashedZone opponentCombinedLibrary = new HashedZone(A.opponentNode.cardsLibrary);
-        opponentCombinedLibrary.addAll(B.opponentNode.cardsLibrary);
-        HashedZone opponentCombinedExile = new HashedZone(A.opponentNode.cardsExile);
-        opponentCombinedExile.addAll(B.opponentNode.cardsExile);
-        HashedZone opponentCombinedGraveyard = new HashedZone(A.opponentNode.cardsGraveyard);
-        opponentCombinedGraveyard.addAll(B.opponentNode.cardsGraveyard);
-        HashedZone opponentCombinedStack = new HashedZone(A.opponentNode.cardsStack);
-        opponentCombinedStack.addAll(B.opponentNode.cardsStack);
-        int opMaxLife = Math.max(A.opponentNode.lifeTotal, B.opponentNode.lifeTotal);
-        */
-        return new GameStateGraphNode(sharedStack, sharedHand, sharedBattleField, sharedGraveyard, sharedExile, sharedLibrary, lowestLife, null);
-        //newNode.opponentNode = new GameStateGraphNode(opponentCombinedStack, opponentCombinedHand,
-        //        opponentCombinedBattlefield, opponentCombinedGraveyard, opponentCombinedExile, opponentCombinedLibrary, opMaxLife, newNode);
-        //return newNode;
-
-    }
-    @Override
-    public boolean equals(Object obj) {
-        if(obj.getClass() == GameStateGraphNode.class) {
-            return equals((GameStateGraphNode) obj);
-        }
-        return super.equals(obj);
-    }
-
-    @Override
-    public int hashCode() {
-        return cardsBattleField.hashCode()+cardsGraveyard.hashCode()
-                +cardsHand.hashCode()+cardsExile.hashCode()+cardsStack.hashCode()+cardsLibrary.hashCode();
-    }
-
-    boolean equals(GameStateGraphNode node) {
-        return (cardsBattleField.equals(node.cardsBattleField) &&
-                cardsGraveyard.equals(node.cardsGraveyard) &&
-                cardsHand.equals(node.cardsHand) &&
-                cardsLibrary.equals(node.cardsLibrary) &&
-                cardsExile.equals(node.cardsExile) &&
-                cardsStack.equals(node.cardsStack) &&
-                lifeTotal == node.lifeTotal);
-                //opponentNode.equals(node.opponentNode));
-    }
-    public static GameStateGraphNode quickMakeGraphNode(List<String> names) {
-        GameStateGraphNode newNode = new GameStateGraphNode();
-        for(String name : names) {
-            CardState newState = new CardState(name);
-            newNode.cardsBattleField.addCardState(newState);
-        }
-        return newNode;
-    }
-    /**this = root
-     * @param node node to look for
-     * @return reference to matching node if found, null otherwise
-     */
-    public GameStateGraphNode contains(GameStateGraphNode node) {
-        if(!node.isDescendentOf(this)) {
-            return null;
-        }
-        if(this.equals(node)) {
-            return this;
-        }
-        for(GameStateGraphNode child : children.keySet()) {
-            GameStateGraphNode out = child.contains(node);
-            if(out != null) {
-                return out;
-            }
-        }
-        return null;
-    }
-
-    /**
-     * returns true if this node is a descendent of the given node (A node is a descendent of itself)
-     * @param node
-     * @return
-     */
-    public boolean isDescendentOf(GameStateGraphNode node) {
-        return cardsBattleField.containsAll(node.cardsBattleField) &&
-                cardsHand.containsAll(node.cardsHand) &&
-                cardsGraveyard.containsAll(node.cardsGraveyard) &&
-                cardsLibrary.containsAll(node.cardsLibrary) &&
-                cardsExile.containsAll(node.cardsExile) &&
-                cardsStack.containsAll(node.cardsStack);
-    }
-    void addChild(GameStateGraphNode child, Float weight) {
-
-        child.parents.put(this, weight);
-        children.put(child, weight);
-    }
-    void addChildSafe(GameStateGraphNode child, Float weight) {
-        if(this.contains(child) != null) {//make sure it isn't already connected via children
-            return;
-        }
-        Set<GameStateGraphNode> childrenOfParent = new HashSet<>(this.children.keySet());
-        for (GameStateGraphNode childOfParent : childrenOfParent) {
-            if (childOfParent.isDescendentOf(child)) {
-                this.removeChild(childOfParent);
-            }
-        }
-        Set<GameStateGraphNode> parentsOfChild = new HashSet<>(child.parents.keySet());
-        for (GameStateGraphNode parentOfChild : parentsOfChild) {
-            if (this.isDescendentOf(parentOfChild)) {
-                parentOfChild.removeChild(child);
-            }
-        }
-        addChild(child, weight);
-    }
-    void addParentAbove(GameStateGraphNode parent, Float weight) {//check parent's children
-        if(parent.contains(this) != null) {//make sure it isn't already connected via children
-            return;
-        }
-        Set<GameStateGraphNode> children = new HashSet<>(parent.children.keySet());
-        for (GameStateGraphNode child : children) {
-            if (child.isDescendentOf(this)) {
-                parent.removeChild(child);
-                //this.addChild(child, 1f);
-            }
-        }
-        parent.addChild(this, weight);
-    }
-    void addChildBelow(GameStateGraphNode child, Float weight) {//check child's parents
-        Set<GameStateGraphNode> parents = new HashSet<>(child.parents.keySet());
-        for (GameStateGraphNode parent : parents) {
-            if (this.isDescendentOf(parent)) {
-                parent.removeChild(child);
-                //parent.addChild(this, 1f);
-            }
-        }
-        this.addChild(child, weight);
-    }
-    void removeChild(GameStateGraphNode child) {
-        this.children.remove(child);
-        child.parents.remove(this);
-    }
-    void removeChildren(Set<GameStateGraphNode> children) {
-        for(GameStateGraphNode child : children) {
-            removeChild(child);
-        }
-    }
-    void addChildren(Set<GameStateGraphNode> children, Float weight) {
-        for(GameStateGraphNode child : children) {
-            addChild(child, weight);
-        }
-    }
-    public void printGraph(int depth) {
-        System.out.printf("Node depth: %d Life total: %d\n", depth, lifeTotal);
-        printNode();
-        for(GameStateGraphNode c : children.keySet()) {
-            c.printGraph(depth+1);
-        }
-    }
-    public void printNode() {
-        System.out.printf("Battlefield: ");
-        for(Integer hash : cardsBattleField.getKeySet()) {
-            System.out.printf("%s ", cardsBattleField.getCardStatesByKey(hash).get(0).cardName);
-        }
-        System.out.printf("\nHand: \n");
-        for(Integer hash : cardsHand.getKeySet()) {
-            System.out.printf("%s ", cardsHand.getCardStatesByKey(hash).get(0).cardName);
-        }
-        System.out.printf("\n%d CHILDREN ===================================================\n\n", children.size());
-    }
-    /**
-     * Gets the most immediate children of the given parent that are ancestors of the given child
-     * @param child
-     * @param grandParent
-     * @param out
-     */
-    public void getOldestChildren(GameStateGraphNode child, GameStateGraphNode grandParent, Set<GameStateGraphNode> out) {
-        boolean isOldestChild = true;
-        for(GameStateGraphNode parent : child.parents.keySet()) {
-            if(parent.isDescendentOf(grandParent) && !parent.equals(grandParent)) {
-                getOldestChildren(parent, grandParent, out);
-                isOldestChild = false;
-            }
-        }
-        if(isOldestChild) {
-            out.add(child);
-        }
-    }
-    /**
-     * finds all leaf nodes in a graph where children of given parent node are removed
-     * @param root root of the graph to look for leaf node in
-     * @param out set that all found leaves are added to.
-     */
-    public static void getAllLeafNodes(GameStateGraphNode root, Set<GameStateGraphNode> out, Set<GameStateGraphNode> removedLeaves) {
-        boolean isLeaf = true;
-        for(GameStateGraphNode child : root.children.keySet()) {
-            if(!removedLeaves.contains(child)) {
-                getAllLeafNodes(child, out, removedLeaves);
-                isLeaf = false;
-            }
-        }
-        if(isLeaf) {
-            out.add(root);
-        }
-    }
-    public static void getRemovedLeavesFromChildren(GameStateGraphNode parent, Set<GameStateGraphNode> out) {
-        for(GameStateGraphNode child : parent.children.keySet()) {
-            getRemovedLeavesFromChildren(child, out);
-        }
-        out.addAll(parent.parentsShouldNotCompare);
-    }
-    public static GameStateGraphNode treeSearch(TreeSet<GameStateGraphNode> treeset, GameStateGraphNode key) {
-        GameStateGraphNode ceil  = treeset.ceiling(key); // least elt >= key
-        GameStateGraphNode floor = treeset.floor(key);   // highest elt <= key
-        return ceil == floor? ceil : null;
-    }
-    public void clearAllHistory() {
-        for(GameStateGraphNode child : children.keySet()) {
-            child.clearAllHistory();
-        }
-        parentsShouldNotCompare.clear();
-        parentsShouldNotCompare.add(this);
-    }
-    /**
-     * Heavily modifies state network to accommodate another leaf node. This process includes calculating
-     * intersections between every existing node and adding them to the graph
-     */
-    public void linkStateNode(GameStateGraphNode newNode) {
-        //this.clearAllHistory();
-
-        PriorityQueue<GameStateGraphNode> newNodes = new PriorityQueue<>();
-        this.addChild(newNode, 1f);
-        newNodes.add(newNode);
-        Set<GameStateGraphNode> newlyGenerated = new HashSet<>();
-        //new nodes should be sorted so children go before parents
-        while ((newNode = newNodes.poll()) != null) {
-            //System.out.println(newNodes.size());
-            Set<GameStateGraphNode> leaves = new HashSet<>();
-
-            Set<GameStateGraphNode> allRemoved = new HashSet<>();
-            getRemovedLeavesFromChildren(newNode, allRemoved);
-            allRemoved.addAll(newlyGenerated);
-
-            getAllLeafNodes(this, leaves, allRemoved);
-
-            for(GameStateGraphNode leaf : leaves) {
-                assert (newNode != leaf);
-
-                GameStateGraphNode sharedNode = GetLargestSharedSubset(leaf, newNode);
-                GameStateGraphNode foundNode = this.contains(sharedNode);
-                if (foundNode != null) {
-                    //link to an existing node
-                    foundNode.addChildSafe(newNode, 1f);
-                    foundNode.addChildSafe(leaf, 1f);
-
-                } else {
-                    //new node cannot possibly already be in the queue by this point (or it would have been found on the graph)
-                    newNodes.add(sharedNode);
-                    sharedNode.addChildSafe(leaf, 1f);
-                    sharedNode.addChildSafe(newNode, 1f);
-                    //link to root temporarily, so it can be found by the leaf retriever
-                    this.addChild(sharedNode, 1f);
-                    //new internodes derived from the same newnode don't need to compare to each other
-                    newlyGenerated.add(sharedNode);
-                }
-                if (!newNode.isDescendentOf(leaf)) { //don't ignore the leaf if it is equal to the comparison's shared set and vice versa(leaf is parent)
-                    newNode.parentsShouldNotCompare.add(leaf);
-                }
-                if(!leaf.isDescendentOf(newNode)) {
-                    leaf.parentsShouldNotCompare.add(newNode);
-                }
-            }
-        }
-    }
-    public static void validateGraph(GameStateGraphNode root, Set<GameStateGraphNode> sourceLeaves) {
-        PriorityQueue<GameStateGraphNode> allNodes = new PriorityQueue<>(sourceLeaves);
-        assert (allNodes.size() == sourceLeaves.size());
-        Set<GameStateGraphNode> out = new HashSet<>(sourceLeaves);
-        GameStateGraphNode first;
-        while((first = allNodes.poll()) != null) {
-            Set<GameStateGraphNode> leaves = new HashSet<>(allNodes);
-            for(GameStateGraphNode leaf : leaves) {
-                GameStateGraphNode sharedNode = GetLargestSharedSubset(first, leaf);
-                if(!out.contains(sharedNode)) {
-                    allNodes.add(sharedNode);
-                    out.add(sharedNode);
-                }
-            }
-        }
-        for(GameStateGraphNode n : out) {
-            n.printNode();
-        }
-    }
-    @Override
-    public int compareTo(Object o) {
-        GameStateGraphNode o2 = (GameStateGraphNode)o;
-        GameStateGraphNode o1 = this;
-        if(o1.isDescendentOf(o2)) {
-            return -1;
-        } else if(o2.isDescendentOf(o1)) {
-            return 1;
-        }
-        return 0;
-    }
-}
diff --git a/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/HashedZone.java b/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/HashedZone.java
deleted file mode 100644
index a4050121d3..0000000000
--- a/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/HashedZone.java
+++ /dev/null
@@ -1,98 +0,0 @@
-package mage.player.ai;
-
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Set;
-
-public class HashedZone {
-    private final HashMap<Integer, List<CardState>> model;
-    public static HashedZone getIntersection(HashedZone a, HashedZone b) {
-        HashedZone out = new HashedZone();
-        for(Integer hash : a.getKeySet()) {
-            List<CardState> v2 = b.getCardStatesByKey(hash);
-            if(v2 == null) continue;
-            List<CardState> v1 = a.getCardStatesByKey(hash);
-            if(v1.size() == 1 && v2.size() == 1) {
-                out.model.put(hash, new ArrayList<>(v1));
-                continue;
-            }
-            out.model.put(hash, CardState.bestPairing(v1, v2));
-        }
-        return out;
-    }
-    public HashedZone() {
-        model = new HashMap<>();
-    }
-
-    public boolean equals(HashedZone z) {
-        //return model.equals(z.model);
-        return (model.keySet().equals(z.model.keySet()));
-    }
-
-    @Override
-    public int hashCode() {
-        return model.hashCode();
-    }
-
-    public HashedZone(HashedZone zone) {
-        model = new HashMap<>(zone.model);
-    }
-    public Set<Integer> getKeySet() {
-        return model.keySet();
-    }
-    public List<CardState> getCardStatesByKey(Integer key) {
-        return model.get(key);
-    }
-    public void addCardState(CardState cardState) {
-        Integer key = cardState.hashCode();
-        if(model.containsKey(key)) {
-            model.get(key).add(cardState);
-        } else {
-            model.put(key, new ArrayList<>());
-            model.get(key).add(cardState);
-        }
-    }
-    public boolean containsAll(HashedZone z) {
-        if(z.model.isEmpty()) {
-            return true;
-        }
-        //return getKeySet().containsAll(z.getKeySet());
-
-        for(Integer hash : z.getKeySet()) {
-            List<CardState> v1 = model.get(hash);
-            if(v1 == null) return false;
-            List<CardState> v2 = z.model.get(hash);
-            if(v1.size() < v2.size()) return false;
-
-            if(v1.size() == 1 && v2.size() == 1) {
-                if(v1.get(0).isChildOf(v2.get(0))) {
-                    continue;
-                }
-            }
-
-            double[][] costs = new double[v1.size()][v2.size()];
-            for(int i = 0; i< v1.size(); i++) {
-                for(int j = 0; j < v2.size(); j++) {
-                    if(v1.get(i).isChildOf(v2.get(j))) {
-                        costs[i][j] = 0;
-                    } else {
-                        costs[i][j] = 1;
-                    }
-                }
-            }
-            HungarianAlgorithm ha = new HungarianAlgorithm(costs);
-            int[] pairing = ha.execute();
-            double totalCost = 0;
-            for(int i = 0; i<pairing.length; i++) {
-                if(pairing[i] > 0) {
-                    totalCost += costs[i][pairing[i]];
-                }
-            }
-            if(totalCost > 0) {
-                return false;
-            }
-        }
-        return true;
-    }
-}
diff --git a/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/HungarianAlgorithm.java b/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/HungarianAlgorithm.java
deleted file mode 100644
index 6dd95f1fdc..0000000000
--- a/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/HungarianAlgorithm.java
+++ /dev/null
@@ -1,338 +0,0 @@
-
-package mage.player.ai;
-
-import java.util.Arrays;
-
-/* Copyright (c) 2012 Kevin L. Stern
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to deal
- * in the Software without restriction, including without limitation the rights
- * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
- * copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
- * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
- * SOFTWARE.
- */
-
-/**
- * An implementation of the Hungarian algorithm for solving the assignment
- * problem. An instance of the assignment problem consists of a number of
- * workers along with a number of jobs and a cost matrix which gives the cost of
- * assigning the i'th worker to the j'th job at position (i, j). The goal is to
- * find an assignment of workers to jobs so that no job is assigned more than
- * one worker and so that no worker is assigned to more than one job in such a
- * manner so as to minimize the total cost of completing the jobs.
- * <p>
- *
- * An assignment for a cost matrix that has more workers than jobs will
- * necessarily include unassigned workers, indicated by an assignment value of
- * -1; in no other circumstance will there be unassigned workers. Similarly, an
- * assignment for a cost matrix that has more jobs than workers will necessarily
- * include unassigned jobs; in no other circumstance will there be unassigned
- * jobs. For completeness, an assignment for a square cost matrix will give
- * exactly one unique worker to each job.
- * <p>
- *
- * This version of the Hungarian algorithm runs in time O(n^3), where n is the
- * maximum among the number of workers and the number of jobs.
- *
- * @author Kevin L. Stern
- */
-public class HungarianAlgorithm {
-    private final double[][] costMatrix;
-    private final int rows, cols, dim;
-    private final double[] labelByWorker, labelByJob;
-    private final int[] minSlackWorkerByJob;
-    private final double[] minSlackValueByJob;
-    private final int[] matchJobByWorker, matchWorkerByJob;
-    private final int[] parentWorkerByCommittedJob;
-    private final boolean[] committedWorkers;
-
-    /**
-     * Construct an instance of the algorithm.
-     *
-     * @param costMatrix
-     *          the cost matrix, where matrix[i][j] holds the cost of assigning
-     *          worker i to job j, for all i, j. The cost matrix must not be
-     *          irregular in the sense that all rows must be the same length; in
-     *          addition, all entries must be non-infinite numbers.
-     */
-    public HungarianAlgorithm(double[][] costMatrix) {
-        this.dim = Math.max(costMatrix.length, costMatrix[0].length);
-        this.rows = costMatrix.length;
-        this.cols = costMatrix[0].length;
-        this.costMatrix = new double[this.dim][this.dim];
-        for (int w = 0; w < this.dim; w++) {
-            if (w < costMatrix.length) {
-                if (costMatrix[w].length != this.cols) {
-                    throw new IllegalArgumentException("Irregular cost matrix");
-                }
-                for (int j = 0; j < this.cols; j++) {
-                    if (Double.isInfinite(costMatrix[w][j])) {
-                        throw new IllegalArgumentException("Infinite cost");
-                    }
-                    if (Double.isNaN(costMatrix[w][j])) {
-                        throw new IllegalArgumentException("NaN cost");
-                    }
-                }
-                this.costMatrix[w] = Arrays.copyOf(costMatrix[w], this.dim);
-            } else {
-                this.costMatrix[w] = new double[this.dim];
-            }
-        }
-        labelByWorker = new double[this.dim];
-        labelByJob = new double[this.dim];
-        minSlackWorkerByJob = new int[this.dim];
-        minSlackValueByJob = new double[this.dim];
-        committedWorkers = new boolean[this.dim];
-        parentWorkerByCommittedJob = new int[this.dim];
-        matchJobByWorker = new int[this.dim];
-        Arrays.fill(matchJobByWorker, -1);
-        matchWorkerByJob = new int[this.dim];
-        Arrays.fill(matchWorkerByJob, -1);
-    }
-
-    /**
-     * Compute an initial feasible solution by assigning zero labels to the
-     * workers and by assigning to each job a label equal to the minimum cost
-     * among its incident edges.
-     */
-    protected void computeInitialFeasibleSolution() {
-        for (int j = 0; j < dim; j++) {
-            labelByJob[j] = Double.POSITIVE_INFINITY;
-        }
-        for (int w = 0; w < dim; w++) {
-            for (int j = 0; j < dim; j++) {
-                if (costMatrix[w][j] < labelByJob[j]) {
-                    labelByJob[j] = costMatrix[w][j];
-                }
-            }
-        }
-    }
-
-    /**
-     * Execute the algorithm.
-     *
-     * @return the minimum cost matching of workers to jobs based upon the
-     *         provided cost matrix. A matching value of -1 indicates that the
-     *         corresponding worker is unassigned.
-     */
-    public int[] execute() {
-        /*
-         * Heuristics to improve performance: Reduce rows and columns by their
-         * smallest element, compute an initial non-zero dual feasible solution and
-         * create a greedy matching from workers to jobs of the cost matrix.
-         */
-        reduce();
-        computeInitialFeasibleSolution();
-        greedyMatch();
-
-        int w = fetchUnmatchedWorker();
-        while (w < dim) {
-            initializePhase(w);
-            executePhase();
-            w = fetchUnmatchedWorker();
-        }
-        int[] result = Arrays.copyOf(matchJobByWorker, rows);
-        for (w = 0; w < result.length; w++) {
-            if (result[w] >= cols) {
-                result[w] = -1;
-            }
-        }
-        return result;
-    }
-
-    /**
-     * Execute a single phase of the algorithm. A phase of the Hungarian algorithm
-     * consists of building a set of committed workers and a set of committed jobs
-     * from a root unmatched worker by following alternating unmatched/matched
-     * zero-slack edges. If an unmatched job is encountered, then an augmenting
-     * path has been found and the matching is grown. If the connected zero-slack
-     * edges have been exhausted, the labels of committed workers are increased by
-     * the minimum slack among committed workers and non-committed jobs to create
-     * more zero-slack edges (the labels of committed jobs are simultaneously
-     * decreased by the same amount in order to maintain a feasible labeling).
-     * <p>
-     *
-     * The runtime of a single phase of the algorithm is O(n^2), where n is the
-     * dimension of the internal square cost matrix, since each edge is visited at
-     * most once and since increasing the labeling is accomplished in time O(n) by
-     * maintaining the minimum slack values among non-committed jobs. When a phase
-     * completes, the matching will have increased in size.
-     */
-    protected void executePhase() {
-        while (true) {
-            int minSlackWorker = -1, minSlackJob = -1;
-            double minSlackValue = Double.POSITIVE_INFINITY;
-            for (int j = 0; j < dim; j++) {
-                if (parentWorkerByCommittedJob[j] == -1) {
-                    if (minSlackValueByJob[j] < minSlackValue) {
-                        minSlackValue = minSlackValueByJob[j];
-                        minSlackWorker = minSlackWorkerByJob[j];
-                        minSlackJob = j;
-                    }
-                }
-            }
-            if (minSlackValue > 0) {
-                updateLabeling(minSlackValue);
-            }
-            parentWorkerByCommittedJob[minSlackJob] = minSlackWorker;
-            if (matchWorkerByJob[minSlackJob] == -1) {
-                /*
-                 * An augmenting path has been found.
-                 */
-                int committedJob = minSlackJob;
-                int parentWorker = parentWorkerByCommittedJob[committedJob];
-                while (true) {
-                    int temp = matchJobByWorker[parentWorker];
-                    match(parentWorker, committedJob);
-                    committedJob = temp;
-                    if (committedJob == -1) {
-                        break;
-                    }
-                    parentWorker = parentWorkerByCommittedJob[committedJob];
-                }
-                return;
-            } else {
-                /*
-                 * Update slack values since we increased the size of the committed
-                 * workers set.
-                 */
-                int worker = matchWorkerByJob[minSlackJob];
-                committedWorkers[worker] = true;
-                for (int j = 0; j < dim; j++) {
-                    if (parentWorkerByCommittedJob[j] == -1) {
-                        double slack = costMatrix[worker][j] - labelByWorker[worker]
-                                - labelByJob[j];
-                        if (minSlackValueByJob[j] > slack) {
-                            minSlackValueByJob[j] = slack;
-                            minSlackWorkerByJob[j] = worker;
-                        }
-                    }
-                }
-            }
-        }
-    }
-
-    /**
-     *
-     * @return the first unmatched worker or {@link #dim} if none.
-     */
-    protected int fetchUnmatchedWorker() {
-        int w;
-        for (w = 0; w < dim; w++) {
-            if (matchJobByWorker[w] == -1) {
-                break;
-            }
-        }
-        return w;
-    }
-
-    /**
-     * Find a valid matching by greedily selecting among zero-cost matchings. This
-     * is a heuristic to jump-start the augmentation algorithm.
-     */
-    protected void greedyMatch() {
-        for (int w = 0; w < dim; w++) {
-            for (int j = 0; j < dim; j++) {
-                if (matchJobByWorker[w] == -1 && matchWorkerByJob[j] == -1
-                        && costMatrix[w][j] - labelByWorker[w] - labelByJob[j] == 0) {
-                    match(w, j);
-                }
-            }
-        }
-    }
-
-    /**
-     * Initialize the next phase of the algorithm by clearing the committed
-     * workers and jobs sets and by initializing the slack arrays to the values
-     * corresponding to the specified root worker.
-     *
-     * @param w
-     *          the worker at which to root the next phase.
-     */
-    protected void initializePhase(int w) {
-        Arrays.fill(committedWorkers, false);
-        Arrays.fill(parentWorkerByCommittedJob, -1);
-        committedWorkers[w] = true;
-        for (int j = 0; j < dim; j++) {
-            minSlackValueByJob[j] = costMatrix[w][j] - labelByWorker[w]
-                    - labelByJob[j];
-            minSlackWorkerByJob[j] = w;
-        }
-    }
-
-    /**
-     * Helper method to record a matching between worker w and job j.
-     */
-    protected void match(int w, int j) {
-        matchJobByWorker[w] = j;
-        matchWorkerByJob[j] = w;
-    }
-
-    /**
-     * Reduce the cost matrix by subtracting the smallest element of each row from
-     * all elements of the row as well as the smallest element of each column from
-     * all elements of the column. Note that an optimal assignment for a reduced
-     * cost matrix is optimal for the original cost matrix.
-     */
-    protected void reduce() {
-        for (int w = 0; w < dim; w++) {
-            double min = Double.POSITIVE_INFINITY;
-            for (int j = 0; j < dim; j++) {
-                if (costMatrix[w][j] < min) {
-                    min = costMatrix[w][j];
-                }
-            }
-            for (int j = 0; j < dim; j++) {
-                costMatrix[w][j] -= min;
-            }
-        }
-        double[] min = new double[dim];
-        for (int j = 0; j < dim; j++) {
-            min[j] = Double.POSITIVE_INFINITY;
-        }
-        for (int w = 0; w < dim; w++) {
-            for (int j = 0; j < dim; j++) {
-                if (costMatrix[w][j] < min[j]) {
-                    min[j] = costMatrix[w][j];
-                }
-            }
-        }
-        for (int w = 0; w < dim; w++) {
-            for (int j = 0; j < dim; j++) {
-                costMatrix[w][j] -= min[j];
-            }
-        }
-    }
-
-    /**
-     * Update labels with the specified slack by adding the slack value for
-     * committed workers and by subtracting the slack value for committed jobs. In
-     * addition, update the minimum slack values appropriately.
-     */
-    protected void updateLabeling(double slack) {
-        for (int w = 0; w < dim; w++) {
-            if (committedWorkers[w]) {
-                labelByWorker[w] += slack;
-            }
-        }
-        for (int j = 0; j < dim; j++) {
-            if (parentWorkerByCommittedJob[j] != -1) {
-                labelByJob[j] -= slack;
-            } else {
-                minSlackValueByJob[j] -= slack;
-            }
-        }
-    }
-}
diff --git a/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/LabeledState.java b/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/LabeledState.java
index 5ec4e76bd0..1a89d5a66b 100644
--- a/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/LabeledState.java
+++ b/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/LabeledState.java
@@ -1,17 +1,90 @@
 package mage.player.ai;
 
-import java.io.Serializable;
+import java.io.*;
+import java.util.BitSet;
+import java.util.HashSet;
+import java.util.Set;
 
+/**
+ * Represents a single training example: a bitset-encoded game state,
+ * an integer action index (one-hot), and a scalar result label.
+ */
 public class LabeledState implements Serializable {
-    public boolean[] stateVector;//state
-    public boolean[] actionVector;//policy
-    public double resultLabel;//win lose
+    private static final long serialVersionUID = 1L;
 
+    /** Bit-packed state vector of length S. */
+    public int[] stateVector;
+    /** Index of the chosen action (one-hot). */
+    public final double[] actionVector;
+    /** Value label (e.g., -1.0 for loss, +1.0 for win). */
+    public final double resultLabel;
 
 
-    public LabeledState(boolean[] sVector, boolean[] aVector, double label) {
-        this.stateVector = sVector;
-        this.actionVector = aVector;
+    /**
+     * Construct a labeled state.
+     * @param stateIndices  indices of active features
+     * @param actionVec    vec of the action distribution
+     * @param label        scalar outcome label
+     */
+    public LabeledState(Set<Integer> stateIndices, double[] actionVec, double label) {
+        // clone to ensure immutability
+        this.stateVector = stateIndices.stream()                       // 1. Get a Stream<Integer>
+                .mapToInt(Integer::intValue)    // 2. Convert to IntStream (unboxes Integer to int)
+                .toArray();
+        this.actionVector = actionVec;
         this.resultLabel = label;
     }
+    public void compress(StateEncoder encoder) {
+        stateVector = encoder.getCompressedVectorArray(stateVector);
+    }
+    public void compress(Set<Integer> ignoreList) {
+        stateVector = FeatureMerger.getCompressedVectorArray(ignoreList, stateVector);
+    }
+
+    /**
+     * Persist this labeled state to the given DataOutputStream.
+     * Caller must write header (record count, S, wordsPerState) before calling.
+     * @param out            DataOutputStream to write to
+     * @throws IOException   on I/O error
+     */
+    public void persist(DataOutputStream out) throws IOException {
+//        for (int j : stateVector) {
+//            if (j >= maxIndex) return; //dont persist a state with unfinalized features
+//        }
+        // 1) Write the NUMBER of active indices first.
+        out.writeInt(stateVector.length);
+
+        // 2) Write only the active indices themselves.
+        for (int index : stateVector) {
+            out.writeInt(index);
+        }
+        // --- The rest of the method remains the same ---
+        // 3) Write your action-distribution vector
+        for (double p : actionVector) {
+            out.writeDouble(p);
+        }
+        // 4) Write result label
+        out.writeDouble(resultLabel);
+    }
+    public void persist(DataOutputStream out, int mIndex) throws IOException {
+        // Convert the BitSet to an array of active indices
+        int count = 0;
+        for(int index : stateVector) {
+            if(index < mIndex) count++;
+        }
+        // 1) Write the NUMBER of active indices first.
+        out.writeInt(count);
+
+        // 2) Write only the active indices themselves.
+        for (int index : stateVector) {
+            if(index < mIndex) out.writeInt(index);
+        }
+        // --- The rest of the method remains the same ---
+        // 3) Write your action-distribution vector
+        for (double p : actionVector) {
+            out.writeDouble(p);
+        }
+        // 4) Write result label
+        out.writeDouble(resultLabel);
+    }
 }
diff --git a/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/NeuralNetEvaluator.java b/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/NeuralNetEvaluator.java
new file mode 100644
index 0000000000..d9f0a8a722
--- /dev/null
+++ b/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/NeuralNetEvaluator.java
@@ -0,0 +1,146 @@
+package mage.player.ai;
+
+import ai.onnxruntime.OrtEnvironment;
+import ai.onnxruntime.OrtSession;
+import ai.onnxruntime.OnnxTensor;
+import ai.onnxruntime.OnnxValue;
+import ai.onnxruntime.OrtException;
+
+import java.nio.LongBuffer; // For int64 tensors
+import java.util.HashMap; // For multiple inputs
+import java.util.Map;
+import java.util.Optional;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+
+/**
+ * Lightweight ONNX Runtime wrapper for policy/value inference.
+ * Adapted for models expecting sparse indices and offsets (e.g., from EmbeddingBag).
+ */
+public class NeuralNetEvaluator implements AutoCloseable {
+
+    public static class InferenceResult {
+        public final float[] policy;
+        public final float value;
+        public InferenceResult(float[] policy, float value) {
+            this.policy = policy;
+            this.value = value;
+        }
+    }
+
+    private final OrtEnvironment env;
+    private final OrtSession session;
+    private final ExecutorService executor;
+
+    // You'll need to get these names by inspecting your exported ONNX model
+    // (e.g., using a tool like Netron)
+    private final String onnxIndicesInputName = "indices"; // Placeholder name
+    private final String onnxOffsetsInputName = "offsets"; // Placeholder name
+    private final String onnxPolicyOutputName = "policy";  // Assuming this remains the same
+    private final String onnxValueOutputName = "value";    // Assuming this remains the same
+
+
+    public NeuralNetEvaluator(String onnxPath) throws OrtException {
+        this(onnxPath,
+                Math.max(1, Runtime.getRuntime().availableProcessors() - 1));
+    }
+
+    public NeuralNetEvaluator(String onnxPath, int threads) throws OrtException {
+        this.env = OrtEnvironment.getEnvironment();
+        OrtSession.SessionOptions opts = new OrtSession.SessionOptions();
+        opts.setOptimizationLevel(OrtSession.SessionOptions.OptLevel.ALL_OPT);
+        opts.setIntraOpNumThreads(1); // Good for when executor handles parallelism
+        opts.setInterOpNumThreads(1); // Good for when executor handles parallelism
+        this.session = env.createSession(onnxPath, opts);
+        this.executor = Executors.newFixedThreadPool(Math.max(1, threads));
+    }
+
+    /**
+     * Performs inference using sparse feature indices.
+     * @param activeGlobalIndices Array of active global feature indices for the state.
+     * @return InferenceResult containing policy and value.
+     */
+    public InferenceResult infer(long[] activeGlobalIndices) { // Changed signature
+        // For single sample inference, offsets tensor is just [0]
+        long[] offsets = new long[]{0};
+
+        // The shape of the indices tensor is [num_active_indices]
+        long[] indicesShape = new long[]{activeGlobalIndices.length};
+        // The shape of the offsets tensor is [batch_size], which is 1 here
+        long[] offsetsShape = new long[]{1};
+
+
+        Map<String, OnnxTensor> inputs = null;
+        OrtSession.Result outputs = null;
+        OnnxTensor indicesTensor = null;
+        OnnxTensor offsetsTensor = null;
+
+        try {
+            indicesTensor = OnnxTensor.createTensor(
+                    env,
+                    LongBuffer.wrap(activeGlobalIndices),
+                    indicesShape
+            );
+            offsetsTensor = OnnxTensor.createTensor(
+                    env,
+                    LongBuffer.wrap(offsets),
+                    offsetsShape
+            );
+
+            inputs = new HashMap<>();
+            inputs.put(onnxIndicesInputName, indicesTensor);
+            inputs.put(onnxOffsetsInputName, offsetsTensor);
+
+            outputs = session.run(inputs);
+
+            // Policy tensor
+            Optional<OnnxValue> optP = outputs.get(onnxPolicyOutputName);
+            if (!optP.isPresent()) {
+                throw new RuntimeException("Missing '" + onnxPolicyOutputName + "' output from ONNX model");
+            }
+            OnnxTensor policyTensor = (OnnxTensor) optP.get();
+            float[] policy = ((float[][]) policyTensor.getValue())[0]; // Assumes policy output shape [1, policy_dim]
+
+            // Value tensor
+            Optional<OnnxValue> optV = outputs.get(onnxValueOutputName);
+            if (!optV.isPresent()) {
+                throw new RuntimeException("Missing '" + onnxValueOutputName + "' output from ONNX model");
+            }
+            OnnxTensor valueTensor = (OnnxTensor) optV.get();
+            float[] valueArray = (float[]) valueTensor.getValue();
+            // Access the first (and only) element of the 1D array.
+            float value = valueArray[0];
+
+            return new InferenceResult(policy, value);
+        } catch (OrtException e) {
+            throw new RuntimeException("ONNX inference failed", e);
+        } finally {
+            // Ensure tensors are closed to free native memory
+            if (indicesTensor != null) indicesTensor.close();
+            if (offsetsTensor != null) offsetsTensor.close();
+            if (outputs != null) outputs.close();
+            // The 'inputs' map itself doesn't need explicit closing if its OnnxTensor values are closed.
+        }
+    }
+
+    /**
+     * Performs asynchronous inference using sparse feature indices.
+     * @param activeGlobalIndices Array of active global feature indices for the state.
+     * @return CompletableFuture<InferenceResult> containing policy and value.
+     */
+    public CompletableFuture<InferenceResult> inferAsync(long[] activeGlobalIndices) { // Changed signature
+        return CompletableFuture.supplyAsync(() -> infer(activeGlobalIndices), executor);
+    }
+
+    @Override
+    public void close() throws OrtException {
+        if (session != null) session.close();
+        // OrtEnvironment.getEnvironment() is a singleton; closing it here might affect other users.
+        // Usually, you close it when the application is shutting down if you obtained it via getEnvironment().
+        // If you created it with OrtEnvironment.create(), then you must close it.
+        // For simplicity, let's assume it's fine if only this class uses it.
+        // env.close(); // Be cautious with closing the shared environment.
+        if (executor != null) executor.shutdown();
+    }
+}
\ No newline at end of file
diff --git a/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/ReplayBuffer.java b/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/ReplayBuffer.java
new file mode 100644
index 0000000000..1b7b322fa7
--- /dev/null
+++ b/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/ReplayBuffer.java
@@ -0,0 +1,94 @@
+package mage.player.ai;
+
+import mage.game.Game;
+import mage.game.GameState;
+import mage.util.RandomUtil;
+
+import java.io.Serializable;
+import java.util.*;
+import java.util.concurrent.ConcurrentLinkedDeque;
+
+/**
+ * A fixed-size replay buffer to store experiences for training reinforcement learning models.
+ * It acts as a sliding window (FIFO): when the buffer is full, adding a new element
+ * removes the oldest one. This class is thread-safe for additions.
+ */
+public class ReplayBuffer implements Serializable {
+    private static final long serialVersionUID = 1L; // For serialization
+    private final Deque<Game> buffer;
+    private final int capacity;
+    private final Random random = new Random();
+
+    public ReplayBuffer(int capacity) {
+        this.capacity = capacity;
+        // Use a thread-safe Deque to allow additions from multiple game-playing threads if needed in the future.
+        this.buffer = new ConcurrentLinkedDeque<>();
+    }
+
+    /**
+     * Adds a single GameState to the buffer.
+     * If the buffer is at capacity, the oldest element is removed.
+     *
+     * @param state The GameState to add.
+     */
+    public synchronized void add(Game state) {
+        if (buffer.size() >= capacity) {
+            buffer.pollFirst(); // Remove the oldest element
+        }
+        buffer.add(state);
+    }
+
+    /**
+     * Adds a collection of GameStates to the buffer.
+     *
+     * @param states The collection of states from a completed game.
+     */
+    public void addAll(Collection<Game> states) {
+        for (Game state : states) {
+            add(state); // Use the synchronized add method
+        }
+    }
+
+    /**
+     * Samples a random batch of GameStates from the buffer.
+     *
+     * @param batchSize The number of states to sample.
+     * @return A list containing the sampled GameStates. Returns an empty list if the buffer is empty.
+     */
+    public List<Game> sample(int batchSize) {
+        // Create a temporary list for random access, as Deque doesn't support get(index)
+        List<Game> tempList = new ArrayList<>(buffer);
+        if (tempList.isEmpty()) {
+            return new ArrayList<>();
+        }
+
+        List<Game> sampleBatch = new ArrayList<>();
+        for (int i = 0; i < batchSize; i++) {
+            int randomIndex = RandomUtil.nextInt(tempList.size());
+            sampleBatch.add(tempList.get(randomIndex));
+        }
+        return sampleBatch;
+    }
+
+    /**
+     * Returns the current number of elements in the buffer.
+     *
+     * @return The size of the buffer.
+     */
+    public int size() {
+        return buffer.size();
+    }
+
+    /**
+     * Returns the maximum capacity of the buffer.
+     *
+     * @return The capacity.
+     */
+    public int getCapacity() {
+        return capacity;
+    }
+
+    public boolean isReadyForSampling(int requiredSize) {
+        return buffer.size() >= requiredSize;
+    }
+}
\ No newline at end of file
diff --git a/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/StateEncoder.java b/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/StateEncoder.java
index f057b020b2..31de2e0c32 100644
--- a/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/StateEncoder.java
+++ b/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/StateEncoder.java
@@ -1,6 +1,6 @@
 package mage.player.ai;
 
-import com.j256.ormlite.stmt.query.In;
+import mage.MageObject;
 import mage.abilities.*;
 import mage.abilities.costs.Cost;
 import mage.abilities.costs.Costs;
@@ -17,6 +17,9 @@ import mage.game.Game;
 import mage.game.Graveyard;
 import mage.game.permanent.Battlefield;
 import mage.game.permanent.Permanent;
+import mage.game.stack.SpellStack;
+import mage.game.stack.StackObject;
+import mage.players.ManaPool;
 import mage.players.Player;
 
 
@@ -26,37 +29,31 @@ import java.util.*;
 /**
  * Deck specific state encoder for reinforcement learning.
  * Before vectors can be made, the encoder must learn all game features of
- * the given 60 card decks through a first pass of 1,000 simulated mcst games
+ * the given 60 card decks through a first pass of 1,000 simulated mcst and minimax games
  */
 public class StateEncoder {
     public static int indexCount;
-    public static int reducedIndexCount;
-    private int originalVectorSize;
     private Features features;
-    public static boolean[] featureVector;
-    public static boolean[] reducedFeatureVector;
-    public static int[] rawToReduced;
-    public static Map<Integer, boolean[][]> pendingFeatures; //maps raw index to occurrence matrix for cohort
+    public Set<Integer> featureVector = new HashSet<>();
     private UUID opponentID;
     private UUID myPlayerID;
-    public List<boolean[]> stateVectors;
-    public List<Integer> stateScores = new ArrayList<>();
+    public List<Set<Integer>> macroStateVectors = new ArrayList<>();
+    public List<Set<Integer>> microStateVectors = new ArrayList<>();
+    public List<Boolean> activeStates = new ArrayList<>();
+
+    public List<Double> stateScores = new ArrayList<>();
+    public List<double[]> actionVectors = new ArrayList<>();
+    public int initialRawSize = 0;//original max index
+    public int mappingVersion = 0;
 
     public Set<Integer> ignoreList;
 
     public StateEncoder() {
         //using statics for convenience for now
-        indexCount = 0;
-        reducedIndexCount = 1; //pending features map to zero
-        originalVectorSize = 0;
+        //indexCount = 0;
         features = new Features();
-        featureVector = new boolean[30000];
-        reducedFeatureVector = new boolean[5000];
-        rawToReduced = new int[30000];
-        Arrays.fill(rawToReduced, 0);
-        pendingFeatures = new HashMap<>();
+        features.setEncoder(this);
         ignoreList = new HashSet<>();
-        stateVectors = new ArrayList<>();
     }
     public void setAgent(UUID me) {
         myPlayerID = me;
@@ -64,8 +61,12 @@ public class StateEncoder {
     public void setOpponent(UUID op) {
         opponentID = op;
     }
+    public Features getFeatures() {return features;}
+    public synchronized UUID getMyPlayerID() {return myPlayerID;}
+    public synchronized void addAction(double[] actionVec) { actionVectors.add(actionVec); }
 
     public void processManaCosts(ManaCosts<ManaCost> manaCost, Game game, Features f, Boolean callParent) {
+        if(f == null) return;
         //f.addFeature(manaCost.getText());
         f.addNumericFeature("ManaValue", manaCost.manaValue(), callParent);
         for(ManaCost mc : manaCost) {
@@ -81,6 +82,7 @@ public class StateEncoder {
         }
     }
     public void processAbility(Ability a, Game game, Features f) {
+        if(f == null) return;
         Costs<Cost> c = a.getCosts();
         //for now lets not worry about encoding costs per abilities
         /*ManaCosts<ManaCost> mcs = a.getManaCostsToPay();
@@ -88,18 +90,20 @@ public class StateEncoder {
             Features costFeature = f.getSubFeatures("AbilityCost");
             processCosts(c, mcs, game, costFeature, false); //dont propagate mana cost up for abilities
         }*/
-        for(Effect e : a.getAllEffects()) {
-            for(Mode m : a.getModes().getAvailableModes(a, game)) {
-                f.addFeature(e.getText(m));
+        for(Mode m : a.getModes().getAvailableModes(a, game)) {
+            for(Effect e : m.getEffects()) {
+                f.parent.addFeature(e.getText(m));//only add feature for abstraction (isn't dynamic)
             }
         }
     }
     public void processActivatedAbility(ActivatedAbility aa, Game game, Features f) {
+        if(f == null) return;
         processAbility(aa, game, f);
 
         if(aa.canActivate(myPlayerID, game).canActivate()) f.addFeature("CanActivate"); //use aa.canActivate()
     }
     public void processTriggeredAbility(TriggeredAbility ta, Game game, Features f) {
+        if(f == null) return;
         processAbility(ta, game, f);
 
         if(!ta.checkTriggeredLimit(game)) f.addFeature("ReachedTriggerLimit"); //use ta.checkTriggeredLimit()
@@ -108,8 +112,8 @@ public class StateEncoder {
 
     }
     public void processCard(Card c, Game game, Features f) {
-
-        f.addFeature("Card");//raw universal type of card added for counting purposes
+        if(f == null) return;
+        f.parent.addFeature("Card");//raw universal type of card added for counting purposes
 
         if(c.isPermanent()) f.addCategory("Permanent");
         //add types
@@ -118,7 +122,7 @@ public class StateEncoder {
         }
         //add subtypes
         for (SubType st : c.getSubtype(game)) {
-            f.addCategory(st.name());
+            if(!st.name().isEmpty()) f.addCategory(st.name());
         }
         //add color
         if(c.getColor(game).isRed()) f.addCategory("RedCard");
@@ -131,8 +135,7 @@ public class StateEncoder {
 
         //add cost
         ManaCosts<ManaCost> mc = c.getManaCost();
-        Features costFeature = f.getSubFeatures("CastingCost");
-        processManaCosts(mc, game, costFeature, true);
+        processManaCosts(mc, game, f, true);
 
 
         //process counters
@@ -149,6 +152,7 @@ public class StateEncoder {
 
     }
     public void processPermBattlefield(Permanent p, Game game, Features f) {
+        if(f == null) return;
         processCard(p, game, f);
         //is tapped?
         if(p.isTapped()) f.addFeature("Tapped");
@@ -156,9 +160,12 @@ public class StateEncoder {
         //process attachments
         for (UUID id : p.getAttachments()) {
             Permanent attachment = game.getPermanent(id);
+            if(attachment == null) continue;
             //modify name to not count auras/equipment twice
-            Features attachmentFeatures = f.getSubFeatures(attachment.getName() + "_Attachment");
+            f.passToParent = false; //don't pass pooled attachment features up, or they will be counted twice
+            Features attachmentFeatures = f.getSubFeatures(attachment.getName());
             processPermBattlefield(attachment, game, attachmentFeatures);
+            f.passToParent = true;
         }
 
 
@@ -180,12 +187,12 @@ public class StateEncoder {
         }
         if(p.isCreature(game)) {
             if(p.canAttack(opponentID, game)) f.addFeature("CanAttack"); //use p.canAttack()
-            if(p.canBlock(opponentID, game)) f.addFeature("CanBlock"); //use p.canBlock()
+            if(p.canBlockAny(game)) f.addFeature("CanBlock");
+            f.addNumericFeature("Damage", p.getDamage());
         }
-
-
     }
     public void processCardInGraveyard(Card c, Game game, Features f) {
+        if(f == null) return;
         //process as card
         processCard(c, game, f);
         //process abilities in gy
@@ -207,6 +214,7 @@ public class StateEncoder {
 
     }
     public void processCardInHand(Card c, Game game, Features f) {
+        if(f == null) return;
         //process as card
         processCard(c, game, f);
         //process abilities in hand
@@ -216,10 +224,10 @@ public class StateEncoder {
         }
         //activated abilities
         for(ActivatedAbility aa : c.getAbilities(game).getActivatedAbilities(Zone.HAND)) {
-            if(!(aa instanceof SpellAbility)) {
-                Features aaFeatures = f.getSubFeatures(aa.getRule());
-                processActivatedAbility(aa, game, aaFeatures);
-            }
+            //if(!(aa instanceof SpellAbility)) {
+            Features aaFeatures = f.getSubFeatures(aa.getRule());
+            processActivatedAbility(aa, game, aaFeatures);
+            //}
         }
         //triggered abilities
         for(TriggeredAbility ta : c.getAbilities(game).getTriggeredAbilities(Zone.HAND)) {
@@ -229,33 +237,84 @@ public class StateEncoder {
         }
     }
     public void processBattlefield(Battlefield bf, Game game, Features f, UUID playerID) {
+        if(f == null) return;
         for (Permanent p : bf.getAllActivePermanents(playerID)) {
             Features permFeatures = f.getSubFeatures(p.getName());
             processPermBattlefield(p, game, permFeatures);
         }
     }
     public void processGraveyard(Graveyard gy, Game game, Features f) {
+        if(f == null) return;
         for (Card c : gy.getCards(game)) {
             Features graveCardFeatures = f.getSubFeatures(c.getName());
             processCardInGraveyard(c, game, graveCardFeatures);
         }
     }
     public void processHand(Cards hand, Game game, Features f) {
+        if(f == null) return;
         for (Card c : hand.getCards(game)) {
             Features handCardFeatures = f.getSubFeatures(c.getName());
             processCardInHand(c, game, handCardFeatures);
         }
     }
-    public void processOpponentState(Game game) {
-        Player myPlayer = game.getPlayer(opponentID);
+    public void processStackObject(StackObject so, int stackPosition, Game game, Features f) {
+        if(f == null) return;
+        f.addNumericFeature("StackPosition", stackPosition, false);
+        if(so.getControllerId()==myPlayerID) f.addFeature("isController");
+        Ability sa = so.getStackAbility();
+        if(sa instanceof TriggeredAbility) {
+            processTriggeredAbility((TriggeredAbility) sa, game, f);
+        } else {
+            processActivatedAbility((ActivatedAbility)sa, game, f);
+            if(sa instanceof SpellAbility) {
+                MageObject source = game.getObject(so.getSourceId());
+                for (Ability a : source.getAbilities().getStaticAbilities(Zone.STACK)) {
+                    f.addFeature(a.toString());
+                }
+            }
+        }
+    }
+    public void processStack(SpellStack stack, Game game, Features f) {
+        if(f == null) return;
+        Iterator<StackObject> itr = stack.descendingIterator();
+        StackObject so;
+        f.addNumericFeature("StackSize", stack.size());
+        int i = 0;
+        while(itr.hasNext()) {
+            so = itr.next();
+            i++;
+            Features soFeatures = f.getSubFeatures(so.toString());
+            processStackObject(so, i, game, soFeatures);
+        }
+    }
+    public void processManaPool(ManaPool mp, Game game,  Features f) {
+        if(f == null) return;
+        f.addNumericFeature("GreenMana", mp.getGreen());
+        f.addNumericFeature("RedMana", mp.getRed());
+        f.addNumericFeature("BlueMana", mp.getBlue());
+        f.addNumericFeature("WhiteMana", mp.getWhite());
+        f.addNumericFeature("BlackMana", mp.getBlack());
+        f.addNumericFeature("ColorlessMana", mp.getColorless());
+        //TODO: deal with conditional mana
+    }
+    public void processOpponentState(Game game, UUID activePlayerID) {
+        //switch for perspective reasons
+        UUID temp = myPlayerID;
+        myPlayerID = opponentID;
+        opponentID = temp;
+
+        Player myPlayer = game.getPlayer(myPlayerID);
         //game metadata
         features.addNumericFeature("OpponentLifeTotal", myPlayer.getLife());
         if(myPlayer.canPlayLand()) features.addFeature("OpponentCanPlayLand"); //use features.addFeature(myPlayer.canPlayLand())
+        //mana pool
+        Features mpFeatures = features.getSubFeatures("OpponentManaPool");
+        processManaPool(myPlayer.getManaPool(), game, mpFeatures);
 
         //start with battlefield
         Battlefield bf = game.getBattlefield();
         Features bfFeatures = features.getSubFeatures("OpponentBattlefield");
-        processBattlefield(bf, game, bfFeatures, opponentID);
+        processBattlefield(bf, game, bfFeatures, myPlayerID);
 
         //now do graveyard
         Graveyard gy = myPlayer.getGraveyard();
@@ -263,22 +322,40 @@ public class StateEncoder {
         processGraveyard(gy, game, gyFeatures);
 
         //now do hand (cards are face down so only keep count of number of cards
-        // TODO: keep track of face up cards
-        Cards hand = myPlayer.getHand();
-        features.addNumericFeature("OpponentCardsInHand", hand.size());
+        // TODO: keep track of face up cards and exile
+        if(myPlayerID==activePlayerID) { //invert perspective
+            Cards hand = myPlayer.getHand();
+            Features handFeatures = features.getSubFeatures("Hand");
+            processHand(hand, game, handFeatures);
+        } else {
+            Cards hand = myPlayer.getHand();
+            features.addNumericFeature("OpponentCardsInHand", hand.size());
+        }
+        //switch back
+        opponentID = myPlayerID;
+        myPlayerID = temp;
 
     }
-    public void processState(Game game) {
+    public synchronized void processState(Game game, UUID actingPlayerID) {
         features.stateRefresh();
-        Arrays.fill(featureVector, false);
-        Arrays.fill(reducedFeatureVector, false);
+        featureVector.clear();
 
         Player myPlayer = game.getPlayer(myPlayerID);
 
         //game metadata
+        features.addFeature(game.getTurnStepType().toString()); //phases
+        if(game.isActivePlayer(myPlayerID)) features.addFeature("IsActivePlayer");
+        if(actingPlayerID==myPlayerID) features.addFeature("IsActingPlayer");
         features.addNumericFeature("LifeTotal", myPlayer.getLife());
         if(myPlayer.canPlayLand()) features.addFeature("CanPlayLand"); //use features.addFeature(myPlayer.canPlayLand())
-        features.addFeature(game.getPhase().getType().name());
+
+        //stack
+        Features stackFeatures = features.getSubFeatures("Stack");
+        processStack(game.getStack(), game, stackFeatures);
+
+        //mana pool
+        Features mpFeatures = features.getSubFeatures("ManaPool");
+        processManaPool(myPlayer.getManaPool(), game, mpFeatures);
 
         //start with battlefield
         Battlefield bf = game.getBattlefield();
@@ -291,94 +368,90 @@ public class StateEncoder {
         processGraveyard(gy, game, gyFeatures);
 
         //now do hand
-        Cards hand = myPlayer.getHand();
-        Features handFeatures = features.getSubFeatures("Hand");
-        processHand(hand, game, handFeatures);
-
+        if(myPlayerID==actingPlayerID) { //keep perspective
+            Cards hand = myPlayer.getHand();
+            Features handFeatures = features.getSubFeatures("Hand");
+            processHand(hand, game, handFeatures);
+        } else {
+            assert (false);
+            Cards hand = myPlayer.getHand();
+            features.addNumericFeature("OpponentCardsInHand", hand.size());
+        }
         //TODO: add exile
 
         //lastly do opponent
-        processOpponentState(game);
+        processOpponentState(game, actingPlayerID);
 
-        //update reduced vector
-        //updateReducedVector();
+        //mapping version
+        features.addNumericFeature("Mapping Version", features.version);
 
-        System.out.println("Raw vector:");
-        for(int i = 0; i < indexCount; i++) {
-            System.out.printf("[%d:%d] ", i, featureVector[i] ? 1 : 0);
-        }
-        /*
-        System.out.println("\nReduced vector:");
-        for(int i = 0; i < reducedIndexCount; i++) {
-            System.out.printf("[%d:%d] ", i, reducedFeatureVector[i] ? 1 : 0);
-        }
-         */
-        System.out.println();
-        stateVectors.add(Arrays.copyOf(featureVector, 30000));
     }
-
+    public void processMicroState(Game game, UUID actingPlayerID) {
+        processState(game, actingPlayerID);
+        microStateVectors.add(new HashSet<>(featureVector));
+    }
+    public synchronized void processMacroState(Game game, UUID actingPlayerID) {
+        processState(game, actingPlayerID);
+        macroStateVectors.add(new HashSet<>(featureVector));
+        //activeStates.add(game.getActivePlayerId() == myPlayerID);
+    }
     /**
-     * call at the end of each processState to filter changes from raw vector to reduced one
+     * Takes an array of raw indices, filters out those present in the ignoreList,
+     * and returns a new array of the remaining indices.
+     *
+     * @param rawIndices The input array of feature indices.
+     * @return A new int[] containing only the indices not in the ignoreList.
      */
-    public void updateReducedVector() {
-        //map normal features
-        for(int i = 0; i < originalVectorSize; i++) {
-            if(!featureVector[i]) continue;
-            int reducedIndex = rawToReduced[i]; //pending features map to zero
-            reducedFeatureVector[reducedIndex] = true;
-        }
-        //update matrix for each pending feature
-        for (int f : pendingFeatures.keySet()) {
-            boolean[][] m = pendingFeatures.get(f);
-            boolean allIndependent = true;
-            for(int i = 1; i < m.length; i++) {
-                if(rawToReduced[i+f] != 0) continue;//only care to check un finalized features
-                boolean isIndependent = true;
-                for(int j = 0; j < m.length; j++) {
-                    m[i][j] = (featureVector[i+f] != featureVector[j+f]) || m[i][j]; //don't change if true
-                    if(rawToReduced[j+f] != 0 && !m[i][j]) {//compared to feature is finalized and they aren't independent
-                        isIndependent = false;
-                    }
-                }
-                if(isIndependent) {
-                    //finalize feature if independent (and hasn't been finalized)
-                    System.out.printf("pending feature at raw index %d has been finalized at reduced index %d\n", i+f, reducedIndexCount);
-                    rawToReduced[i+f] = reducedIndexCount;
-                    reducedFeatureVector[reducedIndexCount++] = featureVector[i+f]; //can be added silently (feature itself didn't fire)
-                } else {
-                    allIndependent = false;
-                }
-            }
-            if(allIndependent) {
-                pendingFeatures.remove(f);
-                System.out.printf("entire pending batch from %d has been successfully finalized\n", f);
+    public int[] getCompressedVectorArray(int[] rawIndices) {
+        Set<Integer> filteredIndicesSet = new HashSet<>();
+
+        for (int index : rawIndices) {
+            if (!this.ignoreList.contains(index)) { // Assuming ignoreList is a member
+                filteredIndicesSet.add(index);
             }
         }
-        //matrix for batch of new features
-        int batchSize = indexCount - originalVectorSize;
-        boolean[][] occurrenceMatrix = new boolean[batchSize][batchSize]; //maps if 2 features occurred independently for each pair
-        if(batchSize > 0) {
-            //add first new feature to reduced vector
-            System.out.printf("new reduced feature at raw index %d has been finalized at reduced index %d representing a batch of %d new features\n", originalVectorSize, reducedIndexCount, batchSize);
-            rawToReduced[originalVectorSize] = reducedIndexCount;
-            reducedFeatureVector[reducedIndexCount++] = true;
-            pendingFeatures.put(originalVectorSize, occurrenceMatrix); //pending features are stored in by their first feature in batch
 
+        // Convert the Set<Integer> to an int[]
+        return filteredIndicesSet.stream()
+                .mapToInt(Integer::intValue)
+                .toArray();
+    }
+    public Set<Integer> getCompressedVector(Set<Integer> rawIndices) {
+        Set<Integer> filteredIndicesSet = new HashSet<>();
+
+        for (int index : rawIndices) {
+            if (!this.ignoreList.contains(index)) { // Assuming ignoreList is a member
+                filteredIndicesSet.add(index);
+            }
         }
-        //lastly update original size
-        originalVectorSize = indexCount;
+        return filteredIndicesSet;
+    }
+    public synchronized int[] getFinalActiveGlobalIndicesArray() {
+        Set<Integer> out1 = getCompressedVector(featureVector);
+        return out1.stream().mapToInt(Integer::intValue).toArray();
+
     }
     // Persist the persistent feature mapping
     public void persistMapping(String filename) throws IOException {
-        features.globalIndexCount = indexCount;
-        features.ignoreList = ignoreList;
+        //features.localIndexCount = indexCount;
+        //features.ignoreList = new HashSet<>(ignoreList);
+        features.version = mappingVersion;
         features.saveMapping(filename);
     }
 
     // Load the feature mapping from file
     public void loadMapping(String filename) throws IOException, ClassNotFoundException {
         features = Features.loadMapping(filename);
-        indexCount = features.globalIndexCount;
-        ignoreList = features.ignoreList;
+        features.setEncoder(this);
+        //indexCount = features.localIndexCount;
+        //ignoreList = new HashSet<>(features.ignoreList);
+        //mappingVersion = features.version;
+        //initialRawSize = indexCount;
+    }
+    // Load the feature mapping from object
+    public void loadMapping(Features f) {
+        features = f.createDeepCopy();
+        features.setEncoder(this);
+
     }
 }
diff --git a/Mage.Server.Plugins/Mage.Player.AI/src/main/java/mage/player/ai/ComputerPlayer.java b/Mage.Server.Plugins/Mage.Player.AI/src/main/java/mage/player/ai/ComputerPlayer.java
index 8ccda6a0e0..afbe9b4a84 100644
--- a/Mage.Server.Plugins/Mage.Player.AI/src/main/java/mage/player/ai/ComputerPlayer.java
+++ b/Mage.Server.Plugins/Mage.Player.AI/src/main/java/mage/player/ai/ComputerPlayer.java
@@ -38,6 +38,7 @@ import mage.game.events.GameEvent;
 import mage.game.match.Match;
 import mage.game.permanent.Permanent;
 import mage.game.stack.Spell;
+import mage.game.stack.StackAbility;
 import mage.game.stack.StackObject;
 import mage.game.tournament.Tournament;
 import mage.player.ai.simulators.CombatGroupSimulator;
@@ -64,10 +65,14 @@ import java.util.Map.Entry;
  */
 public class ComputerPlayer extends PlayerImpl {
 
+    public Set<Set<UUID>> chooseTargetOptions = new HashSet<>();
+    public List<Set<UUID>> chooseTargetAction = new ArrayList<>();
+
     private static final Logger log = Logger.getLogger(ComputerPlayer.class);
     private long lastThinkTime = 0; // msecs for last AI actions calc
 
     protected int PASSIVITY_PENALTY = 5; // Penalty value for doing nothing if some actions are available (was 5)
+    public static boolean PRINT_DECISION_FALLBACKS = false;
 
     // debug only: set TRUE to debug simulation's code/games (on false sim thread will be stopped after few secs by timeout)
     protected boolean COMPUTER_DISABLE_TIMEOUT_IN_GAME_SIMULATIONS = false;
@@ -118,6 +123,8 @@ public class ComputerPlayer extends PlayerImpl {
 
     public ComputerPlayer(final ComputerPlayer player) {
         super(player);
+        chooseTargetOptions = new HashSet<>(player.chooseTargetOptions);
+        chooseTargetAction = new ArrayList<>(player.chooseTargetAction);
     }
 
     @Override
@@ -141,7 +148,7 @@ public class ComputerPlayer extends PlayerImpl {
 
     @Override
     public boolean choose(Outcome outcome, Target target, Ability source, Game game, Map<String, Serializable> options) {
-
+        if(PRINT_DECISION_FALLBACKS && name.equals("PlayerA")) System.out.println("choose: ");
         if (log.isDebugEnabled()) {
             log.debug("choose: " + outcome.toString() + ':' + target.toString());
         }
@@ -532,8 +539,9 @@ public class ComputerPlayer extends PlayerImpl {
 
     @Override
     public boolean chooseTarget(Outcome outcome, Target target, Ability source, Game game) {
+        if(PRINT_DECISION_FALLBACKS && name.equals("PlayerA")) System.out.println("chooseTarget: " + (source==null ? "null" : source.toString()));
         if (log.isDebugEnabled()) {
-            log.debug("chooseTarget: " + outcome.toString() + ':' + target.toString());
+            log.debug("chooseTarget: " + outcome.toString() + ':' + target.getTargetName() + ':' + (source==null ? "null" : source.toString()));
         }
 
         // target - real target, make all changes and add targets to it
@@ -1073,6 +1081,7 @@ public class ComputerPlayer extends PlayerImpl {
     } //end of chooseTarget method
 
     protected Card pickTarget(UUID abilityControllerId, List<Card> cards, Outcome outcome, Target target, Ability source, Game game) {
+        if(PRINT_DECISION_FALLBACKS && name.equals("PlayerA")) System.out.println("pickTarget: " + source.toString());
         Card card;
         while (!cards.isEmpty()) {
 
@@ -1097,6 +1106,7 @@ public class ComputerPlayer extends PlayerImpl {
 
     @Override
     public boolean chooseTargetAmount(Outcome outcome, TargetAmount target, Ability source, Game game) {
+        if(PRINT_DECISION_FALLBACKS && name.equals("PlayerA")) System.out.println("chooseTargetAmount: " + source.toString());
         // TODO: make same code for chooseTarget (without filter and target type dependence)
         if (log.isDebugEnabled()) {
             log.debug("chooseTarget: " + outcome.toString() + ':' + target.toString());
@@ -1904,6 +1914,7 @@ public class ComputerPlayer extends PlayerImpl {
 
     @Override
     public boolean chooseUse(Outcome outcome, String message, String secondMessage, String trueText, String falseText, Ability source, Game game) {
+        if(PRINT_DECISION_FALLBACKS && name.equals("PlayerA")) System.out.println("chooseUse: " + source.toString());
         log.debug("chooseUse: " + outcome.isGood());
         // Be proactive! Always use abilities, the evaluation function will decide if it's good or not
         // Otherwise some abilities won't be used by AI like LoseTargetEffect that has "bad" outcome
@@ -1913,7 +1924,10 @@ public class ComputerPlayer extends PlayerImpl {
 
     @Override
     public boolean choose(Outcome outcome, Choice choice, Game game) {
-        log.debug("choose 3");
+        if(PRINT_DECISION_FALLBACKS && name.equals("PlayerA")) System.out.println("choose2: " + choice.toString());
+        //log.info("choose 3");
+        // before falling back, dump the culprit
+        //System.out.println(choice.toString());
         //TODO: improve this
 
         // choose creature type
@@ -2020,6 +2034,7 @@ public class ComputerPlayer extends PlayerImpl {
 
     @Override
     public boolean chooseTarget(Outcome outcome, Cards cards, TargetCard target, Ability source, Game game) {
+        if(PRINT_DECISION_FALLBACKS && name.equals("PlayerA")) System.out.println("chooseTarget2: " + source.toString());
         if (cards == null || cards.isEmpty()) {
             return target.isRequired(source);
         }
@@ -2051,6 +2066,7 @@ public class ComputerPlayer extends PlayerImpl {
 
     @Override
     public boolean choose(Outcome outcome, Cards cards, TargetCard target, Ability source, Game game) {
+        if(PRINT_DECISION_FALLBACKS && name.equals("PlayerA")) System.out.println("choose3: " + source.toString());
         log.debug("choose 2");
         if (cards == null || cards.isEmpty()) {
             return true;
@@ -2128,13 +2144,14 @@ public class ComputerPlayer extends PlayerImpl {
 
     @Override
     public int chooseReplacementEffect(Map<String, String> effectsMap, Map<String, MageObject> objectsMap, Game game) {
-        log.debug("chooseReplacementEffect");
+        log.info("chooseReplacementEffect");
         //TODO: implement this
         return 0;
     }
 
     @Override
     public Mode chooseMode(Modes modes, Ability source, Game game) {
+        if(PRINT_DECISION_FALLBACKS && name.equals("PlayerA")) System.out.println("chooseMode: " + source.toString());
         log.debug("chooseMode");
         if (modes.getMode() != null && modes.getMaxModes(game, source) == modes.getSelectedModes().size()) {
             // mode was already set by the AI
@@ -2144,15 +2161,18 @@ public class ComputerPlayer extends PlayerImpl {
         // spell modes simulated by AI, see addModeOptions
         // trigger modes chooses here
         // TODO: add AI support to select best modes, current code uses first valid mode
+        List<Mode> allModes = modes.getAvailableModes(source, game);
+        //Collections.shuffle(allModes);
         AvailableMode:
-        for (Mode mode : modes.getAvailableModes(source, game)) {
+        for (Mode mode : allModes) {
             for (UUID selectedModeId : modes.getSelectedModes()) {
                 Mode selectedMode = modes.get(selectedModeId);
                 if (selectedMode.getId().equals(mode.getId())) {
                     continue AvailableMode;
                 }
             }
-            if (mode.getTargets().canChoose(source.getControllerId(), source, game)) { // and where targets are available
+            if (mode.getTargets().canChoose(source.getControllerId(), source, game)) {
+                // and where targets are available
                 return mode;
             }
         }
@@ -2161,6 +2181,7 @@ public class ComputerPlayer extends PlayerImpl {
 
     @Override
     public TriggeredAbility chooseTriggeredAbility(List<TriggeredAbility> abilities, Game game) {
+        if(PRINT_DECISION_FALLBACKS && name.equals("PlayerA")) System.out.println("chooseTriggeredAbility: " + abilities.toString());
         log.debug("chooseTriggeredAbility: " + abilities.toString());
         //TODO: improve this
         if (!abilities.isEmpty()) {
@@ -3052,6 +3073,9 @@ public class ComputerPlayer extends PlayerImpl {
 
         // restore used in AI simulations
         // all human players converted to computer and analyse
+        ComputerPlayer cPlayer = (ComputerPlayer)player;
+        chooseTargetOptions = new HashSet<>(cPlayer.chooseTargetOptions);
+        chooseTargetAction = new ArrayList<>(cPlayer.chooseTargetAction);
         this.human = false;
     }
 
diff --git a/Mage.Server.Plugins/Mage.Player.AIMCTS/pom.xml b/Mage.Server.Plugins/Mage.Player.AIMCTS/pom.xml
index d488c1ed04..f90a8210f8 100644
--- a/Mage.Server.Plugins/Mage.Player.AIMCTS/pom.xml
+++ b/Mage.Server.Plugins/Mage.Player.AIMCTS/pom.xml
@@ -30,6 +30,11 @@
             <artifactId>mage-player-ai</artifactId>
             <version>${project.version}</version>
         </dependency>
+        <dependency>
+            <groupId>org.apache.commons</groupId>
+            <artifactId>commons-math3</artifactId>
+            <version>3.6.1</version>
+        </dependency>
     </dependencies>
 
     <build>
diff --git a/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/ActionEncoder.java b/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/ActionEncoder.java
new file mode 100644
index 0000000000..c889ca5b02
--- /dev/null
+++ b/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/ActionEncoder.java
@@ -0,0 +1,28 @@
+package mage.player.ai;
+
+import mage.abilities.Ability;
+
+import java.util.*;
+
+public class ActionEncoder {
+    public static int indexCount = 0;
+    public static boolean printActions = false;
+    public static List<double[]> actionVectors = new ArrayList<>();
+    public static Map<String, Integer> actionMap = new HashMap<>();
+
+    public static synchronized void addAction(double[] label) {
+        actionVectors.add(label);
+    }
+    public static synchronized int getAction(Ability sa) {
+        String name = sa.toString();
+        if(actionMap.containsKey(name)) {//already contains action
+            if(printActions) System.out.printf("Action: %s already maps to index %d\n", name, actionMap.get(name));
+        } else {
+            actionMap.put(name, indexCount++);
+            if(printActions) System.out.printf("New action: %s discovered, reserving index %d for this action\n", name, actionMap.get(name));
+        }
+        //actionIndices.add(actionMap.get(name));
+        return actionMap.get(name);
+    }
+
+}
diff --git a/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/ChooseTargetNextAction.java b/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/ChooseTargetNextAction.java
new file mode 100644
index 0000000000..a0ec97edbf
--- /dev/null
+++ b/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/ChooseTargetNextAction.java
@@ -0,0 +1,38 @@
+package mage.player.ai;
+
+import mage.abilities.Ability;
+import mage.abilities.ActivatedAbility;
+import mage.game.Game;
+import mage.target.Target;
+
+import java.util.*;
+
+public class ChooseTargetNextAction implements MCTSNodeNextAction {
+
+    @Override
+    public List<MCTSNode> performNextAction(MCTSNode node, MCTSPlayer player, Game game, String fullStateValue) {
+        List<MCTSNode> children = new ArrayList<>();
+        if(MCTSPlayer.PRINT_CHOOSE_DIALOGUES) System.out.println("expanding choose target");
+        // Get targets for the current ability
+        for (Set<UUID> targets: player.chooseTargetOptions) {
+            //create node to add option to
+            Game sim = game.getLastPriority().createSimulationForAI();
+            MCTSPlayer simPlayer2 = (MCTSPlayer) sim.getPlayer(player.getId());
+            MCTSPlayer simPlayer1 = (MCTSPlayer) sim.getPlayer(game.getLastPriorityPlayerId());
+            //simPlayer2.copyDialogues(player); //copy previous micro decisions
+            simPlayer2.chooseTargetAction.add(targets);
+            simPlayer1.activateAbility((ActivatedAbility) node.getAction().copy(), sim);
+            sim.resume();
+            MCTSNode newNode = new MCTSNode(node, sim, node.getAction().copy());
+            newNode.chooseTargetAction = new ArrayList<>(node.chooseTargetAction);
+            newNode.chooseTargetAction.add(targets);
+            children.add(newNode);
+        }
+        return children;
+    }
+
+    @Override
+    public void applyAction(MCTSNode node, MCTSPlayer player, Game game) {
+        //do nothing for now
+    }
+}
diff --git a/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/ComputerPlayerMCTS.java b/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/ComputerPlayerMCTS.java
index 2e61345f50..0d4c7b09d5 100644
--- a/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/ComputerPlayerMCTS.java
+++ b/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/ComputerPlayerMCTS.java
@@ -4,6 +4,7 @@ import mage.abilities.Ability;
 import mage.abilities.ActivatedAbility;
 import mage.abilities.common.PassAbility;
 import mage.cards.Card;
+import mage.constants.Outcome;
 import mage.constants.PhaseStep;
 import mage.constants.RangeOfInfluence;
 import mage.constants.Zone;
@@ -12,13 +13,13 @@ import mage.game.combat.Combat;
 import mage.game.combat.CombatGroup;
 import mage.player.ai.MCTSPlayer.NextAction;
 import mage.players.Player;
+import mage.target.Target;
 import mage.util.ThreadUtils;
 import mage.util.XmageThreadFactory;
 import org.apache.log4j.Logger;
 
-import java.util.ArrayList;
-import java.util.List;
-import java.util.UUID;
+import java.io.Serializable;
+import java.util.*;
 import java.util.concurrent.*;
 
 /**
@@ -31,18 +32,21 @@ public class ComputerPlayerMCTS extends ComputerPlayer {
     protected static final double THINK_TIME_MULTIPLIER = 1.0;
     protected static final boolean USE_MULTIPLE_THREADS = true;
 
-    protected transient MCTSNode root;
+    public transient MCTSNode root;
     protected int maxThinkTime;
     protected static final Logger logger = Logger.getLogger(ComputerPlayerMCTS.class);
-    protected int poolSize;
-
-    protected ExecutorService threadPoolSimulations = null;
-
+    public int poolSize = 2;
+    //public Set<Set<UUID>> chooseTargetOptions = new HashSet<>();
+    //public ArrayList<Set<UUID>> chosenChooseTargetActions = new ArrayList<>();
+    protected transient ExecutorService threadPoolSimulations = null;
+    //public static Game macroState;
+    //public static UUID macroPlayerId;
+    //public static Ability lastAction;
     public ComputerPlayerMCTS(String name, RangeOfInfluence range, int skill) {
         super(name, range);
         human = false;
         maxThinkTime = (int) (skill * THINK_TIME_MULTIPLIER);
-        poolSize = Runtime.getRuntime().availableProcessors();
+        //poolSize = 64;//Runtime.getRuntime().availableProcessors();
     }
 
     protected ComputerPlayerMCTS(UUID id) {
@@ -62,6 +66,7 @@ public class ComputerPlayerMCTS extends ComputerPlayer {
 
     @Override
     public boolean priority(Game game) {
+        chooseTargetAction.clear();
         if (game.getTurnStepType() == PhaseStep.UPKEEP) {
             if (!lastPhase.equals(game.getTurn().getValue(game.getTurnNum()))) {
                 logList(game.getTurn().getValue(game.getTurnNum()) + name + " hand: ", new ArrayList(hand.getCards(game)));
@@ -92,8 +97,9 @@ public class ComputerPlayerMCTS extends ComputerPlayer {
             Game sim = createMCTSGame(game);
             MCTSPlayer player = (MCTSPlayer) sim.getPlayer(playerId);
             player.setNextAction(action);
-            player.isRoot = true;
             root = new MCTSNode(playerId, sim);
+            root.chooseTargetAction = new ArrayList<>(chooseTargetAction);
+
         }
         applyMCTS(game, action);
         if (root != null && root.bestChild() != null) {
@@ -105,7 +111,7 @@ public class ComputerPlayerMCTS extends ComputerPlayer {
     protected void getNextAction(Game game, NextAction nextAction) {
         if (root != null) {
             MCTSNode newRoot;
-            newRoot = root.getMatchingState(game.getState().getValue(game, playerId));
+            newRoot = root.getMatchingState(game.getState().getValue(game, playerId), chooseTargetAction);
             if (newRoot != null) {
                 newRoot.emancipate();
             } else
@@ -141,6 +147,10 @@ public class ComputerPlayerMCTS extends ComputerPlayer {
             if (i < simulatedCombat.getGroups().size()) {
                 CombatGroup currentGroup = currentGroups.get(i);
                 CombatGroup simulatedGroup = simulatedCombat.getGroups().get(i);
+                if(currentGroup.getAttackers().isEmpty()) {
+                    System.out.println("Attacker not found - skipping");
+                    continue;
+                }
                 sb.append(game.getPermanent(currentGroup.getAttackers().get(0)).getName()).append(" with: ");
                 for (UUID blockerId : simulatedGroup.getBlockers()) {
                     // blockers can be added automaticly by requirement effects, so we must add only missing blockers
@@ -155,7 +165,36 @@ public class ComputerPlayerMCTS extends ComputerPlayer {
         logger.info(sb.toString());
         MCTSNode.logHitMiss();
     }
-
+    @Override
+    public boolean chooseTarget(Outcome outcome, Target target, Ability source, Game game) {
+        System.out.println("base choose target");
+        Set<UUID> possible = target.possibleTargets(getId(), game);
+        chooseTargetOptions.clear();
+        MCTSPlayer.getAllPossible(chooseTargetOptions, possible, target.copy(), source, game, getId());
+        getNextAction(game, NextAction.CHOOSE_TARGET);
+        Set<UUID> choice = root.chooseTargetAction.get(root.chooseTargetAction.size()-1);
+        for(UUID targetId : choice) {
+            Set<UUID> chosen = new HashSet<>();
+            if(target.canTarget(targetId, source, game)) {
+                target.addTarget(targetId, source, game);
+                chosen.add(targetId);
+                System.out.printf("Targeting %s\n", game.getObject(targetId).toString());
+            }
+            chooseTargetAction.add(chosen);
+        }
+        return target.isChosen(game);
+    }
+    @Override
+    public boolean choose(Outcome outcome, Target target, Ability source, Game game, Map<String, Serializable> options) {
+        if(game.getTurnNum()>1) {
+            //reroute to mcts simulator
+            return chooseTarget(outcome, target, source, game);
+        } else {
+            //reroute to default
+            System.out.println("falling back to default choose target");
+            return super.choose(outcome, target, source, game, options);
+        }
+    }
     protected long totalThinkTime = 0;
     protected long totalSimulations = 0;
 
@@ -302,13 +341,27 @@ public class ComputerPlayerMCTS extends ComputerPlayer {
      * @return a new game object with simulated players
      */
     protected Game createMCTSGame(Game game) {
+        return createMCTSGame(game, true);
+    }
+    protected Game createMCTSGame(Game game, boolean firstCall) {
         Game mcts = game.createSimulationForAI();
-
         for (Player copyPlayer : mcts.getState().getPlayers().values()) {
             Player origPlayer = game.getState().getPlayers().get(copyPlayer.getId());
             MCTSPlayer newPlayer = new MCTSPlayer(copyPlayer.getId());
             newPlayer.restore(origPlayer);
             newPlayer.setMatchPlayer(origPlayer.getMatchPlayer());
+            //dont shuffle here
+            mcts.getState().getPlayers().put(copyPlayer.getId(), newPlayer);
+        }
+        if(firstCall) {
+            mcts.setLastPriority(createMCTSGame(game.getLastPriority(), false));
+            assert (mcts.getLastPriority().getPlayer(playerId) instanceof MCTSPlayer);
+        }
+        mcts.resume();
+        return mcts;
+    }
+    public static void shuffleUnknowns(Game mcts, UUID playerId) {
+        for (Player newPlayer : mcts.getState().getPlayers().values()) {
             if (!newPlayer.getId().equals(playerId)) {
                 int handSize = newPlayer.getHand().size();
                 newPlayer.getLibrary().addAll(newPlayer.getHand().getCards(mcts), mcts);
@@ -316,18 +369,16 @@ public class ComputerPlayerMCTS extends ComputerPlayer {
                 newPlayer.getLibrary().shuffle();
                 for (int i = 0; i < handSize; i++) {
                     Card card = newPlayer.getLibrary().drawFromTop(mcts);
+                    assert (newPlayer.getLibrary().size() != 0);
+                    assert (card != null);
                     card.setZone(Zone.HAND, mcts);
                     newPlayer.getHand().add(card);
                 }
             } else {
                 newPlayer.getLibrary().shuffle();
             }
-            mcts.getState().getPlayers().put(copyPlayer.getId(), newPlayer);
         }
-        mcts.resume();
-        return mcts;
     }
-
     protected void displayMemory() {
         long heapSize = Runtime.getRuntime().totalMemory();
         long heapMaxSize = Runtime.getRuntime().maxMemory();
diff --git a/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/MCTSExecutor.java b/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/MCTSExecutor.java
index f2916557f5..aa7a7e3691 100644
--- a/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/MCTSExecutor.java
+++ b/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/MCTSExecutor.java
@@ -1,5 +1,7 @@
 package mage.player.ai;
 
+import java.util.ArrayList;
+import java.util.HashSet;
 import java.util.UUID;
 import java.util.concurrent.Callable;
 
@@ -14,6 +16,7 @@ public class MCTSExecutor implements Callable<Boolean> {
     protected UUID playerId;
     protected int simCount;
     public boolean reachedTerminalState = false;
+    private volatile boolean stateUpdatesComplete = false;
 
     private static final Logger logger = Logger.getLogger(ComputerPlayerMCTS.class);
 
@@ -22,6 +25,14 @@ public class MCTSExecutor implements Callable<Boolean> {
         this.thinkTime = thinkTime;
         this.simCount = 0;
         root = new MCTSNode(playerId, sim);
+        root.chooseTargetAction = new ArrayList<>(((MCTSPlayer) sim.getPlayer(playerId)).chooseTargetAction);
+    }
+    public MCTSExecutor(Game sim, UUID playerId, int thinkTime, MCTSNode givenRoot) {
+        this.playerId = playerId;
+        this.thinkTime = thinkTime;
+        this.simCount = 0;
+        root = new MCTSNode(playerId, sim);
+        if(givenRoot != null) root.chooseTargetAction = new ArrayList<>(givenRoot.chooseTargetAction);
     }
     public MCTSExecutor(UUID playerId, int thinkTime, MCTSNode givenRoot) {
         this.playerId = playerId;
@@ -36,48 +47,43 @@ public class MCTSExecutor implements Callable<Boolean> {
         this.reachedTerminalState = exec.reachedTerminalState;
         root = new MCTSNode(exec.root);
     }
+
     @Override
     public Boolean call() {
         //simCount = 0;
         MCTSNode current;
         // This loop termination is controlled externally by timeout.
-        while (true) {
-//            if(simCount > 300) {
-//                return true;
-//            }
-            current = root;
+        long deadline = System.currentTimeMillis() + thinkTime * 1000L;
+        while (simCount <= 300 && !Thread.currentThread().isInterrupted()
+                && System.currentTimeMillis() < deadline) {
             simCount++;
-            // Selection: traverse until a leaf node is reached.
-            int testCount = 0;
-            while (!current.isLeaf()) {
-                current = current.select(this.playerId);
-                testCount++;
-                if(testCount > 1000) {
-                    System.out.println("stuck in selection");
+            synchronized (this) {
+                current = root;
+                // Selection: traverse until a leaf node is reached.
+                int testCount = 0;
+                while (!current.isLeaf()) {
+                    current = current.select(this.playerId);
+                    testCount++;
+                    if (testCount > 1000) {
+                        System.out.println("stuck in selection");
+                        break;
+                    }
                 }
+                double result;
+                if (!current.isTerminal()) {
+                    // Expansion:
+                    result = rollout(current);
+                    current.expand();
+                } else {
+                    reachedTerminalState = true;
+                    result = current.isWinner(this.playerId) ? 1 : -1;
+                }
+                // Backpropagation:
+                current.backpropagate(result);
+                this.stateUpdatesComplete = true;
             }
-            // Don't stop to eval state until stack is empty and there are multiple children
-            int traverseCount = 0;
-            while (!current.isTerminal() && traverseCount < 10
-                    //&& (current.getNumChildren() == 1
-                    //|| current.getGame().getTurnPhaseType() == TurnPhase.COMBAT
-                    && !current.getGame().getStack().isEmpty()) {
-                traverseCount++;
-                current.expand();
-                current = current.select(this.playerId);
-            }
-            int result;
-            if (!current.isTerminal()) {
-                // Expansion:
-                result = rollout(current);
-                current.expand();
-            } else {
-                reachedTerminalState = true;
-                result = current.isWinner(this.playerId) ? 100000000 : -100000000;
-            }
-            // Backpropagation:
-            current.backpropagate(result);
         }
+        return true;
     }
 
     /**
@@ -87,9 +93,8 @@ public class MCTSExecutor implements Callable<Boolean> {
      * @param node the leaf node to evaluate
      * @return an integer evaluation of the node's state
      */
-    protected int rollout(MCTSNode node) {
-        System.out.println("you should never see this");
-        return node.simulate(this.playerId);
+    protected double rollout(MCTSNode node) {
+        return 0;//node.simulate(this.playerId);//-1 or 1
     }
 
     public MCTSNode getRoot() {
diff --git a/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/MCTSNextActionFactory.java b/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/MCTSNextActionFactory.java
index fb408fafa3..f5d85755f5 100644
--- a/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/MCTSNextActionFactory.java
+++ b/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/MCTSNextActionFactory.java
@@ -3,12 +3,13 @@ package mage.player.ai;
 import java.util.HashMap;
 
 public class MCTSNextActionFactory {
-    private static final HashMap<MCTSPlayer.NextAction, MCTSNodeNextAction> strategyMap = new HashMap<>();
+    public static final HashMap<MCTSPlayer.NextAction, MCTSNodeNextAction> strategyMap = new HashMap<>();
 
     static {
         strategyMap.put(MCTSPlayer.NextAction.PRIORITY, new PriorityNextAction());
         strategyMap.put(MCTSPlayer.NextAction.SELECT_BLOCKERS, new SelectBlockersNextAction());
         strategyMap.put(MCTSPlayer.NextAction.SELECT_ATTACKERS, new SelectAttackersNextAction());
+        strategyMap.put(MCTSPlayer.NextAction.CHOOSE_TARGET, new ChooseTargetNextAction());
     }
 
     public static MCTSNodeNextAction createNextAction(MCTSPlayer.NextAction nextAction) {
diff --git a/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/MCTSNode.java b/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/MCTSNode.java
index 114e34fd0f..8c86d33a83 100644
--- a/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/MCTSNode.java
+++ b/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/MCTSNode.java
@@ -1,12 +1,7 @@
 
 package mage.player.ai;
 
-import java.util.ArrayDeque;
-import java.util.ArrayList;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Set;
-import java.util.UUID;
+import java.util.*;
 import java.util.concurrent.ConcurrentHashMap;
 
 import mage.MageInt;
@@ -17,11 +12,16 @@ import mage.abilities.PlayLandAbility;
 import mage.abilities.common.PassAbility;
 import mage.cards.Card;
 import mage.game.Game;
+import mage.game.GameState;
 import mage.game.combat.Combat;
 import mage.game.turn.Step.StepPart;
 import mage.players.Player;
 import mage.util.RandomUtil;
 import org.apache.log4j.Logger;
+import java.util.Random;
+import org.apache.commons.math3.distribution.GammaDistribution;
+import org.apache.commons.math3.distribution.GammaDistribution;
+import org.apache.commons.math3.random.JDKRandomGenerator;
 
 import static java.lang.Math.*;
 
@@ -36,22 +36,27 @@ public class MCTSNode {
     private static final double passRatioTolerance = 0.0;
     private static final Logger logger = Logger.getLogger(MCTSNode.class);
 
+
     private boolean stackIsEmpty = true;
 
     public int visits = 0;
     private int wins = 0;
-    private double score = 0;
-    private MCTSNode parent;
+    public double score = 0;
+    private MCTSNode parent = null;
     public final List<MCTSNode> children = new ArrayList<>();
-    private Ability action;
-    private Game game;
-    private Combat combat;
+    public Ability action;
+    public List<Set<UUID>> chooseTargetAction = new ArrayList<>();
+    private Game game;//only contains shared game
+
+    public Combat combat;
     private final String stateValue;
     private final String fullStateValue;
-    private UUID playerId;
+    public UUID playerId;
     private boolean terminal = false;
     public UUID targetPlayer;
     public int depth = 1;
+    public float[] policy = null;
+    private double prior = 1;
 
     private static int nodeCount;
 
@@ -62,6 +67,10 @@ public class MCTSNode {
         this.fullStateValue = game.getState().getValue(true, game);
         this.stackIsEmpty = game.getStack().isEmpty();
         this.terminal = game.checkIfGameIsOver();
+        this.action = game.getPlayer(game.getLastPriorityPlayerId()).getLastActivated();
+        if(this.action == null) {
+            logger.error("action in node is null\n");
+        }
         setPlayer();
         nodeCount = 1;
 //        logger.info(this.stateValue);
@@ -76,6 +85,7 @@ public class MCTSNode {
         this.terminal = game.checkIfGameIsOver();
         this.parent = parent;
         this.action = action;
+
         setPlayer();
         nodeCount++;
 //        logger.info(this.stateValue);
@@ -84,16 +94,19 @@ public class MCTSNode {
     protected MCTSNode(MCTSNode parent, Game game, Combat combat) {
         this.targetPlayer = parent.targetPlayer;
         this.game = game;
+        //this.gameState = game.getState().copy();
         this.combat = combat;
         this.stateValue = game.getState().getValue(game, targetPlayer);
         this.fullStateValue = game.getState().getValue(true, game);
         this.stackIsEmpty = game.getStack().isEmpty();
         this.terminal = game.checkIfGameIsOver();
         this.parent = parent;
+
         setPlayer();
         nodeCount++;
 //        logger.info(this.stateValue);
     }
+    //dont use
     protected MCTSNode(MCTSNode node) {
         combat = null; action = null; game = null;
         if(node.combat != null) combat = node.combat.copy();
@@ -121,66 +134,66 @@ public class MCTSNode {
 
     }
     private void setPlayer() {
-        if (game.getStep().getStepPart() == StepPart.PRIORITY) {
-            playerId = game.getPriorityPlayerId();
-        } else {
-            if (game.getTurnStepType() == PhaseStep.DECLARE_BLOCKERS) {
-                playerId = game.getCombat().getDefenders().iterator().next();
-            } else {
-                playerId = game.getActivePlayerId();
+        //System.out.println("this happening");
+        for (Player p : game.getPlayers().values()) {
+            MCTSPlayer mctsP = (MCTSPlayer) p;
+            if(mctsP.lastToAct) {
+                playerId = p.getId();
+                return;
             }
         }
-    }
-    public static double sigmoid(double x) {
-        return 1 / (1 + Math.exp(-x));
+        if(game.checkIfGameIsOver()) {
+            logger.info("TERMINAL STATE\n");
+            return;
+        }
+        System.out.println("this should not happen");
+        assert (false);
+//        if (game.getStep().getStepPart() == StepPart.PRIORITY) {
+//            playerId = game.getPriorityPlayerId();
+//        } else {
+//            if (game.getTurnStepType() == PhaseStep.DECLARE_BLOCKERS) {
+//                playerId = game.getCombat().getDefenders().iterator().next();
+//            } else {
+//                playerId = game.getActivePlayerId();
+//            }
+//        }
     }
     public MCTSNode select(UUID targetPlayerId) {
-        double bestValue = Double.NEGATIVE_INFINITY;
-        double worstValue = Double.POSITIVE_INFINITY;
-        boolean isTarget = playerId.equals(targetPlayerId);
-        MCTSNode bestChild = null;
+        // Singlechild shortcut
         if (children.size() == 1) {
             return children.get(0);
         }
-        List<MCTSNode> unvisited = new ArrayList<>();
-        List<MCTSNode> unvisitedWithNoStack = new ArrayList<>();
-        for (MCTSNode node: children) {
-            double uct;
-            if (node.visits > 0) {
-                //System.out.println(node.visits);
-                uct = (node.score / (node.visits * 1.0));
-                if (isTarget) {
-                    uct += (850.0)*(selectionCoefficient * Math.sqrt((visits*1.0) / (node.visits)));
-                    if (uct > bestValue) {
-                        bestChild = node;
-                        bestValue = uct;
-                    }
-                }
-                else {
-                    uct -= (850.0)*(selectionCoefficient * Math.sqrt((visits*1.0) / (node.visits)));
-                    if (uct < worstValue) {
-                        bestChild = node;
-                        worstValue = uct;
-                    }
-                }
-            }
-            else {
-                // ensure that a random unvisited node is played first
-                unvisited.add(node);
-                if(node.stackIsEmpty) {
-                    unvisitedWithNoStack.add(node);
+
+        boolean isTarget = playerId.equals(targetPlayerId);
+        double sign = isTarget ? +1.0 : -1.0;
+
+        MCTSNode best    = null;
+        double bestVal = Double.NEGATIVE_INFINITY;
+
+        double sqrtN = Math.sqrt(visits);
+        double c = selectionCoefficient;
+        synchronized (children) {
+            for (MCTSNode child : children) {
+                // value term: 0 if unvisited, else average reward
+                double q = (child.visits > 0)
+                        ? (child.score / child.visits)
+                        : 0.0;
+                double passBonus = child.getAction() instanceof PassAbility ? 0.05 : 0;
+                // exploration term still blows up when visits==0
+                double u = 1 * (child.prior + 0.3 + passBonus) * (sqrtN / (1 + child.visits));
+
+                // combined PUCT
+                double val = sign * q + u;
+
+                if (val > bestVal) {
+                    bestVal = val;
+                    best = child;
                 }
             }
         }
-        //prioritize unvisited nodes with no stack
-        if(!unvisitedWithNoStack.isEmpty()) {
-            return unvisitedWithNoStack.get(abs(RandomUtil.nextInt())%unvisitedWithNoStack.size());
-        }
-        if(!unvisited.isEmpty()) {
-            return unvisited.get(abs(RandomUtil.nextInt())%unvisited.size());
-        }
-        assert (bestChild != null);
-        return bestChild;
+        // best should never be null once visits>0 on the root
+        assert best != null;
+        return best;
     }
 
     public void expand() {
@@ -188,12 +201,67 @@ public class MCTSNode {
         if (player.getNextAction() == null) {
             logger.fatal("next action is null");
         }
-        children.addAll(MCTSNextActionFactory.createNextAction(player.getNextAction()).performNextAction(this, player, game, fullStateValue));
-        for(MCTSNode c : children) {
-            c.depth = depth+1;
+        synchronized (children) {
+            children.addAll(MCTSNextActionFactory.createNextAction(player.getNextAction()).performNextAction(this, player, game, fullStateValue));
+            for (MCTSNode node : children) {
+                node.depth = depth + 1;
+                node.prior = 1.0;///children.size();
+            }
+            if (policy != null && player.getNextAction() != MCTSPlayer.NextAction.CHOOSE_TARGET) {
+                // 2) find max logit for numeric stability
+                double maxLogit = Double.NEGATIVE_INFINITY;
+                for (MCTSNode node : children) {
+                    if (node.action == null) continue;
+                    int idx = ActionEncoder.getAction(node.getAction());
+                    maxLogit = Math.max(maxLogit, policy[idx]);
+                }
+
+                // 3) compute raw exps and sum
+                double sumExp = 0;
+                for (MCTSNode node : children) {
+                    if (node.action == null) continue;
+                    int idx = ActionEncoder.getAction(node.action);
+                    double raw = Math.exp(policy[idx] - maxLogit);
+                    node.prior = raw;     // assume youve added `public double prior;` to MCTSNode
+                    sumExp += raw;
+                }
+
+                // 4) normalize in place
+                for (MCTSNode node : children) {
+                    node.prior /= sumExp;
+                }
+                long seed = player.dirichletSeed;
+                if (seed != 0) {
+                    double alpha = 0.03, eps = 0;//no noise for now
+                    int K = children.size();
+                    double[] dir = new double[K];
+                    double sum = 0;
+
+                    // 1) create a Commons-Math RNG and seed it
+                    JDKRandomGenerator rg = new JDKRandomGenerator();
+                    rg.setSeed(seed);
+
+                    // 2) pass it into the GammaDistribution
+                    GammaDistribution gd = new GammaDistribution(rg, alpha, 1.0);
+
+                    // 3) sample & mix exactly as before
+                    for (int i = 0; i < K; i++) {
+                        dir[i] = gd.sample();
+                        sum += dir[i];
+                    }
+                    for (int i = 0; i < K; i++) {
+                        dir[i] /= sum;
+                        children.get(i).prior = (1 - eps) * children.get(i).prior + eps * dir[i];
+                    }
+
+                    // 4) mark done
+                    player.dirichletSeed = 0;
+                }
+            }
+            if (!children.isEmpty()) {
+                game = null;
+            }
         }
-        game = null;
-        //if(parent != null) parent.game = null;
     }
 
     public int simulate(UUID playerId) {
@@ -212,7 +280,7 @@ public class MCTSNode {
         return retVal;
     }
 
-    public void backpropagate(int result) {
+    public void backpropagate(double result) {
         visits++;
         score += result;
         if (parent != null)
@@ -220,7 +288,9 @@ public class MCTSNode {
     }
 
     public boolean isLeaf() {
-        return children.isEmpty();
+        synchronized (children) {
+            return children.isEmpty();
+        }
     }
 
     public MCTSNode bestChild() {
@@ -231,8 +301,11 @@ public class MCTSNode {
         boolean bestIsPass = false;
         MCTSNode bestChild = null;
         System.out.print("actions: ");
+
         for (MCTSNode node: children) {
-            if(node.action != null) System.out.printf("[%s score: %.3f count: %d] ", node.action.toString(), node.getWinRatio(), node.visits);
+            if(node.action != null) {
+                System.out.printf("[%s score: %.3f count: %d] ", node.action.toString(), node.getWinRatio(), node.visits);
+            }
             if(node.combat != null && !node.combat.getAttackers().isEmpty()) System.out.printf("[%s score: %.3f count: %d] ", node.combat.toString(), node.getWinRatio(), node.visits);
             //favour passing vs any other action except for playing land if ratio is close
             if (node.visits > bestCount) {
@@ -367,14 +440,15 @@ public class MCTSNode {
      * @param state - the game state that we are looking for
      * @return the matching state or null if no match is found
      */
-    public MCTSNode getMatchingState(String state) {
+    public MCTSNode getMatchingState(String state, List<Set<UUID>> chosen) {
         ArrayDeque<MCTSNode> queue = new ArrayDeque<>();
         queue.add(this);
 
         while (!queue.isEmpty()) {
             MCTSNode current = queue.remove();
-            if (current.stateValue.equals(state))
+            if (current.stateValue.equals(state) && current.chooseTargetAction.equals(chosen))
                 return current;
+            //System.out.printf("MISMATCH: %s\n %s\n",current.stateValue, state);
             for (MCTSNode child: current.children) {
                 queue.add(child);
             }
@@ -384,7 +458,7 @@ public class MCTSNode {
 
     public void merge(MCTSNode merge) {
         // Check that states match; if not, no merge occurs.
-        if (!stateValue.equals(merge.stateValue)) {
+        if (!stateValue.equals(merge.stateValue) || !merge.chooseTargetAction.equals(chooseTargetAction)) {
             logger.info("mismatched merge states at root");
             return;
         }
@@ -413,7 +487,7 @@ public class MCTSNode {
                 for (MCTSNode child : tempChildren) {
                     if (mergeChild.action != null && child.action != null) {
                         if (mergeChild.action.toString().equals(child.action.toString())) {
-                            if (!mergeChild.stateValue.equals(child.stateValue)) {
+                            if (!mergeChild.stateValue.equals(child.stateValue) || !mergeChild.chooseTargetAction.equals(child.chooseTargetAction)) {
                                 // Record mismatch if needed; skip merge.
                             } else {
                                 // Recursively merge the matching child.
@@ -424,8 +498,9 @@ public class MCTSNode {
                         }
                     } else if (mergeChild.combat != null && child.combat != null &&
                             mergeChild.combat.getValue().equals(child.combat.getValue())) {
-                        if (!mergeChild.stateValue.equals(child.stateValue)) {
+                        if (!mergeChild.stateValue.equals(child.stateValue) || !mergeChild.chooseTargetAction.equals(child.chooseTargetAction)) {
                             // Record mismatch if needed.
+
                         } else {
                             child.merge(mergeChild);
                             merged = true;
@@ -560,32 +635,14 @@ public class MCTSNode {
         visits = 0;
         depth = 1;
     }
-    public int maxVisits() {
-        int max = -1;
-        for(MCTSNode n : children) {
-            if(n.visits > max) {
-                max = n.visits;
-            }
-        }
-        return max;
-    }
-    public int diffVisits() {
-        int max = -1;
-        int max2 = -1;//second highest
-        for(MCTSNode n : children) {
-            if(n.visits > max) {
-                max2 = max;
-                max = n.visits;
-            } else if(n.visits > max2) {
-                max2 = n.visits;
-            }
-        }
-        return max-max2;
+    public int getAverageVisits() {
+        if(children.isEmpty()) return 0;
+        return visits/children.size();
     }
     public Game getGame() {
+        //game.getState().restore(gameState);
         return game;
     }
-
     public static void logHitMiss() {
         if (USE_ACTION_CACHE) {
             StringBuilder sb = new StringBuilder();
diff --git a/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/MCTSNodeNextAction.java b/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/MCTSNodeNextAction.java
index befa16c515..494912df8a 100644
--- a/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/MCTSNodeNextAction.java
+++ b/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/MCTSNodeNextAction.java
@@ -6,4 +6,5 @@ import java.util.List;
 
 public interface MCTSNodeNextAction {
     List<MCTSNode> performNextAction(MCTSNode node, MCTSPlayer player, Game game, String fullStateValue);
+    void applyAction(MCTSNode node, MCTSPlayer player, Game game);
 }
diff --git a/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/MCTSPlayer.java b/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/MCTSPlayer.java
index af18024b71..013cf14e11 100644
--- a/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/MCTSPlayer.java
+++ b/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/MCTSPlayer.java
@@ -6,17 +6,28 @@ import mage.Mana;
 import mage.abilities.Ability;
 import mage.abilities.ActivatedAbility;
 import mage.abilities.SpellAbility;
+import mage.abilities.TriggeredAbility;
 import mage.abilities.common.PassAbility;
 import mage.abilities.costs.Costs;
 import mage.abilities.costs.mana.GenericManaCost;
+import mage.abilities.costs.mana.ManaCost;
+import mage.abilities.costs.mana.ManaCostsImpl;
+import mage.abilities.costs.mana.VariableManaCost;
+import mage.abilities.effects.Effect;
 import mage.abilities.mana.ManaOptions;
+import mage.cards.Cards;
+import mage.constants.Outcome;
 import mage.constants.Zone;
 import mage.game.Game;
 import mage.game.permanent.Permanent;
 import mage.players.Player;
+import mage.target.Target;
+import mage.target.TargetCard;
 import org.apache.log4j.Logger;
 
+import java.io.Serializable;
 import java.util.*;
+import java.util.concurrent.ConcurrentLinkedQueue;
 
 /**
  * AI: server side bot with monte carlo logic (experimental, the latest version)
@@ -28,13 +39,21 @@ import java.util.*;
  */
 public class MCTSPlayer extends ComputerPlayer {
 
-    private static final Logger logger = Logger.getLogger(MCTSPlayer.class);
-
+    public boolean lastToAct =  false;
     private NextAction nextAction;
-    public boolean isRoot = false;
+    public long dirichletSeed = 0;
+    //public Set<Set<UUID>> chooseTargetOptions = new HashSet<>();
+    //public List<Set<UUID>> chooseTargetAction = new ArrayList<>();
+    //public Set<Set<UUID>> chooseTriggeredOptions = new HashSet<>();
+    //public List<Set<UUID>> chooseTriggeredAction = new ArrayList<>();
+
+    private int chooseTargetCount = 0;
+    public static boolean PRINT_CHOOSE_DIALOGUES = false;
+
+
 
     public enum NextAction {
-        PRIORITY, SELECT_ATTACKERS, SELECT_BLOCKERS
+                PRIORITY, SELECT_ATTACKERS, SELECT_BLOCKERS, CHOOSE_TARGET, CHOOSE_TRIGGERED_ABILITY
     }
 
     public MCTSPlayer(UUID id) {
@@ -51,38 +70,30 @@ public class MCTSPlayer extends ComputerPlayer {
         return new MCTSPlayer(this);
     }
 
+    public void copyDialogues(MCTSPlayer player) {
+        this.chooseTargetAction = new ArrayList<>(player.chooseTargetAction);
+    }
+
     protected List<ActivatedAbility> getPlayableAbilities(Game game) {
         List<ActivatedAbility> playables = getPlayable(game, true);
         ManaOptions availableMana = getManaAvailable(game);
+        List<ActivatedAbility> out = new ArrayList<>();
         //if only land tapping abilities - just return pass JUST FOR TESTING THIS CANT BE USED FOR TRAINING SINCE SOME DECKS CARE ABOUT THIS TODO:remove
         boolean onlyMana = true;
         for(ActivatedAbility aa : playables) {
-            if(!aa.isManaAbility()) onlyMana = false;
-        }
-        if(onlyMana) playables.clear();
-        List<ActivatedAbility> out = new ArrayList<>();
-        for(ActivatedAbility aa : playables) {
-
-            out.add(aa);
-
-            Set<Mana> possiblePayments = new HashSet<>();
-            for(Mana m : availableMana) {
-                Set<Mana> paySet = ManaOptions.getPossiblePayCombinations(aa.getManaCosts().getMana(), m);
-                possiblePayments.addAll(paySet);
-            }
-            if(false) {
-                System.out.printf("payment options for ability %s\n", aa.toString());
-                for(Mana m : possiblePayments) {
-                    System.out.printf("%s, ", m.toString());
-                }
+            if(!aa.isManaAbility()) {
+                onlyMana = false;
+                out.add(aa);
             }
         }
-
+        if(onlyMana) playables.clear();
+        playables.add(new PassAbility());
         out.add(new PassAbility());
         return out;
     }
 
     public List<Ability> getPlayableOptions(Game game) {
+        //if(true) return simulatePriority(game);
         List<Ability> all = new ArrayList<>();
         List<ActivatedAbility> playables = getPlayableAbilities(game);
         for (ActivatedAbility ability : playables) {
@@ -210,6 +221,7 @@ public class MCTSPlayer extends ComputerPlayer {
     @Override
     public boolean priority(Game game) {
         game.pause();
+        lastToAct = true;
         nextAction = NextAction.PRIORITY;
         return false;
     }
@@ -217,12 +229,61 @@ public class MCTSPlayer extends ComputerPlayer {
     @Override
     public void selectAttackers(Game game, UUID attackingPlayerId) {
         game.pause();
+        lastToAct = true;
         nextAction = NextAction.SELECT_ATTACKERS;
     }
 
     @Override
     public void selectBlockers(Ability source, Game game, UUID defendingPlayerId) {
         game.pause();
+        lastToAct = true;
         nextAction = NextAction.SELECT_BLOCKERS;
     }
+    public static void getAllPossible(Set<Set<UUID>> out, Set<UUID> possible, Target target, Ability source, Game game, UUID myID) {
+        if (target.isChosen(game)) out.add(new HashSet<>(target.getTargets()));
+        for(UUID id : possible) {
+            if (!target.canTarget(myID, id, source, game)) continue;
+            target.add(id, game);
+            if(out.contains(new HashSet<>(target.getTargets()))) {
+                target.remove(id);
+                continue;
+            }
+            Set<UUID> copy = new HashSet<>(possible);
+            copy.remove(id);
+            getAllPossible(out, copy, target, source, game, myID);
+            target.remove(id);
+        }
+    }
+    @Override
+    public boolean chooseTarget(Outcome outcome, Target target, Ability source, Game game) {
+        //System.out.println("chooseTarget: " + source.toString());
+        if(PRINT_CHOOSE_DIALOGUES) System.out.println("CALLING CHOOSE TARGET: " + (source == null ? "null" : source.toString()));
+        if(chooseTargetCount < chooseTargetAction.size()) {
+            for(UUID id : chooseTargetAction.get(chooseTargetCount)) {
+                if(!target.canTarget(getId(), id, source, game)) continue;
+                target.addTarget(id, source, game);
+                if(PRINT_CHOOSE_DIALOGUES) System.out.printf("tried target: %s ", game.getObject(id).toString());
+            }
+            if(PRINT_CHOOSE_DIALOGUES) System.out.println();
+            chooseTargetCount++;
+            return true;
+        }
+        Set<UUID> possible = target.possibleTargets(getId(), game);
+        getAllPossible(chooseTargetOptions, possible, target.copy(), source, game, getId());
+        game.pause();
+        lastToAct = true;
+        nextAction = NextAction.CHOOSE_TARGET;
+        return super.chooseTarget(outcome, target, source, game);
+    }
+    @Override
+    public boolean choose(Outcome outcome, Target target, Ability source, Game game, Map<String, Serializable> options) {
+        //reroute to chooseTarget
+        if(true) {
+            //reroute to mcts simulator
+            return chooseTarget(outcome, target, source, game);
+        } else {
+            //reroute to default
+            return super.choose(outcome, target, source, game, options);
+        }
+    }
 }
diff --git a/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/PriorityNextAction.java b/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/PriorityNextAction.java
index 353522c0a0..f176ea9d08 100644
--- a/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/PriorityNextAction.java
+++ b/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/PriorityNextAction.java
@@ -3,6 +3,7 @@ package mage.player.ai;
 import mage.abilities.Ability;
 import mage.abilities.ActivatedAbility;
 import mage.game.Game;
+import mage.game.GameState;
 
 import java.util.ArrayList;
 import java.util.List;
@@ -20,12 +21,21 @@ public class PriorityNextAction implements MCTSNodeNextAction{
         for (Ability ability: abilities) {
             Game sim = game.createSimulationForAI();
             MCTSPlayer simPlayer = (MCTSPlayer) sim.getPlayer(player.getId());
-            boolean success = simPlayer.activateAbility((ActivatedAbility)ability, sim);
-            if(!success) continue;//failsafe
+            boolean success = simPlayer.activateAbility((ActivatedAbility)ability.copy(), sim);
+            if(!success) {
+                if(MCTSPlayer.PRINT_CHOOSE_DIALOGUES) System.out.println("PRIORITY FAILSAFE TRIGGERED: " + ability.toString());
+                continue;//failsafe
+            }
             sim.resume();
-            children.add(new MCTSNode(node, sim, ability));
+            ComputerPlayerMCTS.shuffleUnknowns(sim, node.targetPlayer);
+            children.add(new MCTSNode(node, sim, ability.copy()));
         }
 
         return children;
     }
+
+    @Override
+    public void applyAction(MCTSNode node, MCTSPlayer player, Game game) {
+        player.activateAbility((ActivatedAbility) node.getAction(), game);
+    }
 }
diff --git a/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/SelectAttackersNextAction.java b/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/SelectAttackersNextAction.java
index 3a3919c948..bb1aba9393 100644
--- a/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/SelectAttackersNextAction.java
+++ b/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/SelectAttackersNextAction.java
@@ -4,6 +4,7 @@ import mage.game.Game;
 
 import java.util.ArrayList;
 import java.util.List;
+import java.util.Set;
 import java.util.UUID;
 
 import static mage.player.ai.MCTSNode.getAttacks;
@@ -30,4 +31,13 @@ public class SelectAttackersNextAction implements MCTSNodeNextAction{
 
         return children;
     }
+
+    @Override
+    public void applyAction(MCTSNode node, MCTSPlayer player, Game game) {
+        UUID defenderId = game.getOpponents(player.getId()).iterator().next();
+        Set<UUID> attack = node.combat.getAttackers();
+        for (UUID attackerId: attack) {
+            player.declareAttacker(attackerId, defenderId, game, false);
+        }
+    }
 }
diff --git a/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/SelectBlockersNextAction.java b/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/SelectBlockersNextAction.java
index def9823a49..a524d92397 100644
--- a/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/SelectBlockersNextAction.java
+++ b/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/SelectBlockersNextAction.java
@@ -23,6 +23,7 @@ public class SelectBlockersNextAction implements MCTSNodeNextAction{
             MCTSPlayer simPlayer = (MCTSPlayer) sim.getPlayer(player.getId());
             List<CombatGroup> groups = sim.getCombat().getGroups();
             for (int i = 0; i < groups.size(); i++) {
+                if(groups.get(i).getAttackers().isEmpty()) continue;//failsafe
                 if (i < block.size()) {
                     for (UUID blockerId : block.get(i)) {
                         simPlayer.declareBlocker(simPlayer.getId(), blockerId, groups.get(i).getAttackers().get(0), sim);
@@ -35,4 +36,18 @@ public class SelectBlockersNextAction implements MCTSNodeNextAction{
 
         return children;
     }
+
+    @Override
+    public void applyAction(MCTSNode node, MCTSPlayer player, Game game) {
+        List<CombatGroup> groups = game.getCombat().getGroups();
+        List<CombatGroup> block = node.combat.getGroups();
+        for (int i = 0; i < groups.size(); i++) {
+            if(groups.get(i).getAttackers().isEmpty()) continue;//failsafe
+            if (i < block.size()) {
+                for (UUID blockerId : block.get(i).getBlockers()) {
+                    player.declareBlocker(player.getId(), blockerId, groups.get(i).getAttackers().get(0), game);
+                }
+            }
+        }
+    }
 }
diff --git a/Mage.Tests/UWTempo.dck b/Mage.Tests/UWTempo.dck
new file mode 100644
index 0000000000..8aa53c714c
--- /dev/null
+++ b/Mage.Tests/UWTempo.dck
@@ -0,0 +1,30 @@
+4 [LCI:63] Malcolm, Alluring Scoundrel
+4 [MKM:273] Island
+4 [DSK:30] Sheltered by Ghosts
+4 [ONE:33] Skrelv, Defector Mite
+4 [DMU:44] Combat Research
+2 [DMU:252] Plaza of Heroes
+4 [MKM:221] No More Lies
+4 [DMU:243] Adarkar Wastes
+4 [ONE:258] Seachrome Coast
+2 [MKM:264] Meticulous Archive
+1 [ONE:254] Mirrex
+2 [DSK:29] Shardmage's Rescue
+3 [DSK:259] Floodfarm Verge
+2 [BRO:26] Soul Partition
+2 [STA:18] Negate
+4 [BLB:54] Kitsa, Otterball Elite
+4 [DFT:39] Bounce Off
+2 [BIG:23] Lost Jitte
+2 [NEO:80] Spell Pierce
+2 [WOE:66] Sleep-Cursed Faerie
+SB: 3 [MOM:13] Elspeth's Smite
+SB: 2 [AKR:33] Rest in Peace
+SB: 2 [MKM:13] Doorkeeper Thrull
+SB: 2 [NEO:80] Spell Pierce
+SB: 2 [LCI:81] Tishana's Tidebinder
+SB: 1 [STA:18] Negate
+SB: 1 [FDN:44] Kaito, Cunning Infiltrator
+SB: 2 [OTJ:4] Aven Interrupter
+LAYOUT MAIN:(1,1)(NONE,false,50)|([LCI:63],[LCI:63],[LCI:63],[LCI:63],[MKM:273],[MKM:273],[MKM:273],[MKM:273],[DSK:30],[DSK:30],[DSK:30],[DSK:30],[ONE:33],[ONE:33],[ONE:33],[ONE:33],[DMU:44],[DMU:44],[DMU:44],[DMU:44],[DMU:252],[DMU:252],[MKM:221],[MKM:221],[MKM:221],[MKM:221],[DMU:243],[DMU:243],[DMU:243],[DMU:243],[ONE:258],[ONE:258],[ONE:258],[ONE:258],[MKM:264],[MKM:264],[ONE:254],[DSK:29],[DSK:29],[DSK:259],[DSK:259],[DSK:259],[BRO:26],[BRO:26],[STA:18],[STA:18],[BLB:54],[BLB:54],[BLB:54],[BLB:54],[DFT:39],[DFT:39],[DFT:39],[DFT:39],[BIG:23],[BIG:23],[NEO:80],[NEO:80],[WOE:66],[WOE:66])
+LAYOUT SIDEBOARD:(1,1)(NONE,false,50)|([MOM:13],[MOM:13],[AKR:33],[MKM:13],[MKM:13],[NEO:80],[NEO:80],[MOM:13],[AKR:33],[LCI:81],[LCI:81],[STA:18],[FDN:44],[OTJ:4],[OTJ:4])
diff --git a/Mage.Tests/actions_mapping.ser b/Mage.Tests/actions_mapping.ser
index 6dcce6c117..0a511d4b1b 100644
Binary files a/Mage.Tests/actions_mapping.ser and b/Mage.Tests/actions_mapping.ser differ
diff --git a/Mage.Tests/features_mapping.ser b/Mage.Tests/features_mapping.ser
deleted file mode 100644
index 083a7b66e8..0000000000
Binary files a/Mage.Tests/features_mapping.ser and /dev/null differ
diff --git a/Mage.Tests/simplegreen.dck b/Mage.Tests/simplegreen.dck
new file mode 100644
index 0000000000..56c729ba45
--- /dev/null
+++ b/Mage.Tests/simplegreen.dck
@@ -0,0 +1,13 @@
+NAME:simplegreen
+4 [LCI:178] Cenote Scout
+24 [SNC:280] Forest
+4 [ONE:167] Evolving Adaptive
+4 [MKM:160] Flourishing Bloom-Kin
+4 [LCI:208] Pugnacious Hammerskull
+4 [DMU:161] Elfhame Wurm
+4 [LCI:191] Hulking Raptor
+4 [DFT:165] Hazard of the Dunes
+4 [ONE:170] Ichorspit Basilisk
+4 [J21:580] Grizzly Bears
+LAYOUT MAIN:(1,1)(NONE,false,50)|([LCI:178],[LCI:178],[LCI:178],[LCI:178],[SNC:280],[SNC:280],[SNC:280],[SNC:280],[SNC:280],[SNC:280],[SNC:280],[SNC:280],[SNC:280],[SNC:280],[SNC:280],[SNC:280],[SNC:280],[SNC:280],[SNC:280],[SNC:280],[SNC:280],[SNC:280],[SNC:280],[SNC:280],[SNC:280],[SNC:280],[SNC:280],[SNC:280],[ONE:167],[ONE:167],[ONE:167],[ONE:167],[MKM:160],[MKM:160],[MKM:160],[MKM:160],[LCI:208],[LCI:208],[LCI:208],[LCI:208],[DMU:161],[DMU:161],[DMU:161],[DMU:161],[LCI:191],[LCI:191],[LCI:191],[LCI:191],[DFT:165],[DFT:165],[DFT:165],[DFT:165],[ONE:170],[ONE:170],[ONE:170],[ONE:170],[J21:580],[J21:580],[J21:580],[J21:580])
+LAYOUT SIDEBOARD:(0,0)(NONE,false,50)|
diff --git a/Mage.Tests/src/test/java/org/mage/test/AI/RL/GenerateMappings.java b/Mage.Tests/src/test/java/org/mage/test/AI/RL/GenerateMappings.java
new file mode 100644
index 0000000000..861bac7b8f
--- /dev/null
+++ b/Mage.Tests/src/test/java/org/mage/test/AI/RL/GenerateMappings.java
@@ -0,0 +1,105 @@
+package org.mage.test.AI.RL;
+
+import mage.constants.MultiplayerAttackOption;
+import mage.constants.PhaseStep;
+import mage.constants.RangeOfInfluence;
+import mage.game.Game;
+import mage.game.GameException;
+import mage.game.TwoPlayerDuel;
+import mage.game.mulligan.MulliganType;
+import mage.player.ai.*;
+import mage.util.RandomUtil;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+import org.mage.test.player.TestComputerPlayer7;
+import org.mage.test.player.TestComputerPlayerPureMonteCarlo;
+import org.mage.test.player.TestPlayer;
+import org.mage.test.serverside.base.CardTestPlayerBaseAI;
+
+import java.io.*;
+import java.nio.file.Files;
+import java.nio.file.Paths;
+import java.util.*;
+
+public class GenerateMappings extends MinimaxVectorExtractionTests {
+
+
+    @Override
+    protected TestPlayer createPlayer(String name, RangeOfInfluence rangeOfInfluence) {
+        if (getFullSimulatedPlayers().contains(name)) {
+            if(name.equals("PlayerA")) {
+                TestComputerPlayerPureMonteCarlo pmc = new TestComputerPlayerPureMonteCarlo(name, RangeOfInfluence.ONE, getSkillLevel());
+                TestPlayer testPlayer = new TestPlayer(pmc);
+                testPlayer.setAIPlayer(true); // enable full AI support (game simulations) for all turns by default
+                return testPlayer;
+            } else {
+                TestComputerPlayer7 t7 = new TestComputerPlayer7(name, RangeOfInfluence.ONE, getSkillLevel());
+                TestPlayer testPlayer = new TestPlayer(t7);
+                testPlayer.setAIPlayer(true); // enable full AI support (game simulations) for all turns by default
+                return testPlayer;
+            }
+        }
+        return super.createPlayer(name, rangeOfInfluence);
+    }
+    @Override
+    public void init_seed() {
+        seed = RandomUtil.nextInt();
+        //seed = -1421792887;
+        seed = 233400479;
+        System.out.printf("USING SEED: %d\n", seed);
+        RandomUtil.setSeed(seed);
+    }
+    @Override
+    public void set_encoder() {
+        ComputerPlayerPureMCTS pmc = (ComputerPlayerPureMCTS)playerA.getComputerPlayer();
+        pmc.setEncoder(encoder);
+        encoder.setAgent(playerA.getId());
+        encoder.setOpponent(playerB.getId());
+    }
+    @Test
+    public void print_current_ignore_list() {
+        System.out.printf("IGNORE LIST SIZE: %d\n", encoder.ignoreList.size());
+        System.out.printf("REDUCED VECTOR SIZE: %d\n", StateEncoder.indexCount - encoder.ignoreList.size());
+        System.out.print("RAW TO REDUCED MAPPING: ");
+        System.out.println();
+        System.out.println(encoder.ignoreList.toString());
+    }
+    /**
+     * uses saved list of actions and states to make a labeled vector batch for training
+     */
+
+    @Test
+    public void make_ignore_X_50() {
+        int maxTurn = 50;
+        Features.printOldFeatures = false;
+        for(int i = 0; i < 50; i++) {
+            setStrictChooseMode(true);
+            setStopAt(maxTurn, PhaseStep.END_TURN);
+            execute();
+            reset_game();
+            System.out.printf("GAME #%d RESET... NEW GAME STARTING\n", i+1);
+        }
+        Set<Integer> newIgnore = new HashSet<>(FeatureMerger.computeIgnoreList(encoder.macroStateVectors));
+        Set<Integer> oldIgnore = new HashSet<>(encoder.ignoreList);
+        encoder.ignoreList = combine_ignore_lists(oldIgnore, newIgnore);
+        //actions = new HashMap<>(ActionEncoder.actionMap);
+        persistData();
+        System.out.printf("IGNORE LIST SIZE: %d\n", encoder.ignoreList.size());
+        System.out.printf("REDUCED VECTOR SIZE: %d\n", StateEncoder.indexCount - encoder.ignoreList.size());
+        //encoder.ignoreList = new HashSet<>(ignore);
+
+    }
+    /**
+     * make a training set of 50 games
+     */
+    @After
+    public void print_vector_size() {
+        System.out.printf("FINAL (unreduced) VECTOR SIZE: %d\n", StateEncoder.indexCount);
+        System.out.printf("FINAL ACTION VECTOR SIZE: %d\n", ActionEncoder.indexCount);
+        for(String s : ActionEncoder.actionMap.keySet()) {
+            System.out.printf("[%s => %d] ", s, ActionEncoder.actionMap.get(s));
+        }
+        System.out.println();
+    }
+}
diff --git a/Mage.Tests/src/test/java/org/mage/test/AI/RL/MCTS2Tests.java b/Mage.Tests/src/test/java/org/mage/test/AI/RL/MCTS2Tests.java
index f39fea7a20..b9d287b47c 100644
--- a/Mage.Tests/src/test/java/org/mage/test/AI/RL/MCTS2Tests.java
+++ b/Mage.Tests/src/test/java/org/mage/test/AI/RL/MCTS2Tests.java
@@ -1,5 +1,6 @@
 package org.mage.test.AI.RL;
 
+import ai.onnxruntime.OrtException;
 import mage.constants.MultiplayerAttackOption;
 import mage.constants.PhaseStep;
 import mage.constants.RangeOfInfluence;
@@ -37,8 +38,8 @@ public class MCTS2Tests extends CardTestPlayerBaseAI {
     @Override
     protected Game createNewGameAndPlayers() throws GameException, FileNotFoundException {
         Game game = new TwoPlayerDuel(MultiplayerAttackOption.LEFT, RangeOfInfluence.ONE, MulliganType.GAME_DEFAULT.getMulligan(0), 60, 20, 7);
-        playerA = createPlayer(game, "PlayerA", "C:\\Users\\WillWroble\\Documents\\" + deckNameA);
-        playerB = createPlayer(game, "PlayerB", "C:\\Users\\WillWroble\\Documents\\" + deckNameB);
+        playerA = createPlayer(game, "PlayerA", "C:\\Users\\owner\\Documents\\" + deckNameA);
+        playerB = createPlayer(game, "PlayerB", "C:\\Users\\owner\\Documents\\" + deckNameB);
         return game;
     }
     @Override
@@ -85,8 +86,7 @@ public class MCTS2Tests extends CardTestPlayerBaseAI {
         // simple test of 5 turns
         int maxTurn = 50;
 
-        //addCard(Zone.HAND, playerA, "Fauna Shaman", 3);
-        //setStrictChooseMode(true);
+        setStrictChooseMode(true);
         setStopAt(maxTurn, PhaseStep.END_TURN);
         execute();
 
diff --git a/Mage.Tests/src/test/java/org/mage/test/AI/RL/MCTS2WithNNTests.java b/Mage.Tests/src/test/java/org/mage/test/AI/RL/MCTS2WithNNTests.java
new file mode 100644
index 0000000000..8c8ae2b94c
--- /dev/null
+++ b/Mage.Tests/src/test/java/org/mage/test/AI/RL/MCTS2WithNNTests.java
@@ -0,0 +1,360 @@
+package org.mage.test.AI.RL;
+
+import mage.constants.PhaseStep;
+import mage.constants.RangeOfInfluence;
+import mage.constants.Zone;
+import mage.player.ai.*;
+import mage.util.RandomUtil;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+import org.mage.test.player.*;
+
+import java.io.*;
+import java.util.*;
+
+import static org.apache.commons.lang3.ObjectUtils.min;
+
+public class MCTS2WithNNTests extends MinimaxVectorExtractionTests {
+
+    public static final String REPLAY_BUFFER_FILE = "replay_buffer.ser";
+    public static final String PATH_TO_MODEL = "models/Model1.onnx";
+    public static final int REPLAY_BUFFER_CAPACITY = 10000; // e.g., holds states from ~50 games
+    public ReplayBuffer replayBuffer;
+    public int wins = 0;
+    public int total = 0;
+    private final boolean useReplayBuffer = false;
+
+    @Override
+    protected TestPlayer createPlayer(String name, RangeOfInfluence rangeOfInfluence) {
+        if (getFullSimulatedPlayers().contains(name)) {
+            if(name.equals("PlayerA")) {
+                TestComputerPlayerMonteCarlo2 mcts2 = new TestComputerPlayerMonteCarlo2(name, RangeOfInfluence.ONE, getSkillLevel());
+                TestPlayer testPlayer = new TestPlayer(mcts2);
+                testPlayer.setAIPlayer(true); // enable full AI support (game simulations) for all turns by default
+                return testPlayer;
+            } else {
+                TestComputerPlayer8 t8 = new TestComputerPlayer8(name, RangeOfInfluence.ONE, getSkillLevel());
+                TestPlayer testPlayer = new TestPlayer(t8);
+                testPlayer.setAIPlayer(true); // enable full AI support (game simulations) for all turns by default
+                return testPlayer;
+            }
+        }
+        return super.createPlayer(name, rangeOfInfluence);
+    }
+    @Before
+    public void init_encoder() {
+        init_seed();
+        System.out.println("Setting up encoder");
+        encoder = new StateEncoder();
+        //ignore = new HashSet<>();
+        //actions = new HashMap<>();
+        // Try to load the persistent mapping from file
+        File mappingFile = new File(MAPPING_FILE);
+        if (mappingFile.exists()) {
+            try {
+                encoder.loadMapping(MAPPING_FILE);
+                System.out.println("Loaded persistent mapping from " + MAPPING_FILE);
+            } catch (IOException | ClassNotFoundException e) {
+                System.out.println("Failed to load mapping. Starting with a fresh mapping.");
+            }
+        } else {
+            System.out.println("No persistent mapping found. Starting fresh.");
+        }
+        //try to load persistent action mappings from file
+        File actionsFile = new File(ACTIONS_FILE);
+        if (actionsFile.exists()) {
+            try {
+                ActionEncoder.actionMap = (Map<String, Integer>) loadObject(ACTIONS_FILE);
+                ActionEncoder.indexCount = ActionEncoder.actionMap.size();
+                System.out.println("Loaded persistent mapping from " + ACTIONS_FILE);
+            } catch (IOException | ClassNotFoundException e) {
+                System.out.println("Failed to load mapping. Starting with a fresh mapping.");
+            }
+        } else {
+            System.out.println("No persistent mapping found. Starting fresh.");
+        }
+        //also set up buffer
+        if(useReplayBuffer) {
+            File bufferFile = new File(REPLAY_BUFFER_FILE);
+            if (bufferFile.exists()) {
+                try {
+                    replayBuffer = (ReplayBuffer) loadObject(REPLAY_BUFFER_FILE);
+                    System.out.printf("Loaded Replay Buffer with %d states from %s%n", replayBuffer.size(), REPLAY_BUFFER_FILE);
+                } catch (IOException | ClassNotFoundException e) {
+                    System.out.println("Failed to load Replay Buffer. Starting with a fresh one.");
+                    replayBuffer = new ReplayBuffer(REPLAY_BUFFER_CAPACITY);
+                }
+            } else {
+                System.out.println("No Replay Buffer found. Starting fresh.");
+                replayBuffer = new ReplayBuffer(REPLAY_BUFFER_CAPACITY);
+            }
+        }
+        set_encoder();
+        labeledStates = new ArrayList<>();
+    }
+    @Override
+    public void init_seed() {
+        seed = RandomUtil.nextInt();
+        //seed = -1421792887;
+        //seed = 233400479;
+        //seed = 1603827803;
+        //seed = -99205609;
+
+        //seed = 144516733;
+        //seed = 197732112;
+        //seed = -781685651;
+        //seed = 2036403658;
+        //seed = -1702733670;
+        //seed = 1617973009;
+        //seed = 1735298645;
+        //seed = -1943293127;
+        //-seed = -1018550371;
+        //seed = 67231982;
+        //seed = 1205983369;
+        System.out.printf("USING SEED: %d\n", seed);
+        RandomUtil.setSeed(seed);
+    }
+    @Override
+    public void set_encoder() {
+        ComputerPlayerMCTS2 mcts2 = (ComputerPlayerMCTS2) playerA.getComputerPlayer();
+        mcts2.clearTree();
+        MCTSNode.clearCaches();
+        ComputerPlayer8 c8 = (ComputerPlayer8)playerB.getComputerPlayer();
+        c8.setEncoder(encoder);
+        mcts2.setEncoder(encoder);
+        mcts2.setBuffer(replayBuffer);
+        mcts2.initNN(PATH_TO_MODEL);
+        encoder.setAgent(playerA.getId());
+        encoder.setOpponent(playerB.getId());
+    }
+    @Override
+    public void create_labeled_states() {
+        total++;
+        if(playerA.hasWon()) wins++;
+        int N = encoder.macroStateVectors.size();
+        double  = 0.99;          // discount factor
+        double  = 0.5;           // how much weight to give the minimax estimate vs. terminal
+
+        labeledStateBatch.clear();
+        for(int i = 0; i < N; i++) {
+            Set<Integer> state = encoder.macroStateVectors.get(i);
+            double[] action = ActionEncoder.actionVectors.get(i);
+            double normScore = encoder.stateScores.get(i);
+
+            boolean win = playerA.hasWon();
+            double terminal = win ? +1.0 : -1.0;
+            double discount = Math.pow(, N - i - 1);
+
+            double blended =  * normScore + (1.0 - ) * terminal * discount;
+
+            labeledStateBatch.add(new LabeledState(state, action, blended));
+        }
+        reset_vectors();
+    }
+    public void loadGame() {
+        if (replayBuffer.size() == 0) {
+            System.out.println("Replay buffer is empty, skipping state load.");
+            reset_game();
+            return;
+        }
+        currentGame = replayBuffer.sample(1).get(0).copy();
+        TestPlayer newPlayerA = (TestPlayer) currentGame.getPlayer(playerA.getId());
+        TestPlayer newPlayerB = (TestPlayer) currentGame.getPlayer(playerB.getId());
+        newPlayerA.setMatchPlayer(playerA.getMatchPlayer());
+        newPlayerB.setMatchPlayer(playerB.getMatchPlayer());
+
+        //ComputerPlayerMCTS2 mcts2 = (ComputerPlayerMCTS2) newPlayerA.getComputerPlayer();
+        //mcts2.root = null;
+        //ComputerPlayerMCTS.macroState = ComputerPlayerMCTS.createCompleteMCTSGame(currentGame);
+
+        playerA.restore(newPlayerA);
+        playerB.restore(newPlayerB);
+        currentGame.getState().getPlayers().put(playerA.getId(), playerA);
+        currentGame.getState().getPlayers().put(playerB.getId(), playerB);
+        currentGame.setGameOptions(gameOptions);
+        set_encoder();
+    }
+    @Test
+    public void test_1_game() {
+        int maxTurn = 50;
+        Features.printOldFeatures = false;
+        addCard(Zone.HAND, playerA, "Sheltered by ghosts");
+        //ComputerPlayer.PRINT_DECISION_FALLBACKS = true;
+        ComputerPlayerMCTS2.SHOW_THREAD_INFO = true;
+        setStrictChooseMode(false);
+        setStopAt(maxTurn, PhaseStep.END_TURN);
+        execute();
+    }
+    @Test
+    public void test_save_1_game_to_buffer() {
+        int maxTurn = 50;
+        Features.printOldFeatures = false;
+        ComputerPlayerMCTS2.SHOW_THREAD_INFO = true;
+        setStrictChooseMode(true);
+        setStopAt(maxTurn, PhaseStep.END_TURN);
+        execute();
+        save_buffer();
+    }
+    @Test
+    public void test_1_game_from_buffer() {
+        loadGame();
+        int maxTurn = 50;
+        Features.printOldFeatures = false;
+        ComputerPlayerMCTS2.SHOW_THREAD_INFO = true;
+        setStrictChooseMode(true);
+        setStopAt(maxTurn, PhaseStep.END_TURN);
+        currentGame.resume();
+    }
+    @Test
+    public void print_data() {
+        System.out.printf("IGNORE LIST SIZE: %d\n", encoder.ignoreList.size());
+        System.out.printf("REDUCED VECTOR SIZE: %d\n", StateEncoder.indexCount - encoder.ignoreList.size());
+        System.out.printf("REPLAY BUFFER SIZE: %d\n", replayBuffer.size());
+    }
+    /**
+     * make a training set of 50 games
+     */
+    @Test
+    public void make_train_ds_X_50() {
+        int maxTurn = 50;
+        Features.printOldFeatures = false;
+        ComputerPlayerMCTS2.SHOW_THREAD_INFO = true;
+        //MCTSPlayer.PRINT_CHOOSE_DIALOGUES = true;
+        //ComputerPlayer.PRINT_DECISION_FALLBACKS = true;
+        for(int i = 0; i < 250; i++) {
+            setStrictChooseMode(false);
+            setStopAt(maxTurn, PhaseStep.END_TURN);
+            execute();
+            create_labeled_states();
+            labeledStates.addAll(labeledStateBatch);
+            labeledStateBatch.clear();
+            reset_game();
+            System.out.printf("GAME #%d RESET... NEW GAME STARTING\n", i+1);
+        }
+        Set<Integer> newIgnore = new HashSet<>(FeatureMerger.computeIgnoreListFromLS(labeledStates));
+        Set<Integer> oldIgnore = new HashSet<>(encoder.ignoreList);
+        encoder.ignoreList = combine_ignore_lists(oldIgnore, newIgnore);
+        compress_labeled_states();
+
+        print_labeled_states();
+        persistLabeledStates(TRAIN_OUT_FILE);
+        persistData();
+        //save_buffer();
+        System.out.printf("IGNORE LIST SIZE: %d\n", encoder.ignoreList.size());
+        System.out.printf("REDUCED VECTOR SIZE: %d\n", StateEncoder.indexCount - encoder.ignoreList.size());
+        System.out.printf("WINRATE: %f\n", wins*1.0/total);
+    }
+    @Test
+    public void make_train_ds_50_from_buffer() {
+        int maxTurn = 50;
+        Features.printOldFeatures = false;
+        ComputerPlayerMCTS2.SHOW_THREAD_INFO = true;
+        for(int i = 0; i < 50; i++) {
+            loadGame();
+            setStrictChooseMode(false);
+            setStopAt(maxTurn, PhaseStep.END_TURN);
+            currentGame.resume();
+            create_labeled_states();
+            labeledStates.addAll(labeledStateBatch);
+            labeledStateBatch.clear();
+            reset_game();
+            System.out.printf("GAME #%d RESET... NEW GAME STARTING\n", i+1);
+        }
+        Set<Integer> newIgnore = new HashSet<>(FeatureMerger.computeIgnoreListFromLS(labeledStates));
+        Set<Integer> oldIgnore = new HashSet<>(encoder.ignoreList);
+        encoder.ignoreList = combine_ignore_lists(oldIgnore, newIgnore);
+        compress_labeled_states();
+
+        print_labeled_states();
+        persistLabeledStates(TRAIN_OUT_FILE);
+        persistData();
+        save_buffer();
+        System.out.printf("IGNORE LIST SIZE: %d\n", encoder.ignoreList.size());
+        System.out.printf("REDUCED VECTOR SIZE: %d\n", StateEncoder.indexCount - encoder.ignoreList.size());
+        System.out.printf("WINRATE: %f\n", wins*1.0/total);
+    }
+    /**
+     * make a testing/validation set of 20 random states from each of 20 games
+     */
+    @Test
+    public void make_test_ds_X_20() {
+        int maxTurn = 50;
+        Features.printOldFeatures = false;
+        ComputerPlayerMCTS2.SHOW_THREAD_INFO = true;
+        //ComputerPlayer.PRINT_DECISION_FALLBACKS = true;
+        for(int i = 0; i < 20; i++) {
+            setStrictChooseMode(false);
+            setStopAt(maxTurn, PhaseStep.END_TURN);
+            execute();
+            create_labeled_states();
+            Collections.shuffle(labeledStateBatch);
+            labeledStates.addAll(labeledStateBatch.subList(0, min(20, labeledStateBatch.size())));
+            labeledStateBatch.clear();
+            reset_game();
+            System.out.printf("GAME #%d RESET... NEW GAME STARTING\n", i+1);
+        }
+        Set<Integer> newIgnore = new HashSet<>(FeatureMerger.computeIgnoreListFromLS(labeledStates));
+        Set<Integer> oldIgnore = new HashSet<>(encoder.ignoreList);
+        encoder.ignoreList = combine_ignore_lists(oldIgnore, newIgnore);
+        compress_labeled_states();
+
+        print_labeled_states();
+        persistLabeledStates(TEST_OUT_FILE);
+        persistData();
+        System.out.printf("IGNORE LIST SIZE: %d\n", encoder.ignoreList.size());
+        System.out.printf("REDUCED VECTOR SIZE: %d\n", StateEncoder.indexCount - encoder.ignoreList.size());
+        System.out.printf("WINRATE: %f\n", wins*1.0/total);
+    }
+    /**
+     * make a testing/validation set of 5 random states from each of 50 games (using replay buffer)
+     */
+    @Test
+    public void make_test_ds_from_buffer_X_50() {
+        int maxTurn = 50;
+        Features.printOldFeatures = false;
+        ComputerPlayerMCTS2.SHOW_THREAD_INFO = true;
+        //ComputerPlayer.PRINT_DECISION_FALLBACKS = true;
+        for(int i = 0; i < 50; i++) {
+            loadGame();
+            setStrictChooseMode(false);
+            setStopAt(maxTurn, PhaseStep.END_TURN);
+            currentGame.resume();
+            create_labeled_states();
+            Collections.shuffle(labeledStateBatch);
+            labeledStates.addAll(labeledStateBatch.subList(0, min(5, labeledStateBatch.size())));
+            labeledStateBatch.clear();
+            reset_game();
+            System.out.printf("GAME #%d RESET... NEW GAME STARTING\n", i+1);
+        }
+        Set<Integer> newIgnore = new HashSet<>(FeatureMerger.computeIgnoreListFromLS(labeledStates));
+        Set<Integer> oldIgnore = new HashSet<>(encoder.ignoreList);
+        encoder.ignoreList = combine_ignore_lists(oldIgnore, newIgnore);
+        compress_labeled_states();
+
+        print_labeled_states();
+        persistLabeledStates(TEST_OUT_FILE);
+        persistData();
+        System.out.printf("IGNORE LIST SIZE: %d\n", encoder.ignoreList.size());
+        System.out.printf("REDUCED VECTOR SIZE: %d\n", StateEncoder.indexCount - encoder.ignoreList.size());
+        System.out.printf("WINRATE: %f\n", wins*1.0/total);
+    }
+    public void save_buffer() {
+        try {
+            saveObject(replayBuffer, REPLAY_BUFFER_FILE);
+            System.out.printf("Persisted replay buffer to %s%n", REPLAY_BUFFER_FILE);
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+    }
+    @After
+    public void print_vector_size() {
+        System.out.printf("FINAL (unreduced) VECTOR SIZE: %d\n", StateEncoder.indexCount);
+        System.out.printf("FINAL ACTION VECTOR SIZE: %d\n", ActionEncoder.indexCount);
+        if(replayBuffer != null) System.out.printf("REPLAY BUFFER SIZE: %d\n", replayBuffer.size());
+        for(String s : ActionEncoder.actionMap.keySet()) {
+            System.out.printf("[%s => %d] ", s, ActionEncoder.actionMap.get(s));
+        }
+        System.out.println();
+    }
+}
diff --git a/Mage.Tests/src/test/java/org/mage/test/AI/RL/MCTSEncoderTests.java b/Mage.Tests/src/test/java/org/mage/test/AI/RL/MCTSEncoderTests.java
index c893a69894..f6b4018cda 100644
--- a/Mage.Tests/src/test/java/org/mage/test/AI/RL/MCTSEncoderTests.java
+++ b/Mage.Tests/src/test/java/org/mage/test/AI/RL/MCTSEncoderTests.java
@@ -39,8 +39,8 @@ public class MCTSEncoderTests extends CardTestPlayerBaseAI {
                 RangeOfInfluence.ONE,
                 MulliganType.GAME_DEFAULT.getMulligan(0),
                 60, 20, 7);
-        playerA = createPlayer(game, "PlayerA", "C:\\Users\\WillWroble\\Documents\\" + deckNameA);
-        playerB = createPlayer(game, "PlayerB", "C:\\Users\\WillWroble\\Documents\\" + deckNameB);
+        playerA = createPlayer(game, "PlayerA", "C:\\Users\\owner\\Documents\\" + deckNameA);
+        playerB = createPlayer(game, "PlayerB", "C:\\Users\\owner\\Documents\\" + deckNameB);
         return game;
     }
 
@@ -72,7 +72,6 @@ public class MCTSEncoderTests extends CardTestPlayerBaseAI {
     }
 
     public void set_encoder() {
-        // Assumes ComputerPlayerMCTS2 has a setEncoder(StateEncoder) method
         ComputerPlayerMCTS2 cp = (ComputerPlayerMCTS2) playerA.getComputerPlayer();
         cp.setEncoder(encoder);
         encoder.setAgent(playerA.getId());
@@ -147,7 +146,7 @@ public class MCTSEncoderTests extends CardTestPlayerBaseAI {
             reset_game();
             System.out.printf("GAME #%d RESET... NEW GAME STARTING\n", i+1);
         }
-        Set<Integer> ignore = FeatureMerger.computeIgnoreList(encoder.stateVectors, 1.00);
+        Set<Integer> ignore = FeatureMerger.computeIgnoreList(encoder.macroStateVectors);
         System.out.printf("IGNORE LIST SIZE: %d\n", ignore.size());
         System.out.printf("REDUCED VECTOR SIZE: %d\n", StateEncoder.indexCount - ignore.size());
     }
diff --git a/Mage.Tests/src/test/java/org/mage/test/AI/RL/VectorExtractionTests.java b/Mage.Tests/src/test/java/org/mage/test/AI/RL/MinimaxVectorExtractionTests.java
similarity index 59%
rename from Mage.Tests/src/test/java/org/mage/test/AI/RL/VectorExtractionTests.java
rename to Mage.Tests/src/test/java/org/mage/test/AI/RL/MinimaxVectorExtractionTests.java
index 5d1270c5c8..465f878a76 100644
--- a/Mage.Tests/src/test/java/org/mage/test/AI/RL/VectorExtractionTests.java
+++ b/Mage.Tests/src/test/java/org/mage/test/AI/RL/MinimaxVectorExtractionTests.java
@@ -8,6 +8,7 @@ import mage.game.GameException;
 import mage.game.TwoPlayerDuel;
 import mage.game.mulligan.MulliganType;
 import mage.player.ai.*;
+import mage.util.RandomUtil;
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
@@ -21,19 +22,23 @@ import java.nio.file.Files;
 import java.nio.file.Paths;
 import java.util.*;
 
-public class VectorExtractionTests extends CardTestPlayerBaseAI {
-    private String deckNameA = "simplegreen.dck"; //simplegreen, UWTempo
+import static java.lang.Integer.min;
+
+public class MinimaxVectorExtractionTests extends CardTestPlayerBaseAI {
+    private String deckNameA = "UWTempo.dck"; //simplegreen, UWTempo
     private String deckNameB = "simplegreen.dck";
-    private List<LabeledState> labeledStates = new ArrayList<>();
-    private List<LabeledState> labeledStateBatch = new ArrayList<>();
-    private StateEncoder encoder;
+    public List<LabeledState> labeledStates = new ArrayList<>();
+    public List<LabeledState> labeledStateBatch = new ArrayList<>();
+    public StateEncoder encoder;
+    public int seed;
+
     //private Set<Integer> ignore;
     //private Map<String, Integer> actions;
     // File where the persistent mapping is stored
-    private static final String MAPPING_FILE = "features_mapping.ser";
-    private static final String ACTIONS_FILE = "actions_mapping.ser";
-    private static final String TRAIN_OUT_FILE = "training.bin";
-    private static final String TEST_OUT_FILE = "testing.bin";
+    public static final String MAPPING_FILE = "features_mapping.ser";
+    public static final String ACTIONS_FILE = "actions_mapping.ser";
+    public static final String TRAIN_OUT_FILE = "training.bin";
+    public static final String TEST_OUT_FILE = "testing.bin";
 
 
     @Override
@@ -44,8 +49,8 @@ public class VectorExtractionTests extends CardTestPlayerBaseAI {
     @Override
     protected Game createNewGameAndPlayers() throws GameException, FileNotFoundException {
         Game game = new TwoPlayerDuel(MultiplayerAttackOption.LEFT, RangeOfInfluence.ONE, MulliganType.GAME_DEFAULT.getMulligan(0), 60, 20, 7);
-        playerA = createPlayer(game, "PlayerA", "C:\\Users\\WillWroble\\Documents\\" + deckNameA);
-        playerB = createPlayer(game, "PlayerB", "C:\\Users\\WillWroble\\Documents\\" + deckNameB);
+        playerA = createPlayer(game, "PlayerA",  deckNameA);
+        playerB = createPlayer(game, "PlayerB",  deckNameB);
         return game;
     }
     @Override
@@ -65,8 +70,14 @@ public class VectorExtractionTests extends CardTestPlayerBaseAI {
         }
         return super.createPlayer(name, rangeOfInfluence);
     }
+    public void init_seed() {
+        seed = RandomUtil.nextInt();
+        System.out.printf("USING SEED: %d\n", seed);
+        RandomUtil.setSeed(seed);
+    }
     @Before
     public void init_encoder() {
+        init_seed();
         System.out.println("Setting up encoder");
         encoder = new StateEncoder();
         //ignore = new HashSet<>();
@@ -101,8 +112,8 @@ public class VectorExtractionTests extends CardTestPlayerBaseAI {
         labeledStates = new ArrayList<>();
     }
     public void set_encoder() {
-        ComputerPlayer8 c8 = (ComputerPlayer8)playerA.getComputerPlayer();
-        c8.setEncoder(encoder);
+        ComputerPlayer8 c8 = (ComputerPlayer8)playerA.getComputerPlayer(); c8.setEncoder(encoder);
+        //c8 = (ComputerPlayer8)playerB.getComputerPlayer(); c8.setEncoder(encoder);
         encoder.setAgent(playerA.getId());
         encoder.setOpponent(playerB.getId());
     }
@@ -118,97 +129,118 @@ public class VectorExtractionTests extends CardTestPlayerBaseAI {
 
     }
     public void reset_vectors() {
-        encoder.stateVectors.clear();
+        encoder.macroStateVectors.clear();
         encoder.stateScores.clear();
-        ActionEncoder.actionVectors.clear();
+        encoder.actionVectors.clear();
     }
 
     /**
      * uses saved list of actions and states to make a labeled vector batch for training
      */
     public void create_labeled_states() {
-        int N = encoder.stateVectors.size();
+        int N = encoder.macroStateVectors.size();
         double  = 0.99;          // discount factor
         double  = 0.5;           // how much weight to give the minimax estimate vs. terminal
 
         labeledStateBatch.clear();
         for(int i = 0; i < N; i++) {
-            // 1) decompress your raw state and action bits (you already have this)
-            boolean[] rawState = encoder.stateVectors.get(i);
-            boolean[] state = new boolean[4000];
-            for(int k = 0, j = 0; j < StateEncoder.indexCount && k < 4000; j++) {
-                if(!encoder.ignoreList.contains(j)) {
-                    state[k++] = rawState[j];
-                }
-            }
-            boolean[] action = ActionEncoder.actionVectors.get(i);
-
-            // 2) get your raw minimax score and normalize into [-1,+1]
-            double rawScore = encoder.stateScores.get(i);
-            //double normScore = rawScore / (double)Math.abs(GameStateEvaluator2.LOSE_GAME_SCORE);
-
-            double scale = 20000.0;              // or better yet: maxAbs(stateScores)
-            double normScore = Math.tanh(rawScore/scale);
+            Set<Integer> state = encoder.macroStateVectors.get(i);
+            double[] action = encoder.actionVectors.get(i);
+            double normScore = encoder.stateScores.get(i);
 
-
-            // 3) build your discounted terminal label in [-1,+1]
             boolean win = playerA.hasWon();
             double terminal = win ? +1.0 : -1.0;
             double discount = Math.pow(, N - i - 1);
 
-            // 4) blend them
             double blended =  * normScore + (1.0 - ) * terminal * discount;
 
-            // 5) store a single LabeledState with that double label
             labeledStateBatch.add(new LabeledState(state, action, blended));
         }
-
-        // shuffle before writing out / persisting
-        //Collections.shuffle(labeledStateBatch);
-
         reset_vectors();
     }
     public void print_labeled_states() {
         for (LabeledState ls : labeledStates) {
             StringBuilder sb1 = new StringBuilder();
-            for (int i = 0; i < 100; i++) {
-                sb1.append(ls.stateVector[i] ? "1" : "0");
-                //sb1.append(", ");
+            for (int i = 0; i < min(100, ls.stateVector.length); i++) {
+                sb1.append(ls.stateVector[i]);
+                sb1.append(" ");
+            }
+
+            System.out.printf("State: %s, Action: %s, Result: %s\n", sb1.toString(), Arrays.toString(ls.actionVector), ls.resultLabel);
+
+        }
+    }
+
+    /**
+     * can remove items from ignore list
+     * @param oldList
+     * @param newList
+     * @return
+     */
+    public Set<Integer> combine_ignore_lists(Set<Integer> oldList, Set<Integer> newList) {
+        Set<Integer> updatedIgnoreList = new HashSet<>();
+
+        int boundaryForOldFeatures = this.encoder.initialRawSize;
+
+
+        for (int i = 0; i < boundaryForOldFeatures; i++) {
+            if (oldList.contains(i) && newList.contains(i)) {
+                updatedIgnoreList.add(i);
             }
-            StringBuilder sb2 = new StringBuilder();
-            for (int i = 0; i < 100; i++) {
-                sb2.append(ls.actionVector[i] ? "1" : "0");
-                //sb2.append(", ");
+        }
+
+        for (Integer featureIndexInNewList : newList) {
+            if (featureIndexInNewList >= boundaryForOldFeatures) {
+                updatedIgnoreList.add(featureIndexInNewList);
             }
-            System.out.printf("State: %s, Action: %s, Result: %s\n", sb1.toString(), sb2.toString(), ls.resultLabel);
         }
+
+        return updatedIgnoreList;
+    }
+
+    /**
+     * use the current encoder's compression at the end so it can use the new ignore list
+     */
+    public void compress_labeled_states() {
+        for (LabeledState ls : labeledStates) {
+            ls.compress(encoder.getFeatures().ignoreList);
+        }
+    }
+    @Test
+    public void print_current_ignore_list() {
+        System.out.printf("IGNORE LIST SIZE: %d\n", encoder.getFeatures().ignoreList.size());
+        System.out.printf("REDUCED VECTOR SIZE: %d\n", encoder.getFeatures().localIndexCount.get() - encoder.getFeatures().ignoreList.size());
     }
     @Test
     public void make_ignore_X_50() {
         int maxTurn = 50;
         Features.printOldFeatures = false;
-        for(int i = 0; i < 50; i++) {
+        for(int i = 0; i < 10; i++) {
             setStrictChooseMode(true);
             setStopAt(maxTurn, PhaseStep.END_TURN);
             execute();
             reset_game();
             System.out.printf("GAME #%d RESET... NEW GAME STARTING\n", i+1);
         }
-        encoder.ignoreList = new HashSet<>(FeatureMerger.computeIgnoreList(encoder.stateVectors, 1.00));
+        //assert(!encoder.getFeatures().ignoreList.isEmpty());
+        Set<Integer> newIgnore = new HashSet<>(FeatureMerger.computeIgnoreList(encoder.macroStateVectors));
+        Set<Integer> oldIgnore = new HashSet<>(encoder.getFeatures().ignoreList);
+        encoder.getFeatures().ignoreList = combine_ignore_lists(oldIgnore, newIgnore);
         //actions = new HashMap<>(ActionEncoder.actionMap);
         persistData();
-        System.out.printf("IGNORE LIST SIZE: %d\n", encoder.ignoreList.size());
-        System.out.printf("REDUCED VECTOR SIZE: %d\n", StateEncoder.indexCount - encoder.ignoreList.size());
-        //encoder.ignoreList = new HashSet<>(ignore);
+        System.out.printf("IGNORE LIST SIZE: %d\n", encoder.getFeatures().ignoreList.size());
+        System.out.printf("REDUCED VECTOR SIZE: %d\n", encoder.getFeatures().localIndexCount.get() - encoder.getFeatures().ignoreList.size());
+        //encoder.getFeatures().ignoreList = new HashSet<>(ignore);
 
     }
     /**
      * make a training set of 50 games
      */
     @Test
-    public void make_train_ds_X_50() {
+    public void make_train_ds_X_250() {
         int maxTurn = 50;
-        for(int i = 0; i < 50; i++) {
+        Features.printOldFeatures = false;
+        for(int i = 0; i < 250; i++) {
             setStrictChooseMode(true);
             setStopAt(maxTurn, PhaseStep.END_TURN);
             execute();
@@ -218,10 +250,15 @@ public class VectorExtractionTests extends CardTestPlayerBaseAI {
             reset_game();
             System.out.printf("GAME #%d RESET... NEW GAME STARTING\n", i+1);
         }
-        //Collections.shuffle(labeledStates);
+        //Set<Integer> oldIgnore = new HashSet<>(encoder.getFeatures().ignoreList);
+        encoder.getFeatures().ignoreList = new HashSet<>(FeatureMerger.computeIgnoreListFromLS(labeledStates, 0, encoder.getFeatures().localIndexCount.get()));
+        compress_labeled_states();
+
         print_labeled_states();
         persistLabeledStates(TRAIN_OUT_FILE);
         persistData();
+        System.out.printf("IGNORE LIST SIZE: %d\n", encoder.getFeatures().ignoreList.size());
+        System.out.printf("REDUCED VECTOR SIZE: %d\n", encoder.getFeatures().localIndexCount.get() - encoder.getFeatures().ignoreList.size());
     }
 
     /**
@@ -230,44 +267,61 @@ public class VectorExtractionTests extends CardTestPlayerBaseAI {
     @Test
     public void make_test_ds_X_50() {
         int maxTurn = 50;
+        Features.printOldFeatures = false;
         for(int i = 0; i < 50; i++) {
             setStrictChooseMode(true);
             setStopAt(maxTurn, PhaseStep.END_TURN);
             execute();
             create_labeled_states();
-            labeledStates.addAll(labeledStateBatch.subList(0, 5));
+            //Collections.shuffle(labeledStateBatch);
+            labeledStates.addAll(labeledStateBatch);
             labeledStateBatch.clear();
             reset_game();
             System.out.printf("GAME #%d RESET... NEW GAME STARTING\n", i+1);
         }
+//        Set<Integer> newIgnore = new HashSet<>(FeatureMerger.computeIgnoreListFromLS(labeledStates));
+//        Set<Integer> oldIgnore = new HashSet<>(encoder.getFeatures().ignoreList);
+//        encoder.getFeatures().ignoreList = combine_ignore_lists(oldIgnore, newIgnore);
+        compress_labeled_states();
+
         print_labeled_states();
         persistLabeledStates(TEST_OUT_FILE);
         persistData();
+        System.out.printf("IGNORE LIST SIZE: %d\n", encoder.getFeatures().ignoreList.size());
+        System.out.printf("REDUCED VECTOR SIZE: %d\n", encoder.getFeatures().localIndexCount.get() - encoder.getFeatures().ignoreList.size());
     }
     @After
     public void print_vector_size() {
-        System.out.printf("FINAL (unreduced) VECTOR SIZE: %d\n", StateEncoder.indexCount);
+        System.out.printf("RAW VECTOR SIZE: %d\n", encoder.getFeatures().localIndexCount.get());
         System.out.printf("FINAL ACTION VECTOR SIZE: %d\n", ActionEncoder.indexCount);
         for(String s : ActionEncoder.actionMap.keySet()) {
             System.out.printf("[%s => %d] ", s, ActionEncoder.actionMap.get(s));
         }
         System.out.println();
     }
-    private void persistLabeledStates(String filename) {
-        try (DataOutputStream out = new DataOutputStream(
-                new BufferedOutputStream(new FileOutputStream(filename)))) {
+    public void persistLabeledStates(String filename) {
+        try (DataOutputStream out = new DataOutputStream(new BufferedOutputStream(Files.newOutputStream(Paths.get(filename))))) {
+
+            // 1) Header
             int n = labeledStates.size();
-            int S = labeledStates.get(0).stateVector.length;
-            int A = labeledStates.get(0).actionVector.length;
-            // Write header: #records, state-dim, action-dim
+
+            // 'S' now represents the TOTAL size of your global feature vocabulary.
+            // The constant should be updated to reflect this.
+            int S = encoder.getFeatures().localIndexCount.get();
+
+            // 'A' is still the size of the policy vector.
+            int A = 128;
+
+            // The new, simpler header:
             out.writeInt(n);
-            out.writeInt(S);
-            out.writeInt(A);
-            // Write raw data: one byte per boolean
+            out.writeInt(S); // Tells PyTorch num_embeddings for the EmbeddingBag
+            out.writeInt(A); // Tells PyTorch the size of the policy vector
+
+            // 2) Body
             for (LabeledState ls : labeledStates) {
-                for (boolean b : ls.stateVector) out.writeByte(b ? 1 : 0);
-                for (boolean b : ls.actionVector) out.writeByte(b ? 1 : 0);
-                out.writeDouble(ls.resultLabel);
+                // This now calls your MODIFIED LabeledState.persist() method,
+                // which writes a variable-length list of indices.
+                ls.persist(out);
             }
         } catch (IOException e) {
             e.printStackTrace();
diff --git a/Mage.Tests/src/test/java/org/mage/test/AI/RL/ParallelDataGenerator.java b/Mage.Tests/src/test/java/org/mage/test/AI/RL/ParallelDataGenerator.java
new file mode 100644
index 0000000000..121f7a1fc7
--- /dev/null
+++ b/Mage.Tests/src/test/java/org/mage/test/AI/RL/ParallelDataGenerator.java
@@ -0,0 +1,429 @@
+package org.mage.test.AI.RL;
+
+import mage.cards.decks.Deck;
+import mage.cards.decks.DeckCardLists;
+import mage.cards.decks.importer.DeckImporter;
+import mage.constants.*;
+import mage.game.*;
+import mage.game.match.Match;
+import mage.game.match.MatchOptions;
+import mage.game.mulligan.MulliganType;
+import mage.player.ai.*;
+import mage.util.RandomUtil;
+import org.junit.Test;
+import org.mage.test.player.TestComputerPlayer7;
+import org.mage.test.player.TestComputerPlayer8;
+import org.mage.test.player.TestPlayer;
+import org.mage.test.serverside.base.CardTestPlayerBaseAI;
+
+import java.io.*;
+import java.util.*;
+import java.util.concurrent.*;
+
+/**
+ * A dedicated, parallelized test class for generating training and testing data sets.
+ * This version is fully compatible with Java 1.8 and uses the correct, thread-safe
+ * game execution logic as defined by the test framework.
+ */
+public class ParallelDataGenerator extends CardTestPlayerBaseAI {
+
+    //region Configuration
+    // ============================ DATA GENERATION SETTINGS ============================
+    private static final int NUM_GAMES_TO_SIMULATE_TRAIN = 250;
+    private static final int NUM_GAMES_TO_SIMULATE_TEST = 50;
+    private static final int MAX_GAME_TURNS = 50;
+    private static final int MAX_CONCURRENT_GAMES = 8;
+
+    // =============================== DECK AND AI SETTINGS ===============================
+    private static final String DECK_A = "UWTempo.dck";
+    private static final String DECK_B = "simplegreen.dck";
+    private static final String MCTS_MODEL_PATH = "models/Model2.onnx";
+    private static final int MCTS_ROLLOUT_THREADS = 2;
+
+    // ================================== FILE PATHS ==================================
+    private static final String MAPPING_FILE = "features_mapping.ser";
+    private static final String ACTIONS_FILE = "actions_mapping.ser";
+    private static final String TRAIN_OUT_FILE = "training.bin";
+    private static final String TEST_OUT_FILE = "testing.bin";
+    // ================================== GLOBAL FIELDS ==================================
+    private Features finalFeatures;
+    private int initialRawSize;
+    private int previousRawSize;
+    //end region
+
+    /**
+     * A simple class to hold the results of a single game, compatible with Java 1.8.
+     */
+    private static class GameResult {
+        private final List<LabeledState> states;
+        private final boolean didPlayerAWin;
+
+        public GameResult(List<LabeledState> states, boolean didPlayerAWin) {
+            this.states = states;
+            this.didPlayerAWin = didPlayerAWin;
+        }
+
+        public List<LabeledState> getStates() {
+            return states;
+        }
+
+        public boolean didPlayerAWin() {
+            return didPlayerAWin;
+        }
+    }
+
+    @Test
+    public void print_mappings() {
+        //load base mapping
+        try {
+            finalFeatures = Features.loadMapping(MAPPING_FILE);
+            ActionEncoder.actionMap = (Map<String, Integer>) loadObject(ACTIONS_FILE);
+        } catch (IOException | ClassNotFoundException e) {
+            System.err.println("failed to load persistent mappings.");
+        }
+        finalFeatures.printFeatureTree(false);
+        System.out.println("Ignore list size: " + finalFeatures.ignoreList.size());
+        System.out.println("Ignore list:");
+        System.out.println(finalFeatures.ignoreList.toString());
+        System.out.println("Action map:");
+        String[] aMap = new String[ActionEncoder.actionMap.size()];
+        for (String s : ActionEncoder.actionMap.keySet()) {
+            //System.out.printf("[%s => %d] ", s, ActionEncoder.actionMap.get(s));
+            aMap[ActionEncoder.actionMap.get(s)] = s;
+        }
+        for (int i = 0; i < aMap.length; i++) {
+            System.out.println(i + " => " + aMap[i]);
+        }
+    }
+
+    @Test
+    public void generateTrainingAndTestingData() {
+
+        //load original mapping as starting point
+        finalFeatures = new Features();
+        initialRawSize = 0;
+        previousRawSize = 0;
+        //load base mapping
+        try {
+            finalFeatures = Features.loadMapping(MAPPING_FILE);
+            initialRawSize = finalFeatures.localIndexCount.get();
+            previousRawSize = finalFeatures.previousLocalIndexCount;
+        } catch (IOException | ClassNotFoundException e) {
+            System.err.println("failed to load persistent mappings.");
+        }
+        Features.printOldFeatures = false;
+        //Features.printNewFeatures = false;
+
+        System.out.println("\n=========================================");
+        System.out.println("    STARTING TESTING DATA GENERATION     ");
+        System.out.println("=========================================");
+
+        List<LabeledState> testingStates = runSimulations(NUM_GAMES_TO_SIMULATE_TEST);
+
+        System.out.println("=========================================");
+        System.out.println("   STARTING TRAINING DATA GENERATION     ");
+        System.out.println("=========================================");
+
+
+        List<LabeledState> trainingStates = runSimulations(NUM_GAMES_TO_SIMULATE_TRAIN);
+
+        //save both data files at once
+        processAndSaveData(trainingStates, testingStates);
+
+        System.out.println("\nData generation complete.");
+    }
+
+    private List<LabeledState> runSimulations(int numGames) {
+        int availableCores = Runtime.getRuntime().availableProcessors();
+        int poolSize = MAX_CONCURRENT_GAMES;
+        System.out.printf("Simulating %d games. Using thread pool of size %d on %d available cores.\n", numGames, poolSize, availableCores);
+
+        ExecutorService executor = Executors.newFixedThreadPool(poolSize);
+        List<Callable<GameResult>> tasks = new ArrayList<>();
+        for (int i = 0; i < numGames; i++) {
+            tasks.add(new Callable<GameResult>() {
+                @Override
+                public GameResult call() throws Exception {
+                    return runSingleGame();
+                }
+            });
+        }
+
+        List<LabeledState> allLabeledStates = new ArrayList<>();
+        int wins = 0;
+        int successfulGames = 0;
+        int failedGames = 0;
+        try {
+            List<Future<GameResult>> futures = executor.invokeAll(tasks);
+            executor.shutdown();
+
+            for (Future<GameResult> future : futures) {
+                try {
+                    // future.get() will block until the task is complete.
+                    GameResult result = future.get();
+                    allLabeledStates.addAll(result.getStates());
+                    if (result.didPlayerAWin()) {
+                        wins++;
+                    }
+                    successfulGames++;
+
+                } catch (ExecutionException e) {
+                    failedGames++;
+                    System.err.println("A game simulation failed and its result will be ignored. Cause: " + e.getCause());
+                    e.getCause().printStackTrace();
+                }
+                // The loop continues to the next future, ignoring the failed one.
+            }
+        } catch (InterruptedException e) {
+            System.err.println("Main simulation thread was interrupted. Shutting down.");
+            e.printStackTrace();
+            Thread.currentThread().interrupt();
+        }
+        System.out.printf("\n--- Simulation Summary ---\n");
+        System.out.printf("Total requested: %d games\n", numGames);
+        System.out.printf("Successful: %d\n", successfulGames);
+        System.out.printf("Failed: %d\n", failedGames);
+        System.out.printf("Player A win rate: %.2f%% (%d/%d)\n", (100.0 * wins / numGames), wins, numGames);
+        return allLabeledStates;
+    }
+
+    public void print_labeled_states(List<LabeledState> labeledStates) {
+        for (LabeledState ls : labeledStates) {
+            StringBuilder sb1 = new StringBuilder();
+            for (int i = 0; i < 100; i++) {
+                sb1.append(ls.stateVector[i]);
+                sb1.append(" ");
+            }
+
+            System.out.printf("State: %s, Action: %s, Result: %s\n", sb1.toString(), Arrays.toString(ls.actionVector), ls.resultLabel);
+
+        }
+    }
+
+    private void processAndSaveData(List<LabeledState> trainingStates, List<LabeledState> testingStates) {
+        List<LabeledState> allStates = new ArrayList<>(trainingStates);
+        allStates.addAll(testingStates);
+        if (allStates.isEmpty()) {
+            System.out.println("No states were generated, skipping file save for " + ParallelDataGenerator.TRAIN_OUT_FILE);
+            return;
+        }
+        //print_labeled_states(trainingStates);
+        System.out.println("Processing " + allStates.size() + " states.");
+        System.out.println("Previous Index Count: " + previousRawSize);
+        System.out.println("Initial Index Count: " + initialRawSize);
+        System.out.println("Final Index Count: " + finalFeatures.localIndexCount.get());
+        Set<Integer> oldIgnoreList = new HashSet<>(finalFeatures.ignoreList);
+        Set<Integer> newIgnoreListA = new HashSet<>(FeatureMerger.computeIgnoreListFromLS(allStates, 0, previousRawSize));
+        Set<Integer> newIgnoreListB = new HashSet<>(FeatureMerger.computeIgnoreListFromLS(allStates, previousRawSize, initialRawSize));
+        System.out.println("Computed " + newIgnoreListB.size() + " features to ignore from this batch.");
+        //intersect
+        newIgnoreListA.retainAll(oldIgnoreList);
+        //union
+        newIgnoreListA.addAll(newIgnoreListB);
+        finalFeatures.ignoreList = newIgnoreListA;
+        System.out.println("Final combined ignore list size: " + finalFeatures.ignoreList.size());
+
+        System.out.println("Compressing all states...");
+        for (LabeledState ls : allStates) {
+            ls.compress(finalFeatures.ignoreList);
+        }
+        System.out.println("Final Compressed Feature Vector Size: " + (finalFeatures.localIndexCount.get() - finalFeatures.ignoreList.size()));
+        persistLabeledStates(trainingStates, ParallelDataGenerator.TRAIN_OUT_FILE);
+        persistLabeledStates(testingStates, ParallelDataGenerator.TEST_OUT_FILE);
+        persistData();
+        System.out.println("Successfully saved data to " + ParallelDataGenerator.TRAIN_OUT_FILE + " and " + ParallelDataGenerator.TEST_OUT_FILE);
+    }
+
+    private GameResult runSingleGame() throws ExecutionException {
+        try {
+
+            Game game;
+            StateEncoder threadEncoder = new StateEncoder();
+
+            // Use a thread-safe random number generator for the seed.
+            long gameSeed = ThreadLocalRandom.current().nextLong();
+            RandomUtil.setSeed(gameSeed);
+
+
+            // All game objects are local to this thread to prevent race conditions.
+            MatchOptions matchOptions = new MatchOptions("test match", "test game type", true, 4);
+            Match localMatch = new FreeForAllMatch(matchOptions);
+            game = new TwoPlayerDuel(MultiplayerAttackOption.LEFT, RangeOfInfluence.ONE, MulliganType.GAME_DEFAULT.getMulligan(0), 60, 20, 7);
+            TestPlayer playerA = createLocalPlayer(game, "PlayerA", DECK_A, localMatch);
+            TestPlayer playerB = createLocalPlayer(game, "PlayerB", DECK_B, localMatch);
+
+            try {
+                threadEncoder.loadMapping(finalFeatures);
+                ActionEncoder.actionMap = (Map<String, Integer>) loadObject(ACTIONS_FILE);
+                ActionEncoder.indexCount = ActionEncoder.actionMap.size();
+            } catch (IOException | ClassNotFoundException e) {
+                System.err.println("Worker thread failed to load persistent mappings.");
+            }
+
+            configurePlayer(playerA, threadEncoder);
+            configurePlayer(playerB, threadEncoder);
+            threadEncoder.setAgent(playerA.getId());
+            threadEncoder.setOpponent(playerB.getId());
+
+            // Based on CardTestPlayerAPIImpl.java, this is the correct thread-safe
+            // way to configure and run a game simulation.
+            GameOptions options = new GameOptions();
+            options.testMode = true;
+            options.stopOnTurn = MAX_GAME_TURNS;
+            options.stopAtStep = PhaseStep.END_TURN;
+            game.setGameOptions(options);
+
+            // Start the game simulation. This is a blocking call that will run the game to completion.
+            game.start(playerA.getId());
+
+            // The rest of the logic is safe as it uses the local player objects.
+            boolean playerAWon = playerA.hasWon();
+            //merge to the final features
+            finalFeatures.merge(threadEncoder.getFeatures());
+            synchronized (finalFeatures) {
+                assert (finalFeatures.localIndexCount.get() >= threadEncoder.getFeatures().localIndexCount.get());
+            }
+            return new GameResult(generateLabeledStatesForGame(threadEncoder, playerAWon), playerAWon);
+        } catch (Exception e) {
+            System.err.println("Caught an internal AI/Game exception in a worker thread. Ignoring this game. Cause: " + e.getMessage());
+            throw new ExecutionException("Worker thread failed - ignoring", e);
+        }
+    }
+
+    private void configurePlayer(TestPlayer player, StateEncoder encoder) {
+        if (player.getComputerPlayer() instanceof ComputerPlayerMCTS2) {
+            ((ComputerPlayerMCTS2) player.getComputerPlayer()).setEncoder(encoder);
+            ((ComputerPlayerMCTS2) player.getComputerPlayer()).initNN(MCTS_MODEL_PATH);
+        } else if (player.getComputerPlayer() instanceof ComputerPlayer8) {
+            ((ComputerPlayer8) player.getComputerPlayer()).setEncoder(encoder);
+        } else if (player.getComputerPlayer() instanceof ComputerPlayerPureMCTS) {
+            ((ComputerPlayerPureMCTS) player.getComputerPlayer()).setEncoder(encoder);
+        }
+    }
+
+    private List<LabeledState> generateLabeledStatesForGame(StateEncoder encoder, boolean didPlayerAWin) {
+        synchronized (encoder) {
+            List<LabeledState> results = new ArrayList<>();
+            int N = encoder.macroStateVectors.size();
+            double gamma = 0.99;
+            double lambda = 0.5;
+
+            for (int i = 0; i < N; i++) {
+                Set<Integer> state = encoder.macroStateVectors.get(i);
+                double[] action = encoder.actionVectors.get(i);
+                double normScore = encoder.stateScores.get(i);
+                double terminal = didPlayerAWin ? +1.0 : -1.0;
+                double discount = Math.pow(gamma, N - i - 1);
+                double blended = lambda * normScore + (1.0 - lambda) * terminal * discount;
+                results.add(new LabeledState(state, action, blended));
+            }
+            return results;
+        }
+    }
+
+    //region Helper Methods
+    public Set<Integer> combine_ignore_lists(Set<Integer> oldList, Set<Integer> newList) {
+        Set<Integer> updatedIgnoreList = new HashSet<>();
+        int boundaryForOldFeatures = previousRawSize;
+
+        for (int i = 0; i < boundaryForOldFeatures; i++) {
+            if (oldList.contains(i) && newList.contains(i)) {
+                updatedIgnoreList.add(i);
+            }
+        }
+        for (Integer featureIndexInNewList : newList) {
+            if (featureIndexInNewList >= boundaryForOldFeatures) {
+                updatedIgnoreList.add(featureIndexInNewList);
+            }
+        }
+        return updatedIgnoreList;
+    }
+
+    public void persistData() {
+        try {
+            finalFeatures.previousLocalIndexCount = initialRawSize;
+            finalFeatures.version++;
+            finalFeatures.saveMapping(MAPPING_FILE);
+            System.out.printf("Persisted feature mapping (and ignore list) to %s%n", MAPPING_FILE);
+            saveObject(new HashMap<>(ActionEncoder.actionMap), ACTIONS_FILE);
+            System.out.printf("Persisted action mapping to %s%n", ACTIONS_FILE);
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+    }
+
+    private void persistLabeledStates(List<LabeledState> states, String filename) {
+        try (DataOutputStream out = new DataOutputStream(new BufferedOutputStream(new FileOutputStream(filename)))) {
+            out.writeInt(states.size());
+            out.writeInt(finalFeatures.localIndexCount.get());
+            out.writeInt(128); // Assuming policy vector size is constant
+
+            for (LabeledState ls : states) {
+                ls.persist(out, finalFeatures.localIndexCount.get());
+            }
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+    }
+
+    private static void saveObject(Object obj, String fileName) throws IOException {
+        try (ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(fileName))) {
+            out.writeObject(obj);
+        }
+    }
+
+    private static Object loadObject(String fileName) throws IOException, ClassNotFoundException {
+        try (ObjectInputStream in = new ObjectInputStream(new FileInputStream(fileName))) {
+            return in.readObject();
+        }
+    }
+
+    //endregion
+    @Override
+    public List<String> getFullSimulatedPlayers() {
+        return Arrays.asList("PlayerA", "PlayerB");
+    }
+
+    protected TestPlayer createLocalPlayer(Game game, String name, String deckName, Match match) throws GameException {
+        TestPlayer player = createNewPlayer(name, game.getRangeOfInfluence());
+        player.setTestMode(true);
+
+        logger.debug("Loading deck...");
+        DeckCardLists list;
+        if (loadedDecks.containsKey(deckName)) {
+            list = loadedDecks.get(deckName);
+        } else {
+            list = DeckImporter.importDeckFromFile(deckName, true);
+            loadedDecks.put(deckName, list);
+        }
+        Deck deck = Deck.load(list, false, false, loadedCardInfo);
+        logger.debug("Done!");
+        if (deck.getMaindeckCards().size() < 40) {
+            throw new IllegalArgumentException("Couldn't load deck, deck size=" + deck.getMaindeckCards().size());
+        }
+
+        game.loadCards(deck.getCards(), player.getId());
+        game.loadCards(deck.getSideboard(), player.getId());
+        game.addPlayer(player, deck);
+        match.addPlayer(player, deck); // fake match
+
+        return player;
+    }
+
+    // This is the correct override to use for creating players within our self-contained games.
+    @Override
+    protected TestPlayer createPlayer(String name, RangeOfInfluence rangeOfInfluence) {
+        if (name.equals("PlayerA")) {
+            TestComputerPlayer8 t8 = new TestComputerPlayer8(name, RangeOfInfluence.ONE, getSkillLevel());
+            TestPlayer testPlayer = new TestPlayer(t8);
+            testPlayer.setAIPlayer(true);
+            return testPlayer;
+        } else {
+            TestComputerPlayer7 t7 = new TestComputerPlayer7(name, RangeOfInfluence.ONE, getSkillLevel());
+            TestPlayer testPlayer = new TestPlayer(t7);
+            testPlayer.setAIPlayer(true);
+            return testPlayer;
+        }
+    }
+    //endregion
+}
\ No newline at end of file
diff --git a/Mage.Tests/src/test/java/org/mage/test/AI/RL/PureMCTSTests.java b/Mage.Tests/src/test/java/org/mage/test/AI/RL/PureMCTSTests.java
new file mode 100644
index 0000000000..edd4d4bbc8
--- /dev/null
+++ b/Mage.Tests/src/test/java/org/mage/test/AI/RL/PureMCTSTests.java
@@ -0,0 +1,132 @@
+package org.mage.test.AI.RL;
+
+import ai.onnxruntime.OrtException;
+import mage.constants.MultiplayerAttackOption;
+import mage.constants.PhaseStep;
+import mage.constants.RangeOfInfluence;
+import mage.game.Game;
+import mage.game.GameException;
+import mage.game.TwoPlayerDuel;
+import mage.game.mulligan.MulliganType;
+import mage.player.ai.ActionEncoder;
+import mage.player.ai.ComputerPlayerPureMCTS;
+import mage.player.ai.Features;
+import mage.player.ai.MCTSNode;
+import mage.util.RandomUtil;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+import org.mage.test.player.TestComputerPlayer7;
+import org.mage.test.player.TestComputerPlayerMonteCarlo2;
+import org.mage.test.player.TestComputerPlayerPureMonteCarlo;
+import org.mage.test.player.TestPlayer;
+import org.mage.test.serverside.base.CardTestPlayerBaseAI;
+
+import java.io.FileNotFoundException;
+import java.util.Arrays;
+import java.util.List;
+
+/**
+ * @author WillWroble
+ */
+public class PureMCTSTests extends CardTestPlayerBaseAI {
+
+    private String deckNameA = "UWTempo.dck"; //simplegreen, UWTempo
+    private String deckNameB = "simplegreen.dck";
+    private int seed;
+
+
+    @Override
+    public List<String> getFullSimulatedPlayers() {
+        return Arrays.asList("PlayerA", "PlayerB");
+    }
+
+    @Override
+    protected Game createNewGameAndPlayers() throws GameException, FileNotFoundException {
+        Game game = new TwoPlayerDuel(MultiplayerAttackOption.LEFT, RangeOfInfluence.ONE, MulliganType.GAME_DEFAULT.getMulligan(0), 60, 20, 7);
+        playerA = createPlayer(game, "PlayerA", "C:\\Users\\owner\\Documents\\" + deckNameA);
+        playerB = createPlayer(game, "PlayerB", "C:\\Users\\owner\\Documents\\" + deckNameB);
+        return game;
+    }
+    @Override
+    protected TestPlayer createPlayer(String name, RangeOfInfluence rangeOfInfluence) {
+        if (getFullSimulatedPlayers().contains(name)) {
+            if(name.equals("PlayerA")) {
+                TestComputerPlayerPureMonteCarlo pmc = new TestComputerPlayerPureMonteCarlo(name, RangeOfInfluence.ONE, getSkillLevel());
+                TestPlayer testPlayer = new TestPlayer(pmc);
+                testPlayer.setAIPlayer(true); // enable full AI support (game simulations) for all turns by default
+                return testPlayer;
+            } else {
+                TestComputerPlayer7 t7 = new TestComputerPlayer7(name, RangeOfInfluence.ONE, getSkillLevel());
+                TestPlayer testPlayer = new TestPlayer(t7);
+                testPlayer.setAIPlayer(true); // enable full AI support (game simulations) for all turns by default
+                return testPlayer;
+            }
+        }
+        return super.createPlayer(name, rangeOfInfluence);
+    }
+    public void reset_game() {
+        ComputerPlayerPureMCTS pmc = (ComputerPlayerPureMCTS) playerA.getComputerPlayer();
+        pmc.clearTree();
+        MCTSNode.clearCaches();
+
+        try {
+            reset();
+        } catch (FileNotFoundException e) {
+            throw new RuntimeException(e);
+        } catch (GameException e) {
+            throw new RuntimeException(e);
+        }
+
+    }
+    @Before
+    public void init_seed() {
+        seed = RandomUtil.nextInt();
+        //seed = -1421792887;
+        seed = 233400479;
+        System.out.printf("USING SEED: %d\n", seed);
+        RandomUtil.setSeed(seed);
+    }
+    //10 turns across 1 game
+    @Test
+    public void test_mcts_10_1() {
+        // simple test of 10 turns
+        int maxTurn = 10;
+        ComputerPlayerPureMCTS.SHOW_THREAD_INFO = true;
+        setStrictChooseMode(true);
+        setStopAt(maxTurn, PhaseStep.END_TURN);
+        execute();
+
+    }
+    //5 turns across 5 games
+    @Test
+    public void test_mcts_5_5() {
+        int maxTurn = 5;
+        Features.printOldFeatures = false;
+        for(int i = 0; i < 5; i++) {
+            setStrictChooseMode(true);
+            setStopAt(maxTurn, PhaseStep.END_TURN);
+            execute();
+            reset_game();
+            System.out.printf("GAME #%d RESET... NEW GAME STARTING\n", i+1);
+        }
+    }
+    //10 turns across 10 games
+    @Test
+    public void test_mcts_10_10() {
+        int maxTurn = 10;
+        Features.printOldFeatures = false;
+        for(int i = 0; i < 10; i++) {
+            setStrictChooseMode(true);
+            setStopAt(maxTurn, PhaseStep.END_TURN);
+            execute();
+            reset_game();
+            System.out.printf("GAME #%d RESET... NEW GAME STARTING\n", i+1);
+        }
+    }
+    @After
+    public void show_data() {
+        System.out.printf("USING SEED: %d\n", seed);
+        //System.out.printf("FINAL ACTION VECTOR SIZE: %d\n", ActionEncoder.indexCount);
+    }
+}
diff --git a/Mage.Tests/src/test/java/org/mage/test/AI/RL/RLAIGameStateGraphTest.java b/Mage.Tests/src/test/java/org/mage/test/AI/RL/RLAIGameStateGraphTest.java
deleted file mode 100644
index fbfbcc0b71..0000000000
--- a/Mage.Tests/src/test/java/org/mage/test/AI/RL/RLAIGameStateGraphTest.java
+++ /dev/null
@@ -1,181 +0,0 @@
-package org.mage.test.AI.RL;
-
-import mage.constants.PhaseStep;
-import mage.constants.RangeOfInfluence;
-import mage.constants.Zone;
-import mage.player.ai.CardState;
-import mage.player.ai.GameStateGraphNode;
-import org.junit.Assert;
-import org.junit.Test;
-import org.mage.test.player.TestComputerPlayerRL;
-import org.mage.test.player.TestPlayer;
-import org.mage.test.serverside.base.CardTestPlayerBaseAI;
-
-import java.util.*;
-
-/**
- * @author JayDi85
- */
-public class RLAIGameStateGraphTest extends CardTestPlayerBaseAI {
-
-    @Override
-    public List<String> getFullSimulatedPlayers() {
-        return Arrays.asList("PlayerA", "PlayerB");
-    }
-
-    @Test
-    public void test_Graph_Simple() {
-        // both must kill x2 bears by x2 bolts
-        GameStateGraphNode root = new GameStateGraphNode();
-        CardState aState = new CardState("A");
-        CardState bState = new CardState("B");
-
-
-        GameStateGraphNode A = new GameStateGraphNode();
-        A.cardsBattleField.addCardState(aState);
-        GameStateGraphNode B = new GameStateGraphNode();
-        B.cardsBattleField.addCardState(bState);
-        GameStateGraphNode AB = new GameStateGraphNode();
-        AB.cardsBattleField.addCardState(new CardState("A"));
-        AB.cardsBattleField.addCardState(new CardState("B"));
-        GameStateGraphNode A__ = GameStateGraphNode.GetLargestSharedSubset(A, root);
-        GameStateGraphNode B__ = GameStateGraphNode.GetLargestSharedSubset(B, root);
-        assert (A__.equals(root));
-        assert (B__.equals(root));
-
-
-        GameStateGraphNode A_ = GameStateGraphNode.GetLargestSharedSubset(AB, A);
-
-        assert (A_.equals(A));
-        assert (root.equals(new GameStateGraphNode()));
-
-        //root.linkStateNode(A);
-        //root.linkStateNode(B);
-        //root.linkStateNode(AB);
-
-        Set<GameStateGraphNode> source = new HashSet<>();
-        source.add(A);
-        source.add(B);
-        source.add(AB);
-        source.add(root);
-
-        assert (source.contains(A_));
-
-        assert (A.isDescendentOf(root));
-        assert (!A.isDescendentOf(B));
-        assert (!B.isDescendentOf(A));
-        assert(AB.isDescendentOf(A));
-
-        //root.printGraph(0);
-        GameStateGraphNode.validateGraph(root, source);
-        System.out.println("Hello World!");
-    }
-    @Test
-    public void test_Graph_Simple2() {
-        // both must kill x2 bears by x2 bolts
-        GameStateGraphNode root = new GameStateGraphNode();
-
-        GameStateGraphNode A = new GameStateGraphNode();
-        A.cardsBattleField.addCardState(new CardState("A"));
-        GameStateGraphNode AB = new GameStateGraphNode();
-        AB.cardsBattleField.addCardState(new CardState("A"));
-        AB.cardsBattleField.addCardState(new CardState("B"));
-        GameStateGraphNode BC = new GameStateGraphNode();
-        BC.cardsBattleField.addCardState(new CardState("B"));
-        BC.cardsBattleField.addCardState(new CardState("C"));
-        GameStateGraphNode AC = new GameStateGraphNode();
-        AC.cardsBattleField.addCardState(new CardState("A"));
-        AC.cardsBattleField.addCardState(new CardState("C"));
-        GameStateGraphNode ACD = new GameStateGraphNode();
-        ACD.cardsBattleField.addCardState(new CardState("A"));
-        ACD.cardsBattleField.addCardState(new CardState("C"));
-        ACD.cardsBattleField.addCardState(new CardState("D"));
-
-
-        GameStateGraphNode A_ = GameStateGraphNode.GetLargestSharedSubset(AC, AB);
-        assert (A.equals(A_));
-        assert (GameStateGraphNode.GetLargestSharedSubset(ACD, AC).equals(AC));
-        Set<GameStateGraphNode> sourceLeaves = new HashSet<>();
-        sourceLeaves.add(AB);
-        sourceLeaves.add(BC);
-        sourceLeaves.add(AC);
-        sourceLeaves.add(ACD);
-        sourceLeaves.add(root);
-        assert (sourceLeaves.size() == 5);
-        assert (!sourceLeaves.contains(A));
-        assert (GameStateGraphNode.GetLargestSharedSubset(AB, AC).equals(A));
-        GameStateGraphNode.validateGraph(root, sourceLeaves);
-
-        root.linkStateNode(AB);
-        root.linkStateNode(BC);
-        root.linkStateNode(AC);
-        root.linkStateNode(ACD);
-        assert(root.contains(AC) != null);
-        //root.printGraph(0);
-        System.out.println("Hello World!");
-    }
-    @Test
-    public void test_Graph_Simple3() {
-        // both must kill x2 bears by x2 bolts
-        GameStateGraphNode root = new GameStateGraphNode();
-
-
-        GameStateGraphNode ABC = GameStateGraphNode.quickMakeGraphNode(Arrays.asList("A", "B", "C"));
-        GameStateGraphNode BCDE = GameStateGraphNode.quickMakeGraphNode(Arrays.asList("D", "B", "C", "E"));
-        GameStateGraphNode DEFG = GameStateGraphNode.quickMakeGraphNode(Arrays.asList("D", "E", "F", "G"));
-        GameStateGraphNode FGHI = GameStateGraphNode.quickMakeGraphNode(Arrays.asList("H", "I", "F", "G"));
-        GameStateGraphNode AFGHI = GameStateGraphNode.quickMakeGraphNode(Arrays.asList("H", "I", "F", "G", "A"));
-
-
-
-        root.linkStateNode(ABC);
-        root.linkStateNode(BCDE);
-        root.linkStateNode(DEFG);
-        root.linkStateNode(FGHI);
-        root.linkStateNode(AFGHI);
-
-
-        root.printGraph(0);
-        System.out.println("Hello World!");
-    }
-    @Test
-    public void test_Graph_triangle() {
-        // both must kill x2 bears by x2 bolts
-        GameStateGraphNode root = new GameStateGraphNode();
-
-
-//        GameStateGraphNode I = GameStateGraphNode.quickMakeGraphNode(Arrays.asList("I"));
-//        GameStateGraphNode J = GameStateGraphNode.quickMakeGraphNode(Arrays.asList("J"));
-//
-//        GameStateGraphNode HI = GameStateGraphNode.quickMakeGraphNode(Arrays.asList("D", "E", "F", "G"));
-//        GameStateGraphNode IJ = GameStateGraphNode.quickMakeGraphNode(Arrays.asList("H", "I", "F", "G"));
-//        GameStateGraphNode JK = GameStateGraphNode.quickMakeGraphNode(Arrays.asList("H", "I", "F", "G"));
-//
-//        GameStateGraphNode GHI = GameStateGraphNode.quickMakeGraphNode(Arrays.asList("H", "I", "F", "G"));
-//        GameStateGraphNode HIJ = GameStateGraphNode.quickMakeGraphNode(Arrays.asList("H", "I", "F", "G", "A"));
-//        GameStateGraphNode IJK = GameStateGraphNode.quickMakeGraphNode(Arrays.asList("H", "I", "F", "G"));
-//        GameStateGraphNode JKL = GameStateGraphNode.quickMakeGraphNode(Arrays.asList("H", "I", "F", "G"));
-
-        GameStateGraphNode FGHI = GameStateGraphNode.quickMakeGraphNode(Arrays.asList("F", "G", "H", "I"));
-        GameStateGraphNode GHIJ = GameStateGraphNode.quickMakeGraphNode(Arrays.asList("G", "H", "I", "J"));
-        GameStateGraphNode HIJK = GameStateGraphNode.quickMakeGraphNode(Arrays.asList("H", "I", "J", "K"));
-        GameStateGraphNode IJKL = GameStateGraphNode.quickMakeGraphNode(Arrays.asList("I", "J", "K", "L"));
-        GameStateGraphNode JKLM = GameStateGraphNode.quickMakeGraphNode(Arrays.asList("J", "K", "L", "M"));
-        GameStateGraphNode KLMN = GameStateGraphNode.quickMakeGraphNode(Arrays.asList("K", "L", "M", "N"));
-
-
-
-        root.linkStateNode(FGHI);
-        root.linkStateNode(GHIJ);
-        root.linkStateNode(HIJK);
-        root.linkStateNode(IJKL);
-        root.linkStateNode(JKLM);
-        //root.linkStateNode(KLMN);
-
-
-        root.printGraph(0);
-        System.out.println("Hello World!");
-    }
-
-
-}
diff --git a/Mage.Tests/src/test/java/org/mage/test/AI/RL/RLEncodingTests.java b/Mage.Tests/src/test/java/org/mage/test/AI/RL/RLEncodingTests.java
index 0047d05e9e..a18e896895 100644
--- a/Mage.Tests/src/test/java/org/mage/test/AI/RL/RLEncodingTests.java
+++ b/Mage.Tests/src/test/java/org/mage/test/AI/RL/RLEncodingTests.java
@@ -17,18 +17,22 @@ import org.mage.test.player.TestPlayer;
 import org.mage.test.serverside.base.CardTestPlayerBaseAI;
 
 import java.io.FileNotFoundException;
+import java.io.IOException;
 import java.util.Arrays;
+import java.util.HashMap;
 import java.util.List;
 import java.util.Set;
 
+import static org.mage.test.AI.RL.MinimaxVectorExtractionTests.MAPPING_FILE;
+
 /**
  * @author WillWroble
  */
 public class RLEncodingTests extends CardTestPlayerBaseAI {
     StateEncoder encoder;
-    private String deckNameA = "simplegreen.dck"; //simplegreen, UWTempo
-    private String deckNameB = "simplegreen.dck";
-
+    private String deckNameB = "UWTempo.dck"; //simplegreen, UWTempo
+    private String deckNameA = "simplegreen.dck";
+    Features old_features;
 
     @Override
     public List<String> getFullSimulatedPlayers() {
@@ -38,8 +42,8 @@ public class RLEncodingTests extends CardTestPlayerBaseAI {
     @Override
     protected Game createNewGameAndPlayers() throws GameException, FileNotFoundException {
         Game game = new TwoPlayerDuel(MultiplayerAttackOption.LEFT, RangeOfInfluence.ONE, MulliganType.GAME_DEFAULT.getMulligan(0), 60, 20, 7);
-        playerA = createPlayer(game, "PlayerA", "C:\\Users\\WillWroble\\Documents\\" + deckNameA);
-        playerB = createPlayer(game, "PlayerB", "C:\\Users\\WillWroble\\Documents\\" + deckNameB);
+        playerA = createPlayer(game, "PlayerA", "C:\\Users\\owner\\Documents\\" + deckNameA);
+        playerB = createPlayer(game, "PlayerB", "C:\\Users\\owner\\Documents\\" + deckNameB);
         return game;
     }
     @Override
@@ -66,10 +70,24 @@ public class RLEncodingTests extends CardTestPlayerBaseAI {
         set_encoder();
     }
     public void set_encoder() {
+        //if(true) return;
         ComputerPlayer8 c8 = (ComputerPlayer8)playerA.getComputerPlayer();
         c8.setEncoder(encoder);
         encoder.setAgent(playerA.getId());
         encoder.setOpponent(playerB.getId());
+        //if(true) return;
+        try {
+            old_features = Features.loadMapping(MAPPING_FILE);
+        } catch (IOException | ClassNotFoundException e) {
+            throw new RuntimeException("failed to load persistent mappings.", e);
+        }
+        if(true) return;
+        try {
+            encoder.loadMapping(MAPPING_FILE);
+        } catch (IOException | ClassNotFoundException e) {
+            throw new RuntimeException("failed to load persistent mappings.", e);
+        }
+
     }
     public void reset_game() {
         try {
@@ -85,14 +103,32 @@ public class RLEncodingTests extends CardTestPlayerBaseAI {
     //5 turns across 1 game
     @Test
     public void test_encoding_5_1() {
+        Features.printOldFeatures = false;
         // simple test of 5 turns
         int maxTurn = 5;
-
         //addCard(Zone.HAND, playerA, "Fauna Shaman", 3);
         setStrictChooseMode(true);
         setStopAt(maxTurn, PhaseStep.END_TURN);
         execute();
 
+//        try {
+//            encoder.getFeatures().saveMapping(MAPPING_FILE);
+//            System.out.printf("Persisted feature mapping (and ignore list) to %s%n", MAPPING_FILE);
+//        } catch (IOException e) {
+//            e.printStackTrace();
+//        }
+        //if(true) return;
+        logger.info(old_features.localIndexCount);
+        logger.info(encoder.getFeatures().localIndexCount);
+        old_features.merge(encoder.getFeatures());
+        logger.info(old_features.localIndexCount);
+
+        try {
+            old_features.saveMapping(MAPPING_FILE);
+            System.out.printf("Persisted feature mapping (and ignore list) to %s%n", MAPPING_FILE);
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
     }
     //20 turns across 1 game
     @Test
@@ -109,6 +145,7 @@ public class RLEncodingTests extends CardTestPlayerBaseAI {
     public void test_encoding_5_5() {
         int maxTurn = 5;
         Features.printOldFeatures = false;
+        Features.printNewFeatures  =false;
         for(int i = 0; i < 5; i++) {
             setStrictChooseMode(true);
             setStopAt(maxTurn, PhaseStep.END_TURN);
@@ -141,7 +178,7 @@ public class RLEncodingTests extends CardTestPlayerBaseAI {
             reset_game();
             System.out.printf("GAME #%d RESET... NEW GAME STARTING\n", i+1);
         }
-        Set<Integer> ignore = FeatureMerger.computeIgnoreList(encoder.stateVectors, 1.00);
+        Set<Integer> ignore = FeatureMerger.computeIgnoreList(encoder.macroStateVectors);
         System.out.printf("IGNORE LIST SIZE: %d\n", ignore.size());
         System.out.printf("REDUCED VECTOR SIZE: %d\n", StateEncoder.indexCount - ignore.size());
     }
@@ -156,7 +193,7 @@ public class RLEncodingTests extends CardTestPlayerBaseAI {
             reset_game();
             System.out.printf("GAME #%d RESET... NEW GAME STARTING\n", i+1);
         }
-        Set<Integer> ignore = FeatureMerger.computeIgnoreList(encoder.stateVectors, 1.00);
+        Set<Integer> ignore = FeatureMerger.computeIgnoreList(encoder.macroStateVectors);
         System.out.printf("IGNORE LIST SIZE: %d\n", ignore.size());
         System.out.printf("REDUCED VECTOR SIZE: %d\n", StateEncoder.indexCount - ignore.size());
     }
@@ -171,7 +208,7 @@ public class RLEncodingTests extends CardTestPlayerBaseAI {
             reset_game();
             System.out.printf("GAME #%d RESET... NEW GAME STARTING\n", i+1);
         }
-        Set<Integer> ignore = FeatureMerger.computeIgnoreList(encoder.stateVectors, 1.00);
+        Set<Integer> ignore = FeatureMerger.computeIgnoreList(encoder.macroStateVectors);
         System.out.printf("IGNORE LIST SIZE: %d\n", ignore.size());
         System.out.printf("REDUCED VECTOR SIZE: %d\n", StateEncoder.indexCount - ignore.size());
     }
@@ -186,7 +223,7 @@ public class RLEncodingTests extends CardTestPlayerBaseAI {
             reset_game();
             System.out.printf("GAME #%d RESET... NEW GAME STARTING\n", i+1);
         }
-        Set<Integer> ignore = FeatureMerger.computeIgnoreList(encoder.stateVectors, 1.00);
+        Set<Integer> ignore = FeatureMerger.computeIgnoreList(encoder.macroStateVectors);
         System.out.printf("IGNORE LIST SIZE: %d\n", ignore.size());
         System.out.printf("REDUCED VECTOR SIZE: %d\n", StateEncoder.indexCount - ignore.size());
         //run one more game this time using ignore list
@@ -209,7 +246,7 @@ public class RLEncodingTests extends CardTestPlayerBaseAI {
             reset_game();
             System.out.printf("GAME #%d RESET... NEW GAME STARTING\n", i+1);
         }
-        Set<Integer> ignore = FeatureMerger.computeIgnoreList(encoder.stateVectors, 1.00);
+        Set<Integer> ignore = FeatureMerger.computeIgnoreList(encoder.macroStateVectors);
         System.out.printf("IGNORE LIST SIZE: %d\n", ignore.size());
         System.out.printf("REDUCED VECTOR SIZE: %d\n", StateEncoder.indexCount - ignore.size());
         //run one more game this time using ignore list
@@ -221,29 +258,7 @@ public class RLEncodingTests extends CardTestPlayerBaseAI {
         execute();
         System.out.println(ignore);
     }
-    @Test
-    public void test_state_consistency() {
-        int maxTurn = 10;
-        //removeAllCardsFromHand(playerA);
-        setStrictChooseMode(true);
-        setStopAt(maxTurn, PhaseStep.END_TURN);
-        execute();
-        //save state after 5 turns
-        int bookmarkedState = currentGame.bookmarkState();
-        boolean[] savedVec = StateEncoder.featureVector;
-        reset_game();
-        //simulate another 5 turns
-        setStrictChooseMode(true);
-        setStopAt(maxTurn, PhaseStep.END_TURN);
-        execute();
-        //reload state and read it
-        currentGame.restoreState(bookmarkedState, "rolling_back_for_testing");
-        encoder.processState(currentGame);
-        boolean[] newVec = StateEncoder.featureVector;
-        System.out.println(Arrays.toString(savedVec));
-        System.out.println(Arrays.toString(newVec));
-        assert (Arrays.equals(savedVec, newVec));
-    }
+
     @After
     public void print_vector_size() {
         System.out.printf("FINAL (unreduced) VECTOR SIZE: %d\n", StateEncoder.indexCount);
diff --git a/Mage.Tests/src/test/java/org/mage/test/AI/RL/SimulateMCTS.java b/Mage.Tests/src/test/java/org/mage/test/AI/RL/SimulateMCTS.java
new file mode 100644
index 0000000000..ef94d9afbb
--- /dev/null
+++ b/Mage.Tests/src/test/java/org/mage/test/AI/RL/SimulateMCTS.java
@@ -0,0 +1,30 @@
+package org.mage.test.AI.RL;
+
+import mage.constants.RangeOfInfluence;
+import org.junit.Test;
+import org.mage.test.player.*;
+
+public class SimulateMCTS extends ParallelDataGenerator {
+
+
+    @Test
+    public void generateTrainingAndTestingData() {
+        super.generateTrainingAndTestingData();
+    }
+
+    // This is the correct override to use for creating players within our self-contained games.
+    @Override
+    protected TestPlayer createPlayer(String name, RangeOfInfluence rangeOfInfluence) {
+        if(name.equals("PlayerA")) {
+            TestComputerPlayerMonteCarlo2 mcts2 = new TestComputerPlayerMonteCarlo2(name, RangeOfInfluence.ONE, getSkillLevel());
+            TestPlayer testPlayer = new TestPlayer(mcts2);
+            testPlayer.setAIPlayer(true); // enable full AI support (game simulations) for all turns by default
+            return testPlayer;
+        } else {
+            TestComputerPlayer8 t8 = new TestComputerPlayer8(name, RangeOfInfluence.ONE, getSkillLevel());
+            TestPlayer testPlayer = new TestPlayer(t8);
+            testPlayer.setAIPlayer(true);
+            return testPlayer;
+        }
+    }
+}
diff --git a/Mage.Tests/src/test/java/org/mage/test/AI/RL/SimulatePureMCTS.java b/Mage.Tests/src/test/java/org/mage/test/AI/RL/SimulatePureMCTS.java
new file mode 100644
index 0000000000..18d6d36ecd
--- /dev/null
+++ b/Mage.Tests/src/test/java/org/mage/test/AI/RL/SimulatePureMCTS.java
@@ -0,0 +1,31 @@
+package org.mage.test.AI.RL;
+
+import mage.constants.RangeOfInfluence;
+import mage.player.ai.ComputerPlayerPureMCTS;
+import org.junit.Test;
+import org.mage.test.player.*;
+
+public class SimulatePureMCTS extends ParallelDataGenerator {
+
+
+    @Test
+    public void generateTrainingAndTestingData() {
+        super.generateTrainingAndTestingData();
+    }
+
+    // This is the correct override to use for creating players within our self-contained games.
+    @Override
+    protected TestPlayer createPlayer(String name, RangeOfInfluence rangeOfInfluence) {
+        if(name.equals("PlayerA")) {
+            TestComputerPlayerPureMonteCarlo pmcts = new TestComputerPlayerPureMonteCarlo(name, RangeOfInfluence.ONE, getSkillLevel());
+            TestPlayer testPlayer = new TestPlayer(pmcts);
+            testPlayer.setAIPlayer(true); // enable full AI support (game simulations) for all turns by default
+            return testPlayer;
+        } else {
+            TestComputerPlayer8 t8 = new TestComputerPlayer8(name, RangeOfInfluence.ONE, getSkillLevel());
+            TestPlayer testPlayer = new TestPlayer(t8);
+            testPlayer.setAIPlayer(true);
+            return testPlayer;
+        }
+    }
+}
diff --git a/Mage.Tests/src/test/java/org/mage/test/player/TestComputerPlayer7.java b/Mage.Tests/src/test/java/org/mage/test/player/TestComputerPlayer7.java
index 4e4aff6b5c..2d5fef98c5 100644
--- a/Mage.Tests/src/test/java/org/mage/test/player/TestComputerPlayer7.java
+++ b/Mage.Tests/src/test/java/org/mage/test/player/TestComputerPlayer7.java
@@ -7,6 +7,7 @@ import mage.constants.Outcome;
 import mage.constants.RangeOfInfluence;
 import mage.game.Game;
 import mage.player.ai.ComputerPlayer7;
+import mage.player.ai.ComputerPlayerMinimaxOpponent;
 import mage.target.Target;
 import mage.target.TargetCard;
 
@@ -18,7 +19,7 @@ import mage.target.TargetCard;
  * @author JayDi85
  */
 
-public final class TestComputerPlayer7 extends ComputerPlayer7 {
+public final class TestComputerPlayer7 extends ComputerPlayerMinimaxOpponent {
 
     private TestPlayer testPlayerLink;
 
diff --git a/Mage.Tests/src/test/java/org/mage/test/player/TestComputerPlayerPureMonteCarlo.java b/Mage.Tests/src/test/java/org/mage/test/player/TestComputerPlayerPureMonteCarlo.java
new file mode 100644
index 0000000000..e69b832e01
--- /dev/null
+++ b/Mage.Tests/src/test/java/org/mage/test/player/TestComputerPlayerPureMonteCarlo.java
@@ -0,0 +1,105 @@
+package org.mage.test.player;
+
+import mage.abilities.Ability;
+import mage.cards.Cards;
+import mage.choices.Choice;
+import mage.constants.Outcome;
+import mage.constants.RangeOfInfluence;
+import mage.game.Game;
+import mage.player.ai.ComputerPlayerMCTS2;
+import mage.player.ai.ComputerPlayerPureMCTS;
+import mage.target.Target;
+import mage.target.TargetCard;
+
+/**
+ * AI: helper class for tests
+ * <p>
+ * Copied-pasted methods from TestComputerPlayer, see docs in there
+ *
+ * @author JayDi85
+ */
+
+public final class TestComputerPlayerPureMonteCarlo extends ComputerPlayerPureMCTS {
+
+    private TestPlayer testPlayerLink;
+
+    public TestComputerPlayerPureMonteCarlo(String name, RangeOfInfluence range, int skill) {
+        super(name, range, skill);
+    }
+
+    public void setTestPlayerLink(TestPlayer testPlayerLink) {
+        this.testPlayerLink = testPlayerLink;
+    }
+
+    @Override
+    public boolean choose(Outcome outcome, Target target, Ability source, Game game) {
+        if (testPlayerLink.canChooseByComputer()) {
+            return super.choose(outcome, target, source, game);
+        } else {
+            return testPlayerLink.choose(outcome, target, source, game);
+        }
+    }
+
+    @Override
+    public boolean choose(Outcome outcome, Choice choice, Game game) {
+        if (testPlayerLink.canChooseByComputer()) {
+            return super.choose(outcome, choice, game);
+        } else {
+            return testPlayerLink.choose(outcome, choice, game);
+        }
+    }
+
+    @Override
+    public boolean choose(Outcome outcome, Cards cards, TargetCard target, Ability source, Game game) {
+        if (testPlayerLink.canChooseByComputer()) {
+            return super.choose(outcome, cards, target, source, game);
+        } else {
+            return testPlayerLink.choose(outcome, cards, target, source, game);
+        }
+    }
+
+    @Override
+    public boolean chooseTarget(Outcome outcome, Target target, Ability source, Game game) {
+        if (testPlayerLink.canChooseByComputer()) {
+            return super.chooseTarget(outcome, target, source, game);
+        } else {
+            return testPlayerLink.chooseTarget(outcome, target, source, game);
+        }
+    }
+
+    @Override
+    public boolean chooseTarget(Outcome outcome, Cards cards, TargetCard target, Ability source, Game game) {
+        if (testPlayerLink.canChooseByComputer()) {
+            return super.chooseTarget(outcome, cards, target, source, game);
+        } else {
+            return testPlayerLink.chooseTarget(outcome, cards, target, source, game);
+        }
+    }
+
+    @Override
+    public boolean flipCoinResult(Game game) {
+        if (testPlayerLink.canChooseByComputer()) {
+            return super.flipCoinResult(game);
+        } else {
+            return testPlayerLink.flipCoinResult(game);
+        }
+    }
+
+    @Override
+    public int rollDieResult(int sides, Game game) {
+        if (testPlayerLink.canChooseByComputer()) {
+            return super.rollDieResult(sides, game);
+        } else {
+            return testPlayerLink.rollDieResult(sides, game);
+        }
+    }
+
+    @Override
+    public boolean isComputer() {
+        if (testPlayerLink.canChooseByComputer()) {
+            return super.isComputer();
+        } else {
+            return testPlayerLink.isComputer();
+        }
+    }
+}
diff --git a/Mage.Tests/src/test/java/org/mage/test/player/TestPlayer.java b/Mage.Tests/src/test/java/org/mage/test/player/TestPlayer.java
index 55b3dc7e4b..c45bcda1b2 100644
--- a/Mage.Tests/src/test/java/org/mage/test/player/TestPlayer.java
+++ b/Mage.Tests/src/test/java/org/mage/test/player/TestPlayer.java
@@ -141,6 +141,11 @@ public class TestPlayer implements Player {
         AIPlayer = false;
         computerPlayer.setTestPlayerLink(this);
     }
+    public TestPlayer(TestComputerPlayerPureMonteCarlo computerPlayer) {
+        this.computerPlayer = computerPlayer;
+        AIPlayer = false;
+        computerPlayer.setTestPlayerLink(this);
+    }
     public TestPlayer(TestComputerPlayerMonteCarlo computerPlayer) {
         this.computerPlayer = computerPlayer;
         AIPlayer = false;
@@ -164,6 +169,15 @@ public class TestPlayer implements Player {
         this.strictChooseMode = testPlayer.strictChooseMode;
     }
 
+    @Override
+    public Ability getLastActivated() {
+        return computerPlayer.getLastActivated();
+    }
+    @Override
+    public void setLastActivated(Ability a) {
+        computerPlayer.setLastActivated(a);
+    }
+
     public void addChoice(String choice) {
         // prepare face down
         // how-to fix:
diff --git a/Mage.Tests/testing.bin b/Mage.Tests/testing.bin
index f823980b70..08b0c743e2 100644
Binary files a/Mage.Tests/testing.bin and b/Mage.Tests/testing.bin differ
diff --git a/Mage.Tests/training.bin b/Mage.Tests/training.bin
index a8a34bf4ba..a3a7303f66 100644
Binary files a/Mage.Tests/training.bin and b/Mage.Tests/training.bin differ
diff --git a/Mage/src/main/java/mage/abilities/condition/common/SourceMatchesFilterCondition.java b/Mage/src/main/java/mage/abilities/condition/common/SourceMatchesFilterCondition.java
index 570ce68ed0..f91478cfe6 100644
--- a/Mage/src/main/java/mage/abilities/condition/common/SourceMatchesFilterCondition.java
+++ b/Mage/src/main/java/mage/abilities/condition/common/SourceMatchesFilterCondition.java
@@ -31,7 +31,7 @@ public class SourceMatchesFilterCondition implements Condition {
     @Override
     public boolean apply(Game game, Ability source) {
         Permanent permanent = source.getSourcePermanentOrLKI(game);
-        return filter.match(permanent, permanent.getControllerId(), source, game);
+        return filter.match(permanent, permanent == null ? source.getControllerId() : permanent.getControllerId(), source, game);
     }
 
     @Override
diff --git a/Mage/src/main/java/mage/abilities/mana/AnyColorPermanentTypesManaAbility.java b/Mage/src/main/java/mage/abilities/mana/AnyColorPermanentTypesManaAbility.java
index f6cd43bbfc..75d61936a7 100644
--- a/Mage/src/main/java/mage/abilities/mana/AnyColorPermanentTypesManaAbility.java
+++ b/Mage/src/main/java/mage/abilities/mana/AnyColorPermanentTypesManaAbility.java
@@ -58,7 +58,7 @@ class AnyColorPermanentTypesManaEffect extends ManaEffect {
 
     public AnyColorPermanentTypesManaEffect(TargetController targetController, FilterPermanent permanentTypes) {
         super();
-        filter = permanentTypes;
+        filter = permanentTypes.copy();
         filter.add(targetController.getControllerPredicate());
         staticText = "Add one mana of any color" +
                 " among " + permanentTypes.getMessage() + " " +
diff --git a/Mage/src/main/java/mage/cards/decks/DeckCardLayout.java b/Mage/src/main/java/mage/cards/decks/DeckCardLayout.java
index b12e9b7cee..966a8dceb8 100644
--- a/Mage/src/main/java/mage/cards/decks/DeckCardLayout.java
+++ b/Mage/src/main/java/mage/cards/decks/DeckCardLayout.java
@@ -2,13 +2,14 @@ package mage.cards.decks;
 
 import mage.util.Copyable;
 
+import java.io.Serializable;
 import java.util.ArrayList;
 import java.util.List;
 
 /**
  * Created by stravant@gmail.com on 2016-10-03.
  */
-public class DeckCardLayout implements Copyable<DeckCardLayout> {
+public class DeckCardLayout implements Copyable<DeckCardLayout>, Serializable {
 
     private final List<List<List<DeckCardInfo>>> cards;
     private final String settings;
diff --git a/Mage/src/main/java/mage/constants/PhaseStep.java b/Mage/src/main/java/mage/constants/PhaseStep.java
index 5b71c6e09b..3d94af36cc 100644
--- a/Mage/src/main/java/mage/constants/PhaseStep.java
+++ b/Mage/src/main/java/mage/constants/PhaseStep.java
@@ -47,11 +47,11 @@ public enum PhaseStep {
     public int getIndex() {
         return index;
     }
-
-    @Override
-    public String toString() {
-        return text;
-    }
+//
+//    @Override
+//    public String toString() {
+//        return text;
+//    }
 
     public static PhaseStep fromString(String needText) {
         return Arrays.stream(values())
diff --git a/Mage/src/main/java/mage/game/Exile.java b/Mage/src/main/java/mage/game/Exile.java
index 7d8b7bd566..813342e32f 100644
--- a/Mage/src/main/java/mage/game/Exile.java
+++ b/Mage/src/main/java/mage/game/Exile.java
@@ -14,7 +14,7 @@ import java.util.stream.Collectors;
  */
 public class Exile implements Serializable, Copyable<Exile> {
 
-    private static final UUID PERMANENT = UUID.randomUUID();
+    private final UUID PERMANENT = UUID.nameUUIDFromBytes("Permanent".getBytes());
 
     private final Map<UUID, ExileZone> exileZones = new HashMap<>();
 
diff --git a/Mage/src/main/java/mage/game/Game.java b/Mage/src/main/java/mage/game/Game.java
index 2df39b9016..4fabcbdb5a 100644
--- a/Mage/src/main/java/mage/game/Game.java
+++ b/Mage/src/main/java/mage/game/Game.java
@@ -46,6 +46,14 @@ import java.util.*;
 import java.util.stream.Collectors;
 
 public interface Game extends MageItem, Serializable, Copyable<Game> {
+//    void setMacroState(Game game);
+//    void setMacroPlayerId(UUID id);
+//    void setLastAction(Ability ability);
+    Game getLastPriority();
+    UUID getLastPriorityPlayerId();
+    Ability getLastPriorityAction();
+
+    void setLastPriority(Game game);
 
     MatchType getGameType();
 
@@ -640,6 +648,9 @@ public interface Game extends MageItem, Serializable, Copyable<Game> {
 
     boolean executingRollback();
 
+    void addCard(UUID cardId, Card card);
+
+
     /**
      * Add counters to permanent before ETB. Use it before put real permanent to battlefield.
      */
diff --git a/Mage/src/main/java/mage/game/GameImpl.java b/Mage/src/main/java/mage/game/GameImpl.java
index fcacee29f7..6217062e15 100644
--- a/Mage/src/main/java/mage/game/GameImpl.java
+++ b/Mage/src/main/java/mage/game/GameImpl.java
@@ -93,6 +93,10 @@ import java.util.stream.Collectors;
  * If it's a temporary/auto-generated data then mark that field as transient and comment in copy constructor.
  */
 public abstract class GameImpl implements Game {
+    //shallow game history for AI
+    private Game lastPriority = this;
+    private UUID lastPriorityPlayerId;
+    public Ability lastPriorityAction;
 
     private static final int ROLLBACK_TURNS_MAX = 4;
     private static final String UNIT_TESTS_ERROR_TEXT = "Error in unit tests";
@@ -182,6 +186,8 @@ public abstract class GameImpl implements Game {
     }
 
     protected GameImpl(final GameImpl game) {
+        this.lastPriorityAction = game.lastPriorityAction;
+        this.lastPriorityPlayerId = game.lastPriorityPlayerId;
         //this.customData = game.customData; // temporary data, no need on game copy
         //this.losingPlayer = game.losingPlayer; // temporary data, no need on game copy
         this.aiGame = game.aiGame;
@@ -247,6 +253,48 @@ public abstract class GameImpl implements Game {
          */
     }
 
+    /**
+     * @return the game object from right before the last priority
+     */
+    @Override
+    public Game getLastPriority() {
+        return lastPriority;
+    }
+
+    /**
+     * @return the id of the player who last had priority
+     */
+    @Override
+    public UUID getLastPriorityPlayerId() {
+        return lastPriorityPlayerId;
+    }
+
+    /**
+     * @return the action made during the last priority
+     */
+    @Override
+    public Ability getLastPriorityAction() {
+        return lastPriorityAction;
+    }
+    /**
+     * @return the action made during the last priority
+     */
+    @Override
+    public void setLastPriority(Game game) {
+        lastPriority = game;
+    }
+//    @Override
+//    public void setMacroState(Game game) {
+//        macroState = game;
+//    }
+//    @Override
+//    public void setMacroPlayerId(UUID id) {
+//        macroPlayerId = id;
+//    }
+//    @Override
+//    public void setLastAction(Ability ability) {
+//        lastAction = ability;
+//    }
     @Override
     public boolean isSimulation() {
         return simulation;
@@ -255,6 +303,7 @@ public abstract class GameImpl implements Game {
     @Override
     public Game createSimulationForAI() {
         Game res = this.copy();
+        ((GameImpl) res).lastPriority = lastPriority;
         ((GameImpl) res).simulation = true;
         ((GameImpl) res).aiGame = true;
         return res;
@@ -948,7 +997,14 @@ public abstract class GameImpl implements Game {
         }
         return savedStates.size();
     }
-
+    // In mage.game.GameImpl.java
+    @Override
+    public void addCard(UUID cardId, Card card) {
+        // This public method allows our reconstructor to populate the master card map.
+        if (cardId != null && card != null) {
+            this.gameCards.put(cardId, card);
+        }
+    }
     /**
      * Warning, for inner usage only, use player.restoreState as much as possible instead
      *
@@ -1459,13 +1515,13 @@ public abstract class GameImpl implements Game {
             // This is not a real emblem. Just a fake source for the
             // inherent trigger ability related to Rad counters
             // Faking a source just to display something on the stack ability.
-            state.addHelperEmblem(new RadiationEmblem(), playerId);
+            //state.addHelperEmblem(new RadiationEmblem(), playerId);
         }
 
         // global card hints for better UX
         for (UUID playerId : state.getPlayerList(startingPlayerId)) {
-            state.addHelperEmblem(new XmageHelperEmblem().withCardHint("storm counter", StormAbility.getHint()), playerId);
-            state.addHelperEmblem(new XmageHelperEmblem().withCardHint("day or night", DayNightHint.instance), playerId);
+            //state.addHelperEmblem(new XmageHelperEmblem().withCardHint("storm counter", StormAbility.getHint()), playerId);
+            //state.addHelperEmblem(new XmageHelperEmblem().withCardHint("day or night", DayNightHint.instance), playerId);
         }
     }
 
@@ -1713,8 +1769,11 @@ public abstract class GameImpl implements Game {
                                 if (isPaused() || checkIfGameIsOver()) {
                                     return;
                                 }
+                                lastPriority = this.copy();
+                                lastPriorityPlayerId = player.getId();
                                 // resetPassed should be called if player performs any action
                                 if (player.priority(this)) {
+                                    assert (player.getLastActivated()!= null);
                                     if (executingRollback()) {
                                         return;
                                     }
diff --git a/Mage/src/main/java/mage/players/Player.java b/Mage/src/main/java/mage/players/Player.java
index aed45f3a4a..7b4c2b826d 100644
--- a/Mage/src/main/java/mage/players/Player.java
+++ b/Mage/src/main/java/mage/players/Player.java
@@ -70,7 +70,8 @@ public interface Player extends MageItem, Copyable<Player> {
     enum PayLifeCostLevel {
         allAbilities, nonSpellnonActivatedAbilities, onlyManaAbilities, none
     }
-
+    Ability getLastActivated();
+    void setLastActivated(Ability a);
     /**
      * Current player is real life player (human). Try to use in GUI and network engine only.
      * <p>
diff --git a/Mage/src/main/java/mage/players/PlayerImpl.java b/Mage/src/main/java/mage/players/PlayerImpl.java
index 432b0917f0..2032ff68aa 100644
--- a/Mage/src/main/java/mage/players/PlayerImpl.java
+++ b/Mage/src/main/java/mage/players/PlayerImpl.java
@@ -83,6 +83,7 @@ public abstract class PlayerImpl implements Player, Serializable {
     static final Map<PhaseStep, Step.StepPart> SILENT_PHASES_STEPS = ImmutableMap.<PhaseStep, Step.StepPart>builder().
             put(PhaseStep.DECLARE_ATTACKERS, Step.StepPart.PRE).build();
 
+    private Ability lastActivated;
     /**
      * Used to cancel waiting requests send to the player
      */
@@ -200,7 +201,7 @@ public abstract class PlayerImpl implements Player, Serializable {
     protected final List<List<Mana>> availableTriggeredManaList = new ArrayList<>();
 
     protected PlayerImpl(String name, RangeOfInfluence range) {
-        this(UUID.randomUUID());
+        this(UUID.nameUUIDFromBytes(name.getBytes()));
         this.name = name;
         this.range = range;
         hand = new CardsImpl();
@@ -218,6 +219,9 @@ public abstract class PlayerImpl implements Player, Serializable {
     }
 
     protected PlayerImpl(final PlayerImpl player) {
+
+        this.lastActivated = player.lastActivated;
+
         this.abort = player.abort;
         this.playerId = player.playerId;
 
@@ -301,7 +305,12 @@ public abstract class PlayerImpl implements Player, Serializable {
         this.phyrexianColors = player.getPhyrexianColors() != null ? player.phyrexianColors.copy() : null;
         this.designations = CardUtil.deepCopyObject(player.designations);
     }
-
+    public Ability getLastActivated() {
+        return lastActivated;
+    }
+    public void setLastActivated(Ability a) {
+        lastActivated = a;
+    }
     /**
      * Restore on rollback
      *
@@ -312,7 +321,7 @@ public abstract class PlayerImpl implements Player, Serializable {
         if (!(player instanceof PlayerImpl)) {
             throw new IllegalArgumentException("Wrong code usage: can't restore from player class " + player.getClass().getName());
         }
-
+        this.lastActivated = player.getLastActivated();
         this.name = player.getName();
         this.human = player.isHuman();
         this.life = player.getLife();
@@ -1597,8 +1606,11 @@ public abstract class PlayerImpl implements Player, Serializable {
     @Override
     public boolean activateAbility(ActivatedAbility ability, Game game) {
         if (ability == null) {
+            logger.error("activating null ability");
             return false;
         }
+        //logger.info("last activated: " + (lastActivated == null ? "null" : this.lastActivated.toString()));
+        lastActivated = ability.copy();
         boolean result;
         if (ability instanceof PassAbility) {
             pass(game);
diff --git a/Mage/src/main/java/mage/target/TargetPermanent.java b/Mage/src/main/java/mage/target/TargetPermanent.java
index c97ea339e0..aae13f22fe 100644
--- a/Mage/src/main/java/mage/target/TargetPermanent.java
+++ b/Mage/src/main/java/mage/target/TargetPermanent.java
@@ -51,7 +51,7 @@ public class TargetPermanent extends TargetObject {
 
     @Override
     public boolean canTarget(UUID id, Ability source, Game game) {
-        return canTarget(source.getControllerId(), id, source, game);
+        return canTarget(source==null ? id : source.getControllerId(), id, source, game);
     }
 
     @Override
diff --git a/Mage/src/main/java/mage/target/common/TargetDiscard.java b/Mage/src/main/java/mage/target/common/TargetDiscard.java
index 854230c9ea..f2b436a0d0 100644
--- a/Mage/src/main/java/mage/target/common/TargetDiscard.java
+++ b/Mage/src/main/java/mage/target/common/TargetDiscard.java
@@ -47,7 +47,7 @@ public class TargetDiscard extends TargetCard {
     @Override
     public boolean canTarget(UUID id, Ability source, Game game) {
         Card card = game.getPlayer(playerId).getHand().get(id, game);
-        return filter.match(card, source.getControllerId(), game);
+        return filter.match(card, source == null ? playerId : source.getControllerId(), game);
     }
 
     @Override
diff --git a/my_changes.diff b/my_changes.diff
new file mode 100644
index 0000000000..8452a7a845
--- /dev/null
+++ b/my_changes.diff
@@ -0,0 +1,391 @@
+diff --git a/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/Features.java b/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/Features.java
+index 3cc053f64a..59dc18cc24 100644
+--- a/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/Features.java
++++ b/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/Features.java
+@@ -4,20 +4,22 @@ import java.io.*;
+ import java.nio.file.Files;
+ import java.nio.file.Paths;
+ import java.util.*;
++import java.util.concurrent.atomic.AtomicInteger;
+ 
+ /**
+- *this hierarchical structure represents the mapping of every possible relevant feature encountered from a game state to
+- * an index on a 200000 dimension binary vector. the reduced form of this vector (~6000) will be used as input for both a policy and
++ * This hierarchical structure represents the mapping of every possible relevant feature encountered from a game state to
++ * an index on a 200000 dimension binary vector. The reduced form of this vector (~5000) will be used as input for both a policy and
+  * value neural network. To see how game features are mapped look at StateEncoder.java this data structure only handles and stores the
+- * mappings
++ * mappings.
++ *
+  * @author willwroble
+  */
+-public class Features  implements Serializable {
+-    private static final long serialVersionUID = 1L;
+-    public int globalIndexCount;
+-    Set<Integer> ignoreList;
+-    Map<Integer, Integer> rawToReduced;
+-    int version;
++public class Features implements Serializable {
++    private static final long serialVersionUID = 2L; // Version updated for the structural change
++    public AtomicInteger localIndexCount; // a mutable, thread-safe counter
++    public int previousLocalIndexCount = 0;
++    public Set<Integer> ignoreList;
++    public int version = 0;
+ 
+     private final Map<String, Map<Integer, Features>> subFeatures;
+     private final Map<String, Map<Integer, Integer>> features;
+@@ -28,12 +30,13 @@ public class Features  implements Serializable {
+     private final Set<Features> categories; //resets every state represents temporary category features fall under
+     public boolean passToParent = true;
+ 
+-    private StateEncoder encoder;
++    private transient StateEncoder encoder;
+ 
+     private String featureName;
+-    private Features parent;
++    public Features parent;
+     public static boolean printOldFeatures = true;
+     public static boolean printNewFeatures = true;
++
+     public Features() {
+         //constructor
+         subFeatures = new HashMap<>();
+@@ -43,58 +46,82 @@ public class Features  implements Serializable {
+         numericOccurrences = new HashMap<>();
+         categoriesForChildren = new HashMap<>();
+         categories = new HashSet<>();
++        ignoreList = new HashSet<>();
++        localIndexCount = new AtomicInteger(0);
+         parent = null;
+         featureName = "root";
+     }
++
+     public Features(Features p, String name) {
+         this();
++        // Manually set fields instead of calling this(), to avoid creating a new AtomicInteger
+         parent = p;
+         featureName = name;
+         encoder = p.encoder;
++        localIndexCount = p.localIndexCount;
++    }
++
++    public Features(String name, StateEncoder e, AtomicInteger i) {
++        this();
++        featureName = name;
++        encoder = e;
++        localIndexCount = i;
+     }
+ 
+     public void setEncoder(StateEncoder encoder) {
+         this.encoder = encoder;
++        for (String n : subFeatures.keySet()) {
++            for (Integer i : subFeatures.get(n).keySet()) {
++                subFeatures.get(n).get(i).setEncoder(encoder);
++            }
++        }
++        for (String n : categoriesForChildren.keySet()) {
++            categoriesForChildren.get(n).setEncoder(encoder);
++        }
+     }
+ 
+     public Features getCategory(String name) {
+-
+-        if(categoriesForChildren.containsKey(name)) {//already contains category
++        if (categoriesForChildren.containsKey(name)) { //already contains category
+             return categoriesForChildren.get(name);
+-
+-        } else{//completely new
++        } else { //completely new
+             Features parentCategory = null;
+-            if(parent != null) parentCategory = parent.getCategory(name); //categories can have a parent
+-            Features newCat = new Features(parentCategory, name + "_" + featureName);
++            if (parent != null) parentCategory = parent.getCategory(name); //categories can have a parent
++            Features newCat;
++            if (parentCategory != null) {
++                newCat = new Features(parentCategory, name + "_" + featureName);
++            } else {
++                newCat = new Features(name + "_" + featureName, encoder, localIndexCount);
++            }
+             categoriesForChildren.put(name, newCat);
+             return newCat;
+         }
+-
+     }
+ 
+     /**
+      * gets subfeatures at name or creates them if they dont exist
++     *
+      * @param name
+      * @return subfeature at name (never returns null)
+      */
+     public Features getSubFeatures(String name) {
+         return getSubFeatures(name, true);
+     }
++
+     public Features getSubFeatures(String name, boolean passToParent) {
+         //added as normal binary feature
+         addFeature(name);
+ 
+         int n = occurrences.get(name);
+-        if(subFeatures.containsKey(name)) {//already contains feature
+-            if(subFeatures.get(name).containsKey(n)) {//contains count too
++        if (subFeatures.containsKey(name)) { //already contains feature
++            if (subFeatures.get(name).containsKey(n)) { //contains count too
+                 return subFeatures.get(name).get(n);
+-            } else {//new count
++            } else { //new count
+                 Map<Integer, Features> map = subFeatures.get(name);
+                 Features newSub = new Features(this, name + "_" + Integer.toString(n));
+                 map.put(n, newSub);
+                 return newSub;
+             }
+-        } else{//completely new
++        } else { //completely new
+             Map<Integer, Features> newMap = new HashMap<>();
+             Features newSub = new Features(this, name + "_1");
+             newMap.put(1, newSub);
+@@ -103,6 +130,7 @@ public class Features  implements Serializable {
+             return newSub;
+         }
+     }
++
+     /**
+      * similar to a subfeature a category will pool features within itself. however
+      * unlike subfeatures a feature can inherit multiple categories(ie card type and color).
+@@ -110,6 +138,7 @@ public class Features  implements Serializable {
+      * this function creates/finds the category with the given name and adds it as a
+      * category for this feature to pass up to, similar to the parent
+      * Categories should always be added before features
++     *
+      * @param name
+      */
+     public void addCategory(String name) {
+@@ -117,94 +146,105 @@ public class Features  implements Serializable {
+         Features categoryFeature = parent.getCategory(name);
+         categories.add(categoryFeature);
+     }
++
+     public void addFeature(String name) {
+         addFeature(name, true);
+     }
++
+     public void addFeature(String name, boolean callParent) {
+         //usually add feature to parent/categories
+-        if(parent != null && callParent && passToParent) {
++        if (parent != null && callParent && passToParent) {
+             parent.addFeature(name);
+-            for(Features c : categories) {
++            for (Features c : categories) {
+                 c.addFeature(name);
+             }
+         }
+ 
+-        if(features.containsKey(name)) {//has feature
+-            int count = occurrences.get(name)+1;
++        if (features.containsKey(name)) { //has feature
++            int count = occurrences.get(name) + 1;
+             occurrences.put(name, count);
+-            if(features.get(name).containsKey(count)) {//already contains feature at this count
+-                if(printOldFeatures) System.out.printf("Index %d is already reserved for feature %s at %d times in %s\n", features.get(name).get(count), name, count, featureName);
+-            } else {//contains feature but different count
+-                features.get(name).put(count, StateEncoder.indexCount++);
+-                if(printNewFeatures) System.out.printf("Feature %s exists but has not occurred %d times, reserving index %d for the %d occurrence of this feature in %s\n",
+-                        name, count, StateEncoder.indexCount-1, count, featureName);
++            if (features.get(name).containsKey(count)) { //already contains feature at this count
++                if (printOldFeatures)
++                    System.out.printf("Index %d is already reserved for feature %s at %d times in %s\n", features.get(name).get(count), name, count, featureName);
++            } else { //contains feature but different count
++                features.get(name).put(count, localIndexCount.getAndIncrement()); //  FIXED: Use atomic increment
++                if (printNewFeatures)
++                    System.out.printf("Feature %s exists but has not occurred %d times, reserving index %d for the %d occurrence of this feature in %s\n",
++                            name, count, localIndexCount.get() - 1, count, featureName);
+             }
+-        } else {//completely new feature
++        } else { //completely new feature
+             occurrences.put(name, 1);
+             Map<Integer, Integer> n = new HashMap<>();
+-            n.put(1, StateEncoder.indexCount++);
++            n.put(1, localIndexCount.getAndIncrement());
+             features.put(name, n);
+-            if(printNewFeatures) System.out.printf("New feature %s discovered in %s, reserving index %d for this feature\n", name, featureName, n.get(1));
++            if (printNewFeatures)
++                System.out.printf("New feature %s discovered in %s, reserving index %d for this feature\n", name, featureName, n.get(1));
+         }
+-        StateEncoder.featureVector.add(features.get(name).get(occurrences.get(name)));
++        encoder.featureVector.add(features.get(name).get(occurrences.get(name)));
+     }
++
+     public void addNumericFeature(String name, int num) {
+         addNumericFeature(name, num, true);
+     }
++
+     public void addNumericFeature(String name, int num, boolean callParent) {
+         //usually add feature to parent/categories
+-        if(parent != null && callParent && passToParent) {
++        if (parent != null && callParent && passToParent) {
+             parent.addNumericFeature(name, num);
+         }
+ 
+         //also adds copy to number right below this one which will recursively increment the occurrences of each lesser feature
+         //Integer nextHighest = numericFeatures.get(name).floorKey(num-1);
+-        if(num > 0) addNumericFeature(name, num-1, false);
++        if (num > 0) addNumericFeature(name, num - 1, false);
+ 
+-        if(numericFeatures.containsKey(name)) {
+-
+-            if(numericFeatures.get(name).containsKey(num)) {
+-                int count = numericOccurrences.get(name).get(num)+1;
++        if (numericFeatures.containsKey(name)) {
++            if (numericFeatures.get(name).containsKey(num)) {
++                int count = numericOccurrences.get(name).get(num) + 1;
+                 numericOccurrences.get(name).put(num, count);
+ 
+-                if(numericFeatures.get(name).get(num).containsKey(count)) {//already contains feature at this count
+-                    if(printOldFeatures) System.out.printf("Index %d is already reserved for numeric feature %s with %d at %d times in %s\n", numericFeatures.get(name).get(num).get(count), name, num, count, featureName);
+-                } else {//contains feature and num but different count
+-                    numericFeatures.get(name).get(num).put(count, StateEncoder.indexCount++);
+-                    if(printNewFeatures) System.out.printf("Numeric feature %s with %d exists but has not occurred %d times, reserving index %d for the %d occurrence of this feature in %s\n",
+-                            name, num, count, StateEncoder.indexCount-1, count, featureName);
++                if (numericFeatures.get(name).get(num).containsKey(count)) { //already contains feature at this count
++                    if (printOldFeatures)
++                        System.out.printf("Index %d is already reserved for numeric feature %s with %d at %d times in %s\n", numericFeatures.get(name).get(num).get(count), name, num, count, featureName);
++                } else { //contains feature and num but different count
++                    numericFeatures.get(name).get(num).put(count, localIndexCount.getAndIncrement());
++                    if (printNewFeatures)
++                        System.out.printf("Numeric feature %s with %d exists but has not occurred %d times, reserving index %d for the %d occurrence of this feature in %s\n",
++                                name, num, count, localIndexCount.get() - 1, count, featureName);
+                 }
+             } else { //contains category but not this number
+                 Map<Integer, Map<Integer, Integer>> map = numericFeatures.get(name);
+                 Map<Integer, Integer> subMap = new HashMap<>();
+-                subMap.put(1, StateEncoder.indexCount++);
++                subMap.put(1, localIndexCount.getAndIncrement());
+                 map.put(num, subMap);
+                 numericOccurrences.get(name).put(num, 1);
+-                if(printNewFeatures) System.out.printf("Numeric feature %s exists but has not occurred with %d, reserving index %d for this feature at %d in %s\n",
+-                        name, num, StateEncoder.indexCount-1, num, featureName);
++                if (printNewFeatures)
++                    System.out.printf("Numeric feature %s exists but has not occurred with %d, reserving index %d for this feature at %d in %s\n",
++                            name, num, localIndexCount.get() - 1, num, featureName);
+             }
+-        } else {//completely new feature category
++        } else { //completely new feature category
+             TreeMap<Integer, Map<Integer, Integer>> newMap = new TreeMap<>();
+             Map<Integer, Integer> subMap = new HashMap<>();
+-            subMap.put(1, StateEncoder.indexCount++);
++            subMap.put(1, localIndexCount.getAndIncrement());
+             newMap.put(num, subMap);
+             numericFeatures.put(name, newMap);
+             TreeMap<Integer, Integer> newTreeMap = new TreeMap<>();
+             newTreeMap.put(num, 1);
+             numericOccurrences.put(name, newTreeMap);
+-            if(printNewFeatures) System.out.printf("New numeric feature %s discovered with %d in %s, reserving index %d for this feature at %d\n", name,
+-                    num, featureName, StateEncoder.indexCount-1, num);
++            if (printNewFeatures)
++                System.out.printf("New numeric feature %s discovered with %d in %s, reserving index %d for this feature at %d\n", name,
++                        num, featureName, localIndexCount.get() - 1, num);
+         }
+-        StateEncoder.featureVector.add(numericFeatures.get(name).get(num).get(numericOccurrences.get(name).get(num)));
++        encoder.featureVector.add(numericFeatures.get(name).get(num).get(numericOccurrences.get(name).get(num)));
+     }
++
+     public void stateRefresh() {
+         categories.clear();
+         occurrences.replaceAll((k, v) -> 0);
+-        for(String c : numericOccurrences.keySet()) {
++        for (String c : numericOccurrences.keySet()) {
+             numericOccurrences.get(c).replaceAll((k, v) -> 0);
+         }
+-        for(String n : subFeatures.keySet()) {
+-            for(int i : subFeatures.get(n).keySet()) {
++        for (String n : subFeatures.keySet()) {
++            for (int i : subFeatures.get(n).keySet()) {
+                 subFeatures.get(n).get(i).stateRefresh();
+             }
+         }
+@@ -213,6 +253,78 @@ public class Features  implements Serializable {
+         }
+     }
+ 
++    /**
++     * always discard f after merging
++     *
++     * @param f object to merge with
++     */
++    public synchronized void merge(Features f) {
++        if (this == f) return;
++
++        // Normal features
++        for (String n : f.features.keySet()) {
++            Map<Integer, Integer> thisOccurrenceMap = this.features.computeIfAbsent(n, k -> new HashMap<>());
++            this.occurrences.putIfAbsent(n, 0);
++            for (int i : f.features.get(n).keySet()) {
++                if (!thisOccurrenceMap.containsKey(i)) {
++                    thisOccurrenceMap.put(i, this.localIndexCount.getAndIncrement());
++                }
++            }
++        }
++
++        // Numeric features
++        for (String n : f.numericFeatures.keySet()) {
++            TreeMap<Integer, Map<Integer, Integer>> thisNumericMap = this.numericFeatures.computeIfAbsent(n, k -> new TreeMap<>());
++            this.numericOccurrences.putIfAbsent(n, new TreeMap<>());
++            for (int num : f.numericFeatures.get(n).keySet()) {
++                Map<Integer, Integer> thisOccurrenceMap = thisNumericMap.computeIfAbsent(num, k -> new HashMap<>());
++                this.numericOccurrences.get(n).putIfAbsent(num, 0);
++                for (int i  : f.numericFeatures.get(n).get(num).keySet()) {
++                    if (!thisOccurrenceMap.containsKey(i)) {
++                        thisOccurrenceMap.put(i, this.localIndexCount.getAndIncrement());
++                    }
++                }
++            }
++        }
++        //subfeatures
++        for (String n : f.subFeatures.keySet()) {
++            Map<Integer, Features> thisSubMap = this.subFeatures.computeIfAbsent(n, k -> new HashMap<>());
++            for (int i : f.subFeatures.get(n).keySet()) {
++                Features thisSubFeature = thisSubMap.computeIfAbsent(i, k -> new Features(this, n + "_" + i));
++                thisSubFeature.merge(f.subFeatures.get(n).get(i));
++            }
++        }
++        //category labels
++        for (String n : f.categoriesForChildren.keySet()) {
++            if (!this.categoriesForChildren.containsKey(n)) {
++                this.categoriesForChildren.put(n, this.getCategory(n));
++            }
++            this.categoriesForChildren.get(n).merge(f.categoriesForChildren.get(n));
++        }
++    }
++    /**
++     * Creates a synchronized, deep copy of this Features object.
++     * By being synchronized, it ensures we get a clean snapshot and never
++     * copy the object while another thread is in the middle of merging.
++     * @return A new, completely independent deep copy of this object.
++     */
++    public synchronized Features createDeepCopy() {
++        try {
++            ByteArrayOutputStream byteOutput = new ByteArrayOutputStream();
++            ObjectOutputStream objectOutput = new ObjectOutputStream(byteOutput);
++            objectOutput.writeObject(this);
++            objectOutput.close();
++
++            ByteArrayInputStream byteInput = new ByteArrayInputStream(byteOutput.toByteArray());
++            ObjectInputStream objectInput = new ObjectInputStream(byteInput);
++            Features copy = (Features) objectInput.readObject();
++            objectInput.close();
++
++            return copy;
++        } catch (IOException | ClassNotFoundException e) {
++            throw new RuntimeException("Failed to create a deep copy of the Features object.", e);
++        }
++    }
+     // Helper method to persist the Features mapping to a file
+     public void saveMapping(String filename) throws IOException {
+         try (ObjectOutputStream oos = new ObjectOutputStream(Files.newOutputStream(Paths.get(filename)))) {
+@@ -226,4 +338,4 @@ public class Features  implements Serializable {
+             return (Features) ois.readObject();
+         }
+     }
+-}
++}
+\ No newline at end of file
diff --git a/node_modules/.package-lock.json b/node_modules/.package-lock.json
new file mode 100644
index 0000000000..c4b6cf37bd
--- /dev/null
+++ b/node_modules/.package-lock.json
@@ -0,0 +1,7 @@
+{
+  "name": "mage",
+  "version": "1.0.0",
+  "lockfileVersion": 3,
+  "requires": true,
+  "packages": {}
+}
diff --git a/package-lock.json b/package-lock.json
new file mode 100644
index 0000000000..1c22f60c00
--- /dev/null
+++ b/package-lock.json
@@ -0,0 +1,13 @@
+{
+  "name": "mage",
+  "version": "1.0.0",
+  "lockfileVersion": 3,
+  "requires": true,
+  "packages": {
+    "": {
+      "name": "mage",
+      "version": "1.0.0",
+      "license": "ISC"
+    }
+  }
+}
diff --git a/package.json b/package.json
new file mode 100644
index 0000000000..261a48d2dc
--- /dev/null
+++ b/package.json
@@ -0,0 +1,20 @@
+{
+  "name": "mage",
+  "version": "1.0.0",
+  "description": "[![Build Status](https://app.travis-ci.com/magefree/mage.svg?branch=master)](https://app.travis-ci.com/magefree/mage)\r [![Lines of Code](https://sonarcloud.io/api/project_badges/measure?project=magefree_mage&metric=ncloc)](https://sonarcloud.io/summary/new_code?id=magefree_mage)\r [![Coverage](https://sonarcloud.io/api/project_badges/measure?project=magefree_mage&metric=coverage)](https://sonarcloud.io/summary/new_code?id=magefree_mage)\r [![Technical Debt](https://sonarcloud.io/api/project_badges/measure?project=magefree_mage&metric=sqale_index)](https://sonarcloud.io/summary/new_code?id=magefree_mage)\r [![latest release](https://img.shields.io/github/v/release/magefree/mage)](https://github.com/magefree/mage/releases/)\r [![commints since latest release](https://img.shields.io/github/commits-since/magefree/mage/latest)](https://github.com/magefree/mage/commits/)\r [![Join the chat at https://gitter.im/magefree/mage](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/magefree/mage?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)",
+  "main": "index.js",
+  "scripts": {
+    "test": "echo \"Error: no test specified\" && exit 1"
+  },
+  "repository": {
+    "type": "git",
+    "url": "git+https://github.com/WillWroble/mage.git"
+  },
+  "keywords": [],
+  "author": "",
+  "license": "ISC",
+  "bugs": {
+    "url": "https://github.com/WillWroble/mage/issues"
+  },
+  "homepage": "https://github.com/WillWroble/mage#readme"
+}
