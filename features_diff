diff --git a/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/ComputerPlayer8.java b/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/ComputerPlayer8.java
index 3e25bb645c..b94f825eb7 100644
--- a/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/ComputerPlayer8.java
+++ b/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/ComputerPlayer8.java
@@ -135,13 +135,12 @@ public class ComputerPlayer8 extends ComputerPlayer7{
                         getAbilityAndSourceInfo(game, ability, true)
                 ));
                 //save action vector
-                ActionEncoder.addAction(getActionVec(ability));
+                encoder.addAction(getActionVec(ability));
                 //save state vector
-                encoder.processMacroState(game);
+                encoder.processMacroState(game, getId());
                 //add scores
-                double perspectiveFactor = getId() == encoder.myPlayerID ? 1.0 : -1.0;
+                double perspectiveFactor = getId() == encoder.getMyPlayerID() ? 1.0 : -1.0;
                 encoder.stateScores.add(perspectiveFactor*Math.tanh(root.score*1.0/20000));
-                //encoder.activeStates.add(getId() == encoder.myPlayerID);
                 if (!ability.getTargets().isEmpty()) {
                     for (Target target : ability.getTargets()) {
                         for (UUID id : target.getTargets()) {
diff --git a/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/ComputerPlayerMCTS2.java b/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/ComputerPlayerMCTS2.java
index da9e8d7a62..38cd6837cc 100644
--- a/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/ComputerPlayerMCTS2.java
+++ b/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/ComputerPlayerMCTS2.java
@@ -65,7 +65,7 @@ public class ComputerPlayerMCTS2 extends ComputerPlayerMCTS {
 
         int[] activeGlobalIndices;
 
-        encoder.processState(node.getGame());
+        encoder.processState(node.getGame(), getId());
         activeGlobalIndices = encoder.getFinalActiveGlobalIndicesArray();
 
 
@@ -259,8 +259,8 @@ public class ComputerPlayerMCTS2 extends ComputerPlayerMCTS {
             MCTSNode best = root.bestChild();
             if(best == null) return;
 
-            encoder.processMacroState(game);
-            ActionEncoder.addAction(getActionVec());
+            encoder.processMacroState(game, getId());
+            encoder.addAction(getActionVec());
             encoder.stateScores.add(root.getWinRatio());
             Game copiedState = game.copy();
             if(buffer != null)
diff --git a/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/ComputerPlayerPureMCTS.java b/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/ComputerPlayerPureMCTS.java
index ad6f87b4a3..16210cbb92 100644
--- a/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/ComputerPlayerPureMCTS.java
+++ b/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/ComputerPlayerPureMCTS.java
@@ -4,37 +4,37 @@ import ai.onnxruntime.OrtException;
 import mage.constants.PhaseStep;
 import mage.constants.RangeOfInfluence;
 import mage.game.Game;
+import mage.game.GameState;
 import mage.player.ai.MCTSPlayer.NextAction;
 import mage.util.RandomUtil;
 import mage.util.ThreadUtils;
 import mage.util.XmageThreadFactory;
 import org.apache.log4j.Logger;
 
-import java.util.ArrayList;
-import java.util.List;
-import java.util.UUID;
+import java.util.*;
 import java.util.concurrent.*;
 
 /**
- * ComputerPlayerPureMCTS extends ComputerPlayerMCTS and uses random rollouts to maxaminze feature discovery
+ * ComputerPlayerPureMCTS extends ComputerPlayerMCTS and always returns 0 at leaf nodes.
+ * It is designed as a purely random chaotic agent for feature discovery
  */
 public class ComputerPlayerPureMCTS extends ComputerPlayerMCTS {
 
     private static final Logger logger = Logger.getLogger(ComputerPlayerPureMCTS.class);
 
-    private StateEncoder encoder = null;
-    private static final int MAX_MCTS_CYCLES = 5;//number of additional cycles the search is allowed to run
-    private static final int BASE_THREAD_TIMEOUT = 3;//seconds
-    private static final int MIN_TREE_VISITS = 100;
+    private transient StateEncoder encoder = null;
+    private transient ReplayBuffer buffer = null;
+    private static final int MAX_MCTS_CYCLES = 6;//number of additional cycles the search is allowed to run
+    private static final int BASE_THREAD_TIMEOUT = 1;//seconds
+    private static final int MIN_TREE_VISITS = 50;//per child per thread
 
     public static boolean SHOW_THREAD_INFO = false;
-    private final Object encoderLock = new Object();
+
 
 
 
     public ComputerPlayerPureMCTS(String name, RangeOfInfluence range, int skill) {
         super(name, range, skill);
-
     }
 
     protected ComputerPlayerPureMCTS(UUID id) {
@@ -51,34 +51,22 @@ public class ComputerPlayerPureMCTS extends ComputerPlayerMCTS {
         return new ComputerPlayerPureMCTS(this);
     }
 
-
-
+    /**
+     * just meaningless exploration
+     * @param node
+     * @return
+     */
+    protected double evaluateState(MCTSNode node) {
+        encoder.processMacroState(node.getGame(), getId());
+        encoder.addAction(getActionVec());
+        encoder.stateScores.add(0.0);
+        return 0;
+    }
     public void setEncoder(StateEncoder enc) {
         encoder = enc;
     }
-
-    public StateEncoder getEncoder() {
-        return encoder;
-    }
-    public int diffVisits(List<Integer> children) {
-        int max = -1;
-        int max2 = -1;//second highest
-        for(int n : children) {
-            if(n > max) {
-                max2 = max;
-                max = n;
-            } else if(n > max2) {
-                max2 = n;
-            }
-        }
-        return max-max2;
-    }
-    protected double evaluateState(MCTSNode node) {
-        synchronized(encoderLock) {
-            encoder.processMacroState(node.getGame());
-            if(node.getAction() != null)ActionEncoder.getAction(node.getAction());
-        }
-        return 0;
+    public void setBuffer(ReplayBuffer buf) {
+        buffer = buf;
     }
     public int averageVisits(List<Integer> children) {
         int sum = 0;
@@ -106,10 +94,11 @@ public class ComputerPlayerPureMCTS extends ComputerPlayerMCTS {
         int initialVisits = root.getAverageVisits();
         //if(initialVisits > MAX_TREE_VISITS) return;//just keep using tree
         if(SHOW_THREAD_INFO) System.out.printf("STARTING ROOT VISITS: %d\n", initialVisits);
-        int thinkTime = BASE_THREAD_TIMEOUT;//calculateThinkTime(game, action);
+        int thinkTime = BASE_THREAD_TIMEOUT;
 
 
         if (this.threadPoolSimulations == null) {
+            System.out.println(poolSize);
             this.threadPoolSimulations = new ThreadPoolExecutor(
                     poolSize,
                     poolSize,
@@ -120,10 +109,12 @@ public class ComputerPlayerPureMCTS extends ComputerPlayerMCTS {
             );
         }
         List<MCTSExecutor> tasks = new ArrayList<>();
+        long seed = RandomUtil.nextInt();
         for (int i = 0; i < poolSize; i++) {
             Game sim = createMCTSGame(game);
             MCTSPlayer player = (MCTSPlayer) sim.getPlayer(playerId);
             player.setNextAction(action);
+            player.dirichletSeed = seed;
             // Create an executor that overrides rollout() to use evaluateState().
             MCTSExecutor exec = new MCTSExecutor(sim, playerId, thinkTime) {
                 @Override
@@ -131,7 +122,7 @@ public class ComputerPlayerPureMCTS extends ComputerPlayerMCTS {
                     // Instead of a full simulation, evaluate the leaf state with our value function.
                     return evaluateState(node);
                 }
-            };;
+            };
             tasks.add(exec);
         }
         //runs mcts sims until the root has been visited enough times
@@ -139,11 +130,13 @@ public class ComputerPlayerPureMCTS extends ComputerPlayerMCTS {
         int cycleCounter = 0;
         int fullTime = 0;
 
-        while (averageVisits(childVisits)+initialVisits < MIN_TREE_VISITS) {//use max visits of children as indicator
+        while (averageVisits(childVisits)+initialVisits < MIN_TREE_VISITS*poolSize) {//use max visits of children as indicator
 
-            if (cycleCounter > MAX_MCTS_CYCLES) break;
-            cycleCounter++;
+            if (cycleCounter > MAX_MCTS_CYCLES) break; //early exit
+
+            //if(diffVisits(childVisits) > 2.5 && averageVisits(childVisits) > MIN_TREE_VISITS*poolSize*0.5) break;
 
+            cycleCounter++;
             try {
                 List<Future<Boolean>> runningTasks = threadPoolSimulations.invokeAll(tasks, thinkTime, TimeUnit.SECONDS);
                 for (Future<Boolean> runningTask : runningTasks) {
@@ -156,7 +149,9 @@ public class ComputerPlayerPureMCTS extends ComputerPlayerMCTS {
                     throw new IllegalStateException("One of the simulated games raised an error: " + e, e);
                 }
             }
+
             childVisits = getChildVisits(tasks);
+
             if (SHOW_THREAD_INFO) {
                 System.out.printf("CYCLE %d: %d threads were created\n", cycleCounter, tasks.size());
                 for (MCTSExecutor task : tasks) {
@@ -167,7 +162,6 @@ public class ComputerPlayerPureMCTS extends ComputerPlayerMCTS {
                 System.out.printf("\nCOMPOSITE CHILDREN: %s\n", childVisits.toString());
             }
             fullTime += thinkTime;
-            thinkTime += 1;
         }
         int simCount = 0;
         for (MCTSExecutor task : tasks) {
@@ -186,8 +180,54 @@ public class ComputerPlayerPureMCTS extends ComputerPlayerMCTS {
         }
         MCTSNode.logHitMiss();
     }
+    double[] getActionVec() {
+        double tau = 1.0;            // your temperature hyperparam
+        int    A   = 128;
+        double[] out = new double[A];
+        double   sum = 0;
+        // 1) accumulate visits^(1/tau)
+        for (MCTSNode child : root.children) {
+            if (child.getAction() != null) {
+                int idx = ActionEncoder.getAction(child.getAction());
+                double v = child.visits;
+                // apply temperature
+                double vt = Math.pow(v, 1.0 / tau);
+                out[idx] = vt;
+                sum += vt;
+            }
+        }
+
+        // 2) normalize into a proper distribution
+        if (sum > 0) {
+            for (int i = 0; i < A; i++) {
+                out[i] = out[i] / sum;
+            }
+        }
+        return out;
+    }
+    @Override
+    protected void calculateActions(Game game, NextAction action) {
+        if (root == null) {
+            Game sim = createMCTSGame(game);
+            MCTSPlayer player = (MCTSPlayer) sim.getPlayer(playerId);
+            player.setNextAction(action);
+            root = new MCTSNode(playerId, sim);
+            root.chooseTargetAction = new ArrayList<>(chooseTargetAction);
+        }
+        applyMCTS(game, action);
+        if (root != null) {
+            MCTSNode best = root.bestChild();
+            if(best == null) return;
+
+            encoder.processMacroState(game, getId());
+            encoder.addAction(getActionVec());
+            encoder.stateScores.add(root.getWinRatio());
 
-    private static List<Integer> getChildVisits(List<MCTSExecutor> tasks) {
+            root = best;
+            root.emancipate();
+        }
+    }
+    private List<Integer> getChildVisits(List<MCTSExecutor> tasks) {
         List<Integer> childVisits = new ArrayList<>();
         int min = Integer.MAX_VALUE;
         for(MCTSExecutor task : tasks) {
@@ -196,7 +236,7 @@ public class ComputerPlayerPureMCTS extends ComputerPlayerMCTS {
 
         for(int i = 0; i <  min; i++) {
             int visitSum = 0;
-            for(int j = 0; j < 8; j++) {
+            for(int j = 0; j < poolSize; j++) {
                 visitSum += tasks.get(j).root.children.get(i).visits;
             }
             childVisits.add(visitSum);
diff --git a/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/FeatureMerger.java b/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/FeatureMerger.java
index 539fea5e00..108e887937 100644
--- a/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/FeatureMerger.java
+++ b/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/FeatureMerger.java
@@ -1,5 +1,7 @@
 package mage.player.ai;
 
+import com.j256.ormlite.stmt.query.In;
+
 import java.util.*;
 
 public class FeatureMerger {
@@ -113,4 +115,76 @@ public class FeatureMerger {
         }
         return ignoreList;
     }
+    /**
+     * Computes an ignore list for features using LabeledState objects.
+     * Assumes LabeledState.activeGlobalIndices is an int[] of active global feature indices.
+     * @param endIndex max index to use
+     * @param labeledStates List of LabeledState objects.
+     * @return A Set of feature indices to ignore.
+     */
+    public static Set<Integer> computeIgnoreListFromLS(List<LabeledState> labeledStates, int startIndex, int endIndex) {
+        int M = labeledStates.size();
+        if (M == 0) {
+            return Collections.emptySet();
+        }
+
+        BitSet[] patterns = new BitSet[endIndex];
+        for (int f = startIndex; f < endIndex; f++) {
+            patterns[f] = new BitSet(M);
+        }
+
+        for (int row = 0; row < M; row++) {
+            // Assuming LabeledState now has a field like 'activeGlobalIndices' of type int[]
+            int[] activeIndices = labeledStates.get(row).stateVector;
+            for (int activeFeatureIndex : activeIndices) {
+                if (activeFeatureIndex >= startIndex && activeFeatureIndex < endIndex) {
+                    patterns[activeFeatureIndex].set(row);
+                } else {
+                    // Log or handle out-of-bounds index
+                }
+            }
+        }
+
+        // The rest of the logic is identical to computeIgnoreList
+        Map<BitSet, Integer> representative = new HashMap<>(endIndex);
+        Set<Integer> ignoreList = new HashSet<>();
+
+        for (int f = startIndex; f < endIndex; f++) {
+            BitSet pattern = patterns[f];
+            if (pattern.isEmpty()) {
+                ignoreList.add(f);
+                continue;
+            }
+            BitSet key = (BitSet) pattern.clone();
+            Integer first = representative.get(key);
+            if (first == null) {
+                representative.put(key, f);
+            } else {
+                ignoreList.add(f);
+            }
+        }
+        return ignoreList;
+    }
+    /**
+     * Compresses a raw feature vector by removing any indices present in the ignore set.
+     * @param ignore The Set of feature indices to remove.
+     * @param stateVector The uncompressed array of feature indices.
+     * @return A new, compressed array of feature indices.
+     */
+    public static int[] getCompressedVectorArray(Set<Integer> ignore, int[] stateVector) {
+        // Use a List to dynamically store the features that are kept.
+        List<Integer> compressedList = new ArrayList<>();
+        for (int featureIndex : stateVector) {
+            if (!ignore.contains(featureIndex)) {
+                compressedList.add(featureIndex);
+            }
+        }
+
+        // Convert the List to a primitive int array for final storage.
+        int[] out = new int[compressedList.size()];
+        for (int i = 0; i < compressedList.size(); i++) {
+            out[i] = compressedList.get(i);
+        }
+        return out;
+    }
 }
\ No newline at end of file
diff --git a/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/Features.java b/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/Features.java
index 3cc053f64a..0fd9dcdf12 100644
--- a/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/Features.java
+++ b/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/Features.java
@@ -4,20 +4,22 @@ import java.io.*;
 import java.nio.file.Files;
 import java.nio.file.Paths;
 import java.util.*;
+import java.util.concurrent.atomic.AtomicInteger;
 
 /**
- *this hierarchical structure represents the mapping of every possible relevant feature encountered from a game state to
- * an index on a 200000 dimension binary vector. the reduced form of this vector (~6000) will be used as input for both a policy and
+ * This hierarchical structure represents the mapping of every possible relevant feature encountered from a game state to
+ * an index on a 200000 dimension binary vector. The reduced form of this vector (~5000) will be used as input for both a policy and
  * value neural network. To see how game features are mapped look at StateEncoder.java this data structure only handles and stores the
- * mappings
+ * mappings.
+ *
  * @author willwroble
  */
-public class Features  implements Serializable {
-    private static final long serialVersionUID = 1L;
-    public int globalIndexCount;
-    Set<Integer> ignoreList;
-    Map<Integer, Integer> rawToReduced;
-    int version;
+public class Features implements Serializable {
+    private static final long serialVersionUID = 2L; // Version updated for the structural change
+    public AtomicInteger localIndexCount; // a mutable, thread-safe counter
+    public int previousLocalIndexCount = 0;
+    public Set<Integer> ignoreList;
+    public int version = 0;
 
     private final Map<String, Map<Integer, Features>> subFeatures;
     private final Map<String, Map<Integer, Integer>> features;
@@ -28,12 +30,13 @@ public class Features  implements Serializable {
     private final Set<Features> categories; //resets every state represents temporary category features fall under
     public boolean passToParent = true;
 
-    private StateEncoder encoder;
+    private transient StateEncoder encoder;
 
     private String featureName;
-    private Features parent;
+    public Features parent;
     public static boolean printOldFeatures = true;
     public static boolean printNewFeatures = true;
+
     public Features() {
         //constructor
         subFeatures = new HashMap<>();
@@ -43,58 +46,84 @@ public class Features  implements Serializable {
         numericOccurrences = new HashMap<>();
         categoriesForChildren = new HashMap<>();
         categories = new HashSet<>();
+        ignoreList = new HashSet<>();
+        localIndexCount = new AtomicInteger(0);
         parent = null;
         featureName = "root";
     }
+
     public Features(Features p, String name) {
         this();
+        // Manually set fields instead of calling this(), to avoid creating a new AtomicInteger
         parent = p;
         featureName = name;
         encoder = p.encoder;
+        localIndexCount = p.localIndexCount;
+    }
+
+    public Features(String name, StateEncoder e, AtomicInteger i) {
+        this();
+        featureName = name;
+        encoder = e;
+        localIndexCount = i;
     }
 
     public void setEncoder(StateEncoder encoder) {
         this.encoder = encoder;
+        for (String n : subFeatures.keySet()) {
+            for (Integer i : subFeatures.get(n).keySet()) {
+                subFeatures.get(n).get(i).setEncoder(encoder);
+            }
+        }
+        for (String n : categoriesForChildren.keySet()) {
+            categoriesForChildren.get(n).setEncoder(encoder);
+        }
     }
 
     public Features getCategory(String name) {
-
-        if(categoriesForChildren.containsKey(name)) {//already contains category
+        if(name.isEmpty()) return null;
+        if (categoriesForChildren.containsKey(name)) { //already contains category
             return categoriesForChildren.get(name);
-
-        } else{//completely new
+        } else { //completely new
             Features parentCategory = null;
-            if(parent != null) parentCategory = parent.getCategory(name); //categories can have a parent
-            Features newCat = new Features(parentCategory, name + "_" + featureName);
+            if (parent != null) parentCategory = parent.getCategory(name); //categories can have a parent
+            Features newCat;
+            if (parentCategory != null) {
+                newCat = new Features(parentCategory, name + "_" + featureName);
+            } else {
+                newCat = new Features(name + "_" + featureName, encoder, localIndexCount);
+            }
             categoriesForChildren.put(name, newCat);
             return newCat;
         }
-
     }
 
     /**
      * gets subfeatures at name or creates them if they dont exist
+     *
      * @param name
      * @return subfeature at name (never returns null)
      */
     public Features getSubFeatures(String name) {
         return getSubFeatures(name, true);
     }
+
     public Features getSubFeatures(String name, boolean passToParent) {
+        if(name.isEmpty()) return null;
         //added as normal binary feature
         addFeature(name);
 
         int n = occurrences.get(name);
-        if(subFeatures.containsKey(name)) {//already contains feature
-            if(subFeatures.get(name).containsKey(n)) {//contains count too
+        if (subFeatures.containsKey(name)) { //already contains feature
+            if (subFeatures.get(name).containsKey(n)) { //contains count too
                 return subFeatures.get(name).get(n);
-            } else {//new count
+            } else { //new count
                 Map<Integer, Features> map = subFeatures.get(name);
                 Features newSub = new Features(this, name + "_" + Integer.toString(n));
                 map.put(n, newSub);
                 return newSub;
             }
-        } else{//completely new
+        } else { //completely new
             Map<Integer, Features> newMap = new HashMap<>();
             Features newSub = new Features(this, name + "_1");
             newMap.put(1, newSub);
@@ -103,6 +132,7 @@ public class Features  implements Serializable {
             return newSub;
         }
     }
+
     /**
      * similar to a subfeature a category will pool features within itself. however
      * unlike subfeatures a feature can inherit multiple categories(ie card type and color).
@@ -110,101 +140,116 @@ public class Features  implements Serializable {
      * this function creates/finds the category with the given name and adds it as a
      * category for this feature to pass up to, similar to the parent
      * Categories should always be added before features
+     *
      * @param name
      */
     public void addCategory(String name) {
+        if(name.isEmpty()) return;
         addFeature(name); //first add as feature since every category is also a feature
         Features categoryFeature = parent.getCategory(name);
         categories.add(categoryFeature);
     }
+
     public void addFeature(String name) {
         addFeature(name, true);
     }
+
     public void addFeature(String name, boolean callParent) {
+        if(name.isEmpty()) return;
         //usually add feature to parent/categories
-        if(parent != null && callParent && passToParent) {
+        if (parent != null && callParent && passToParent) {
             parent.addFeature(name);
-            for(Features c : categories) {
+            for (Features c : categories) {
                 c.addFeature(name);
             }
         }
 
-        if(features.containsKey(name)) {//has feature
-            int count = occurrences.get(name)+1;
+        if (features.containsKey(name)) { //has feature
+            int count = occurrences.get(name) + 1;
             occurrences.put(name, count);
-            if(features.get(name).containsKey(count)) {//already contains feature at this count
-                if(printOldFeatures) System.out.printf("Index %d is already reserved for feature %s at %d times in %s\n", features.get(name).get(count), name, count, featureName);
-            } else {//contains feature but different count
-                features.get(name).put(count, StateEncoder.indexCount++);
-                if(printNewFeatures) System.out.printf("Feature %s exists but has not occurred %d times, reserving index %d for the %d occurrence of this feature in %s\n",
-                        name, count, StateEncoder.indexCount-1, count, featureName);
+            if (features.get(name).containsKey(count)) { //already contains feature at this count
+                if (printOldFeatures)
+                    System.out.printf("Index %d is already reserved for feature %s at %d times in %s\n", features.get(name).get(count), name, count, featureName);
+            } else { //contains feature but different count
+                features.get(name).put(count, localIndexCount.getAndIncrement()); //  FIXED: Use atomic increment
+                if (printNewFeatures)
+                    System.out.printf("Feature %s exists but has not occurred %d times, reserving index %d for the %d occurrence of this feature in %s\n",
+                            name, count, localIndexCount.get() - 1, count, featureName);
             }
-        } else {//completely new feature
+        } else { //completely new feature
             occurrences.put(name, 1);
             Map<Integer, Integer> n = new HashMap<>();
-            n.put(1, StateEncoder.indexCount++);
+            n.put(1, localIndexCount.getAndIncrement());
             features.put(name, n);
-            if(printNewFeatures) System.out.printf("New feature %s discovered in %s, reserving index %d for this feature\n", name, featureName, n.get(1));
+            if (printNewFeatures)
+                System.out.printf("New feature %s discovered in %s, reserving index %d for this feature\n", name, featureName, n.get(1));
         }
-        StateEncoder.featureVector.add(features.get(name).get(occurrences.get(name)));
+        encoder.featureVector.add(features.get(name).get(occurrences.get(name)));
     }
+
     public void addNumericFeature(String name, int num) {
         addNumericFeature(name, num, true);
     }
+
     public void addNumericFeature(String name, int num, boolean callParent) {
+        if(name.isEmpty()) return;
         //usually add feature to parent/categories
-        if(parent != null && callParent && passToParent) {
+        if (parent != null && callParent && passToParent) {
             parent.addNumericFeature(name, num);
         }
 
         //also adds copy to number right below this one which will recursively increment the occurrences of each lesser feature
         //Integer nextHighest = numericFeatures.get(name).floorKey(num-1);
-        if(num > 0) addNumericFeature(name, num-1, false);
-
-        if(numericFeatures.containsKey(name)) {
+        if (num > 0) addNumericFeature(name, num - 1, false);
 
-            if(numericFeatures.get(name).containsKey(num)) {
-                int count = numericOccurrences.get(name).get(num)+1;
+        if (numericFeatures.containsKey(name)) {
+            if (numericFeatures.get(name).containsKey(num)) {
+                int count = numericOccurrences.get(name).get(num) + 1;
                 numericOccurrences.get(name).put(num, count);
 
-                if(numericFeatures.get(name).get(num).containsKey(count)) {//already contains feature at this count
-                    if(printOldFeatures) System.out.printf("Index %d is already reserved for numeric feature %s with %d at %d times in %s\n", numericFeatures.get(name).get(num).get(count), name, num, count, featureName);
-                } else {//contains feature and num but different count
-                    numericFeatures.get(name).get(num).put(count, StateEncoder.indexCount++);
-                    if(printNewFeatures) System.out.printf("Numeric feature %s with %d exists but has not occurred %d times, reserving index %d for the %d occurrence of this feature in %s\n",
-                            name, num, count, StateEncoder.indexCount-1, count, featureName);
+                if (numericFeatures.get(name).get(num).containsKey(count)) { //already contains feature at this count
+                    if (printOldFeatures)
+                        System.out.printf("Index %d is already reserved for numeric feature %s with %d at %d times in %s\n", numericFeatures.get(name).get(num).get(count), name, num, count, featureName);
+                } else { //contains feature and num but different count
+                    numericFeatures.get(name).get(num).put(count, localIndexCount.getAndIncrement());
+                    if (printNewFeatures)
+                        System.out.printf("Numeric feature %s with %d exists but has not occurred %d times, reserving index %d for the %d occurrence of this feature in %s\n",
+                                name, num, count, localIndexCount.get() - 1, count, featureName);
                 }
             } else { //contains category but not this number
                 Map<Integer, Map<Integer, Integer>> map = numericFeatures.get(name);
                 Map<Integer, Integer> subMap = new HashMap<>();
-                subMap.put(1, StateEncoder.indexCount++);
+                subMap.put(1, localIndexCount.getAndIncrement());
                 map.put(num, subMap);
                 numericOccurrences.get(name).put(num, 1);
-                if(printNewFeatures) System.out.printf("Numeric feature %s exists but has not occurred with %d, reserving index %d for this feature at %d in %s\n",
-                        name, num, StateEncoder.indexCount-1, num, featureName);
+                if (printNewFeatures)
+                    System.out.printf("Numeric feature %s exists but has not occurred with %d, reserving index %d for this feature at %d in %s\n",
+                            name, num, localIndexCount.get() - 1, num, featureName);
             }
-        } else {//completely new feature category
+        } else { //completely new feature category
             TreeMap<Integer, Map<Integer, Integer>> newMap = new TreeMap<>();
             Map<Integer, Integer> subMap = new HashMap<>();
-            subMap.put(1, StateEncoder.indexCount++);
+            subMap.put(1, localIndexCount.getAndIncrement());
             newMap.put(num, subMap);
             numericFeatures.put(name, newMap);
             TreeMap<Integer, Integer> newTreeMap = new TreeMap<>();
             newTreeMap.put(num, 1);
             numericOccurrences.put(name, newTreeMap);
-            if(printNewFeatures) System.out.printf("New numeric feature %s discovered with %d in %s, reserving index %d for this feature at %d\n", name,
-                    num, featureName, StateEncoder.indexCount-1, num);
+            if (printNewFeatures)
+                System.out.printf("New numeric feature %s discovered with %d in %s, reserving index %d for this feature at %d\n", name,
+                        num, featureName, localIndexCount.get() - 1, num);
         }
-        StateEncoder.featureVector.add(numericFeatures.get(name).get(num).get(numericOccurrences.get(name).get(num)));
+        encoder.featureVector.add(numericFeatures.get(name).get(num).get(numericOccurrences.get(name).get(num)));
     }
+
     public void stateRefresh() {
         categories.clear();
         occurrences.replaceAll((k, v) -> 0);
-        for(String c : numericOccurrences.keySet()) {
+        for (String c : numericOccurrences.keySet()) {
             numericOccurrences.get(c).replaceAll((k, v) -> 0);
         }
-        for(String n : subFeatures.keySet()) {
-            for(int i : subFeatures.get(n).keySet()) {
+        for (String n : subFeatures.keySet()) {
+            for (int i : subFeatures.get(n).keySet()) {
                 subFeatures.get(n).get(i).stateRefresh();
             }
         }
@@ -213,6 +258,164 @@ public class Features  implements Serializable {
         }
     }
 
+    /**
+     * always discard f after merging
+     *
+     * @param f object to merge with
+     */
+    public synchronized void merge(Features f) {
+        if (this == f) return;
+
+        // Normal features
+        for (String n : f.features.keySet()) {
+            Map<Integer, Integer> thisOccurrenceMap = this.features.computeIfAbsent(n, k -> new HashMap<>());
+            this.occurrences.putIfAbsent(n, 0);
+            for (int i : f.features.get(n).keySet()) {
+                if (!thisOccurrenceMap.containsKey(i)) {
+                    thisOccurrenceMap.put(i, this.localIndexCount.getAndIncrement());
+                }
+            }
+        }
+
+        // Numeric features
+        for (String n : f.numericFeatures.keySet()) {
+            TreeMap<Integer, Map<Integer, Integer>> thisNumericMap = this.numericFeatures.computeIfAbsent(n, k -> new TreeMap<>());
+            this.numericOccurrences.putIfAbsent(n, new TreeMap<>());
+            for (int num : f.numericFeatures.get(n).keySet()) {
+                Map<Integer, Integer> thisOccurrenceMap = thisNumericMap.computeIfAbsent(num, k -> new HashMap<>());
+                this.numericOccurrences.get(n).putIfAbsent(num, 0);
+                for (int i  : f.numericFeatures.get(n).get(num).keySet()) {
+                    if (!thisOccurrenceMap.containsKey(i)) {
+                        thisOccurrenceMap.put(i, this.localIndexCount.getAndIncrement());
+                    }
+                }
+            }
+        }
+        //subfeatures
+        for (String n : f.subFeatures.keySet()) {
+            Map<Integer, Features> thisSubMap = this.subFeatures.computeIfAbsent(n, k -> new HashMap<>());
+            for (int i : f.subFeatures.get(n).keySet()) {
+                Features thisSubFeature = thisSubMap.computeIfAbsent(i, k -> new Features(this, n + "_" + i));
+                thisSubFeature.merge(f.subFeatures.get(n).get(i));
+            }
+        }
+        //category labels
+        for (String n : f.categoriesForChildren.keySet()) {
+            if (!this.categoriesForChildren.containsKey(n)) {
+                this.categoriesForChildren.put(n, this.getCategory(n));
+            }
+            this.categoriesForChildren.get(n).merge(f.categoriesForChildren.get(n));
+        }
+    }
+    /**
+     * Creates a synchronized, deep copy of this Features object.
+     * By being synchronized, it ensures we get a clean snapshot and never
+     * copy the object while another thread is in the middle of merging.
+     * @return A new, completely independent deep copy of this object.
+     */
+    public synchronized Features createDeepCopy() {
+        try {
+            ByteArrayOutputStream byteOutput = new ByteArrayOutputStream();
+            ObjectOutputStream objectOutput = new ObjectOutputStream(byteOutput);
+            objectOutput.writeObject(this);
+            objectOutput.close();
+
+            ByteArrayInputStream byteInput = new ByteArrayInputStream(byteOutput.toByteArray());
+            ObjectInputStream objectInput = new ObjectInputStream(byteInput);
+            Features copy = (Features) objectInput.readObject();
+            objectInput.close();
+
+            return copy;
+        } catch (IOException | ClassNotFoundException e) {
+            throw new RuntimeException("Failed to create a deep copy of the Features object.", e);
+        }
+    }
+    /**
+     * Prints the entire feature tree, hiding features on the ignore list by default.
+     */
+    public void printFeatureTree() {
+        // Default behavior: do not print ignored features.
+        printFeatureTree(false);
+    }
+
+    /**
+     * Prints the entire feature tree in a hierarchical format.
+     *
+     * @param showIgnored If true, all features will be printed. If false, features
+     * whose indices are in the ignoreList will not be printed.
+     */
+    public void printFeatureTree(boolean showIgnored) {
+        // Start the recursion, passing the root's ignoreList down the tree.
+        printTreeRecursive(this.featureName, showIgnored, this.ignoreList);
+    }
+
+    /**
+     * Helper function to recursively traverse and print the feature tree.
+     *
+     * @param prefix        The current hierarchical path of the feature.
+     * @param showIgnored   If false, features on the ignore list are skipped.
+     * @param masterIgnoreList The single ignoreList from the root object to check against.
+     */
+    private void printTreeRecursive(String prefix, boolean showIgnored, Set<Integer> masterIgnoreList) {
+        // The conditional check for printing.
+        final boolean shouldPrintAll = showIgnored;
+
+        // Print the direct "leaf" features of the current node
+        if (this.features != null) {
+            for (Map.Entry<String, Map<Integer, Integer>> featureEntry : this.features.entrySet()) {
+                String featureName = featureEntry.getKey();
+                Map<Integer, Integer> occurrenceMap = featureEntry.getValue();
+                for (Map.Entry<Integer, Integer> occurrenceEntry : occurrenceMap.entrySet()) {
+                    Integer occurrence = occurrenceEntry.getKey();
+                    Integer index = occurrenceEntry.getValue();
+                    if (shouldPrintAll || !masterIgnoreList.contains(index)) {
+                        System.out.println(prefix + "/" + featureName + "/" + occurrence + "=>" + index);
+                    }
+                }
+            }
+        }
+
+        // Print the direct numeric "leaf" features of the current node
+        if (this.numericFeatures != null) {
+            for (Map.Entry<String, TreeMap<Integer, Map<Integer, Integer>>> numericEntry : this.numericFeatures.entrySet()) {
+                String featureName = numericEntry.getKey();
+                for (Map.Entry<Integer, Map<Integer, Integer>> valueEntry : numericEntry.getValue().entrySet()) {
+                    int numValue = valueEntry.getKey();
+                    for (Map.Entry<Integer, Integer> occurrenceEntry : valueEntry.getValue().entrySet()) {
+                        Integer occurrence = occurrenceEntry.getKey();
+                        Integer index = occurrenceEntry.getValue();
+                        if (shouldPrintAll || !masterIgnoreList.contains(index)) {
+                            System.out.println(prefix + "/" + featureName + "_val" + numValue + "/" + occurrence + "=>" + index);
+                        }
+                    }
+                }
+            }
+        }
+
+        // Recurse into sub-features, passing the master list along
+        if (this.subFeatures != null) {
+            for (Map.Entry<String, Map<Integer, Features>> subEntry : this.subFeatures.entrySet()) {
+                String subFeatureName = subEntry.getKey();
+                Map<Integer, Features> occurrenceMap = subEntry.getValue();
+                for (Map.Entry<Integer, Features> occurrenceEntry : occurrenceMap.entrySet()) {
+                    Integer occurrence = occurrenceEntry.getKey();
+                    Features subFeatureInstance = occurrenceEntry.getValue();
+                    String newPrefix = prefix + "/" + subFeatureName + "/" + occurrence;
+                    subFeatureInstance.printTreeRecursive(newPrefix, showIgnored, masterIgnoreList);
+                }
+            }
+        }
+
+        // Recurse into categories, passing the master list along
+        if (this.categoriesForChildren != null) {
+            for (Map.Entry<String, Features> categoryEntry : this.categoriesForChildren.entrySet()) {
+                String categoryName = categoryEntry.getKey();
+                Features categoryFeature = categoryEntry.getValue();
+                String newPrefix = prefix + "/" + categoryName;
+                categoryFeature.printTreeRecursive(newPrefix, showIgnored, masterIgnoreList);
+            }
+        }
+    }
     // Helper method to persist the Features mapping to a file
     public void saveMapping(String filename) throws IOException {
         try (ObjectOutputStream oos = new ObjectOutputStream(Files.newOutputStream(Paths.get(filename)))) {
@@ -226,4 +429,4 @@ public class Features  implements Serializable {
             return (Features) ois.readObject();
         }
     }
-}
+}
\ No newline at end of file
diff --git a/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/LabeledState.java b/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/LabeledState.java
index 064de3b8fe..1a89d5a66b 100644
--- a/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/LabeledState.java
+++ b/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/LabeledState.java
@@ -19,6 +19,7 @@ public class LabeledState implements Serializable {
     /** Value label (e.g., -1.0 for loss, +1.0 for win). */
     public final double resultLabel;
 
+
     /**
      * Construct a labeled state.
      * @param stateIndices  indices of active features
@@ -36,6 +37,10 @@ public class LabeledState implements Serializable {
     public void compress(StateEncoder encoder) {
         stateVector = encoder.getCompressedVectorArray(stateVector);
     }
+    public void compress(Set<Integer> ignoreList) {
+        stateVector = FeatureMerger.getCompressedVectorArray(ignoreList, stateVector);
+    }
+
     /**
      * Persist this labeled state to the given DataOutputStream.
      * Caller must write header (record count, S, wordsPerState) before calling.
@@ -43,8 +48,9 @@ public class LabeledState implements Serializable {
      * @throws IOException   on I/O error
      */
     public void persist(DataOutputStream out) throws IOException {
-        // Convert the BitSet to an array of active indices
-
+//        for (int j : stateVector) {
+//            if (j >= maxIndex) return; //dont persist a state with unfinalized features
+//        }
         // 1) Write the NUMBER of active indices first.
         out.writeInt(stateVector.length);
 
@@ -60,4 +66,25 @@ public class LabeledState implements Serializable {
         // 4) Write result label
         out.writeDouble(resultLabel);
     }
+    public void persist(DataOutputStream out, int mIndex) throws IOException {
+        // Convert the BitSet to an array of active indices
+        int count = 0;
+        for(int index : stateVector) {
+            if(index < mIndex) count++;
+        }
+        // 1) Write the NUMBER of active indices first.
+        out.writeInt(count);
+
+        // 2) Write only the active indices themselves.
+        for (int index : stateVector) {
+            if(index < mIndex) out.writeInt(index);
+        }
+        // --- The rest of the method remains the same ---
+        // 3) Write your action-distribution vector
+        for (double p : actionVector) {
+            out.writeDouble(p);
+        }
+        // 4) Write result label
+        out.writeDouble(resultLabel);
+    }
 }
diff --git a/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/StateEncoder.java b/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/StateEncoder.java
index 9a655372a0..31de2e0c32 100644
--- a/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/StateEncoder.java
+++ b/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/StateEncoder.java
@@ -1,6 +1,5 @@
 package mage.player.ai;
 
-import com.j256.ormlite.stmt.query.In;
 import mage.MageObject;
 import mage.abilities.*;
 import mage.abilities.costs.Cost;
@@ -8,7 +7,6 @@ import mage.abilities.costs.Costs;
 import mage.abilities.costs.mana.ManaCost;
 import mage.abilities.costs.mana.ManaCosts;
 import mage.abilities.effects.Effect;
-import mage.abilities.mana.ManaOptions;
 import mage.cards.Card;
 import mage.cards.Cards;
 import mage.constants.CardType;
@@ -31,21 +29,20 @@ import java.util.*;
 /**
  * Deck specific state encoder for reinforcement learning.
  * Before vectors can be made, the encoder must learn all game features of
- * the given 60 card decks through a first pass of 1,000 simulated mcst games
+ * the given 60 card decks through a first pass of 1,000 simulated mcst and minimax games
  */
 public class StateEncoder {
     public static int indexCount;
-    public static int reducedIndexCount;
     private Features features;
-    public static Set<Integer> featureVector = new HashSet<>();
-    public UUID opponentID;
-    public UUID myPlayerID;
+    public Set<Integer> featureVector = new HashSet<>();
+    private UUID opponentID;
+    private UUID myPlayerID;
     public List<Set<Integer>> macroStateVectors = new ArrayList<>();
     public List<Set<Integer>> microStateVectors = new ArrayList<>();
-    public Map<Integer, Integer> rawToReduced = new HashMap<>();
     public List<Boolean> activeStates = new ArrayList<>();
 
     public List<Double> stateScores = new ArrayList<>();
+    public List<double[]> actionVectors = new ArrayList<>();
     public int initialRawSize = 0;//original max index
     public int mappingVersion = 0;
 
@@ -53,9 +50,9 @@ public class StateEncoder {
 
     public StateEncoder() {
         //using statics for convenience for now
-        indexCount = 0;
-        reducedIndexCount = 1;
+        //indexCount = 0;
         features = new Features();
+        features.setEncoder(this);
         ignoreList = new HashSet<>();
     }
     public void setAgent(UUID me) {
@@ -64,8 +61,12 @@ public class StateEncoder {
     public void setOpponent(UUID op) {
         opponentID = op;
     }
+    public Features getFeatures() {return features;}
+    public synchronized UUID getMyPlayerID() {return myPlayerID;}
+    public synchronized void addAction(double[] actionVec) { actionVectors.add(actionVec); }
 
     public void processManaCosts(ManaCosts<ManaCost> manaCost, Game game, Features f, Boolean callParent) {
+        if(f == null) return;
         //f.addFeature(manaCost.getText());
         f.addNumericFeature("ManaValue", manaCost.manaValue(), callParent);
         for(ManaCost mc : manaCost) {
@@ -81,6 +82,7 @@ public class StateEncoder {
         }
     }
     public void processAbility(Ability a, Game game, Features f) {
+        if(f == null) return;
         Costs<Cost> c = a.getCosts();
         //for now lets not worry about encoding costs per abilities
         /*ManaCosts<ManaCost> mcs = a.getManaCostsToPay();
@@ -90,16 +92,18 @@ public class StateEncoder {
         }*/
         for(Mode m : a.getModes().getAvailableModes(a, game)) {
             for(Effect e : m.getEffects()) {
-                f.addFeature(e.getText(m));
+                f.parent.addFeature(e.getText(m));//only add feature for abstraction (isn't dynamic)
             }
         }
     }
     public void processActivatedAbility(ActivatedAbility aa, Game game, Features f) {
+        if(f == null) return;
         processAbility(aa, game, f);
 
         if(aa.canActivate(myPlayerID, game).canActivate()) f.addFeature("CanActivate"); //use aa.canActivate()
     }
     public void processTriggeredAbility(TriggeredAbility ta, Game game, Features f) {
+        if(f == null) return;
         processAbility(ta, game, f);
 
         if(!ta.checkTriggeredLimit(game)) f.addFeature("ReachedTriggerLimit"); //use ta.checkTriggeredLimit()
@@ -108,7 +112,7 @@ public class StateEncoder {
 
     }
     public void processCard(Card c, Game game, Features f) {
-
+        if(f == null) return;
         f.parent.addFeature("Card");//raw universal type of card added for counting purposes
 
         if(c.isPermanent()) f.addCategory("Permanent");
@@ -118,7 +122,7 @@ public class StateEncoder {
         }
         //add subtypes
         for (SubType st : c.getSubtype(game)) {
-            f.addCategory(st.name());
+            if(!st.name().isEmpty()) f.addCategory(st.name());
         }
         //add color
         if(c.getColor(game).isRed()) f.addCategory("RedCard");
@@ -148,6 +152,7 @@ public class StateEncoder {
 
     }
     public void processPermBattlefield(Permanent p, Game game, Features f) {
+        if(f == null) return;
         processCard(p, game, f);
         //is tapped?
         if(p.isTapped()) f.addFeature("Tapped");
@@ -182,11 +187,12 @@ public class StateEncoder {
         }
         if(p.isCreature(game)) {
             if(p.canAttack(opponentID, game)) f.addFeature("CanAttack"); //use p.canAttack()
-            if(p.canBlock(opponentID, game)) f.addFeature("CanBlock");
+            if(p.canBlockAny(game)) f.addFeature("CanBlock");
             f.addNumericFeature("Damage", p.getDamage());
         }
     }
     public void processCardInGraveyard(Card c, Game game, Features f) {
+        if(f == null) return;
         //process as card
         processCard(c, game, f);
         //process abilities in gy
@@ -208,6 +214,7 @@ public class StateEncoder {
 
     }
     public void processCardInHand(Card c, Game game, Features f) {
+        if(f == null) return;
         //process as card
         processCard(c, game, f);
         //process abilities in hand
@@ -230,24 +237,28 @@ public class StateEncoder {
         }
     }
     public void processBattlefield(Battlefield bf, Game game, Features f, UUID playerID) {
+        if(f == null) return;
         for (Permanent p : bf.getAllActivePermanents(playerID)) {
             Features permFeatures = f.getSubFeatures(p.getName());
             processPermBattlefield(p, game, permFeatures);
         }
     }
     public void processGraveyard(Graveyard gy, Game game, Features f) {
+        if(f == null) return;
         for (Card c : gy.getCards(game)) {
             Features graveCardFeatures = f.getSubFeatures(c.getName());
             processCardInGraveyard(c, game, graveCardFeatures);
         }
     }
     public void processHand(Cards hand, Game game, Features f) {
+        if(f == null) return;
         for (Card c : hand.getCards(game)) {
             Features handCardFeatures = f.getSubFeatures(c.getName());
             processCardInHand(c, game, handCardFeatures);
         }
     }
     public void processStackObject(StackObject so, int stackPosition, Game game, Features f) {
+        if(f == null) return;
         f.addNumericFeature("StackPosition", stackPosition, false);
         if(so.getControllerId()==myPlayerID) f.addFeature("isController");
         Ability sa = so.getStackAbility();
@@ -264,6 +275,7 @@ public class StateEncoder {
         }
     }
     public void processStack(SpellStack stack, Game game, Features f) {
+        if(f == null) return;
         Iterator<StackObject> itr = stack.descendingIterator();
         StackObject so;
         f.addNumericFeature("StackSize", stack.size());
@@ -275,8 +287,23 @@ public class StateEncoder {
             processStackObject(so, i, game, soFeatures);
         }
     }
-    public void processOpponentState(Game game) {
-        Player myPlayer = game.getPlayer(opponentID);
+    public void processManaPool(ManaPool mp, Game game,  Features f) {
+        if(f == null) return;
+        f.addNumericFeature("GreenMana", mp.getGreen());
+        f.addNumericFeature("RedMana", mp.getRed());
+        f.addNumericFeature("BlueMana", mp.getBlue());
+        f.addNumericFeature("WhiteMana", mp.getWhite());
+        f.addNumericFeature("BlackMana", mp.getBlack());
+        f.addNumericFeature("ColorlessMana", mp.getColorless());
+        //TODO: deal with conditional mana
+    }
+    public void processOpponentState(Game game, UUID activePlayerID) {
+        //switch for perspective reasons
+        UUID temp = myPlayerID;
+        myPlayerID = opponentID;
+        opponentID = temp;
+
+        Player myPlayer = game.getPlayer(myPlayerID);
         //game metadata
         features.addNumericFeature("OpponentLifeTotal", myPlayer.getLife());
         if(myPlayer.canPlayLand()) features.addFeature("OpponentCanPlayLand"); //use features.addFeature(myPlayer.canPlayLand())
@@ -287,7 +314,7 @@ public class StateEncoder {
         //start with battlefield
         Battlefield bf = game.getBattlefield();
         Features bfFeatures = features.getSubFeatures("OpponentBattlefield");
-        processBattlefield(bf, game, bfFeatures, opponentID);
+        processBattlefield(bf, game, bfFeatures, myPlayerID);
 
         //now do graveyard
         Graveyard gy = myPlayer.getGraveyard();
@@ -296,7 +323,7 @@ public class StateEncoder {
 
         //now do hand (cards are face down so only keep count of number of cards
         // TODO: keep track of face up cards and exile
-        if(opponentID==game.getPriorityPlayerId()) { //invert perspective
+        if(myPlayerID==activePlayerID) { //invert perspective
             Cards hand = myPlayer.getHand();
             Features handFeatures = features.getSubFeatures("Hand");
             processHand(hand, game, handFeatures);
@@ -304,57 +331,21 @@ public class StateEncoder {
             Cards hand = myPlayer.getHand();
             features.addNumericFeature("OpponentCardsInHand", hand.size());
         }
+        //switch back
+        opponentID = myPlayerID;
+        myPlayerID = temp;
 
     }
-    public void processManaPool(ManaPool mp, Game game,  Features f) {
-        f.addNumericFeature("GreenMana", mp.getGreen());
-        f.addNumericFeature("RedMana", mp.getRed());
-        f.addNumericFeature("BlueMana", mp.getBlue());
-        f.addNumericFeature("WhiteMana", mp.getWhite());
-        f.addNumericFeature("BlackMana", mp.getBlack());
-        f.addNumericFeature("ColorlessMana", mp.getColorless());
-        //TODO: deal with conditional mana
-    }
-    public void processPhase(Game game) {
-        switch (game.getTurnStepType()) {
-            case UPKEEP:
-                features.addFeature("Upkeep");
-            case DRAW:
-                features.addFeature("Draw");
-            case PRECOMBAT_MAIN:
-                features.addFeature("PreCombatMain");
-            case BEGIN_COMBAT:
-                features.addFeature("BeginCombat");
-            case DECLARE_ATTACKERS:
-                features.addFeature("DeclareAttackers");
-            case DECLARE_BLOCKERS:
-                features.addFeature("DeclareBlockers");
-            case FIRST_COMBAT_DAMAGE:
-                features.addFeature("FirstCombatDamage");
-            case COMBAT_DAMAGE:
-                features.addFeature("CombatDamage");
-            case END_COMBAT:
-                features.addFeature("EndCombat");
-            case POSTCOMBAT_MAIN:
-                features.addFeature("PostCombatMain");
-            case END_TURN:
-                features.addFeature("EndTurn");
-            case CLEANUP:
-               features.addFeature("Cleanup");
-        }
-    }
-    public synchronized void processState(Game game) {
+    public synchronized void processState(Game game, UUID actingPlayerID) {
         features.stateRefresh();
         featureVector.clear();
 
         Player myPlayer = game.getPlayer(myPlayerID);
 
         //game metadata
-        features.addFeature(game.getPhase().getType().name());
+        features.addFeature(game.getTurnStepType().toString()); //phases
         if(game.isActivePlayer(myPlayerID)) features.addFeature("IsActivePlayer");
-        if(game.getPriorityPlayerId()==myPlayerID) features.addFeature("IsPriorityPlayer");
-        //TODO: *IMPORTANT* ADD PHASE INFO
-        processPhase(game);
+        if(actingPlayerID==myPlayerID) features.addFeature("IsActingPlayer");
         features.addNumericFeature("LifeTotal", myPlayer.getLife());
         if(myPlayer.canPlayLand()) features.addFeature("CanPlayLand"); //use features.addFeature(myPlayer.canPlayLand())
 
@@ -377,32 +368,30 @@ public class StateEncoder {
         processGraveyard(gy, game, gyFeatures);
 
         //now do hand
-        if(opponentID==game.getPriorityPlayerId()) { //invert perspective
-            Cards hand = myPlayer.getHand();
-            features.addNumericFeature("OpponentCardsInHand", hand.size());
-        } else {
+        if(myPlayerID==actingPlayerID) { //keep perspective
             Cards hand = myPlayer.getHand();
             Features handFeatures = features.getSubFeatures("Hand");
             processHand(hand, game, handFeatures);
+        } else {
+            assert (false);
+            Cards hand = myPlayer.getHand();
+            features.addNumericFeature("OpponentCardsInHand", hand.size());
         }
         //TODO: add exile
 
         //lastly do opponent
-        processOpponentState(game);
+        processOpponentState(game, actingPlayerID);
 
         //mapping version
-        features.addNumericFeature("Mapping Version", mappingVersion);
+        features.addNumericFeature("Mapping Version", features.version);
 
-        //update reduced vector
-        //updateReducedVector();
-        //stateVectors.add(Arrays.copyOf(featureVector, 30000));
     }
-    public void processMicroState(Game game) {
-        processState(game);
+    public void processMicroState(Game game, UUID actingPlayerID) {
+        processState(game, actingPlayerID);
         microStateVectors.add(new HashSet<>(featureVector));
     }
-    public void processMacroState(Game game) {
-        processState(game);
+    public synchronized void processMacroState(Game game, UUID actingPlayerID) {
+        processState(game, actingPlayerID);
         macroStateVectors.add(new HashSet<>(featureVector));
         //activeStates.add(game.getActivePlayerId() == myPlayerID);
     }
@@ -423,7 +412,6 @@ public class StateEncoder {
         }
 
         // Convert the Set<Integer> to an int[]
-
         return filteredIndicesSet.stream()
                 .mapToInt(Integer::intValue)
                 .toArray();
@@ -445,9 +433,8 @@ public class StateEncoder {
     }
     // Persist the persistent feature mapping
     public void persistMapping(String filename) throws IOException {
-        features.globalIndexCount = indexCount;
-        features.ignoreList = new HashSet<>(ignoreList);
-        features.rawToReduced = new HashMap<>(rawToReduced);
+        //features.localIndexCount = indexCount;
+        //features.ignoreList = new HashSet<>(ignoreList);
         features.version = mappingVersion;
         features.saveMapping(filename);
     }
@@ -455,10 +442,16 @@ public class StateEncoder {
     // Load the feature mapping from file
     public void loadMapping(String filename) throws IOException, ClassNotFoundException {
         features = Features.loadMapping(filename);
-        indexCount = features.globalIndexCount;
-        ignoreList = new HashSet<>(features.ignoreList);
-        rawToReduced = new HashMap<>(features.rawToReduced);
-        mappingVersion = features.version+1;
-        initialRawSize = indexCount;
+        features.setEncoder(this);
+        //indexCount = features.localIndexCount;
+        //ignoreList = new HashSet<>(features.ignoreList);
+        //mappingVersion = features.version;
+        //initialRawSize = indexCount;
+    }
+    // Load the feature mapping from object
+    public void loadMapping(Features f) {
+        features = f.createDeepCopy();
+        features.setEncoder(this);
+
     }
 }
diff --git a/Mage.Tests/src/test/java/org/mage/test/AI/RL/GenerateMappings.java b/Mage.Tests/src/test/java/org/mage/test/AI/RL/GenerateMappings.java
index 9b7131649e..861bac7b8f 100644
--- a/Mage.Tests/src/test/java/org/mage/test/AI/RL/GenerateMappings.java
+++ b/Mage.Tests/src/test/java/org/mage/test/AI/RL/GenerateMappings.java
@@ -62,10 +62,6 @@ public class GenerateMappings extends MinimaxVectorExtractionTests {
         System.out.printf("IGNORE LIST SIZE: %d\n", encoder.ignoreList.size());
         System.out.printf("REDUCED VECTOR SIZE: %d\n", StateEncoder.indexCount - encoder.ignoreList.size());
         System.out.print("RAW TO REDUCED MAPPING: ");
-        for(int i : encoder.rawToReduced.keySet()) {
-            if(i < encoder.rawToReduced.get(i)) System.out.println("-here-");
-            System.out.printf("[%d => %d]", i, encoder.rawToReduced.get(i));
-        }
         System.out.println();
         System.out.println(encoder.ignoreList.toString());
     }
diff --git a/Mage.Tests/src/test/java/org/mage/test/AI/RL/MinimaxVectorExtractionTests.java b/Mage.Tests/src/test/java/org/mage/test/AI/RL/MinimaxVectorExtractionTests.java
index ebf62bc545..465f878a76 100644
--- a/Mage.Tests/src/test/java/org/mage/test/AI/RL/MinimaxVectorExtractionTests.java
+++ b/Mage.Tests/src/test/java/org/mage/test/AI/RL/MinimaxVectorExtractionTests.java
@@ -22,6 +22,8 @@ import java.nio.file.Files;
 import java.nio.file.Paths;
 import java.util.*;
 
+import static java.lang.Integer.min;
+
 public class MinimaxVectorExtractionTests extends CardTestPlayerBaseAI {
     private String deckNameA = "UWTempo.dck"; //simplegreen, UWTempo
     private String deckNameB = "simplegreen.dck";
@@ -60,8 +62,8 @@ public class MinimaxVectorExtractionTests extends CardTestPlayerBaseAI {
                 testPlayer.setAIPlayer(true); // enable full AI support (game simulations) for all turns by default
                 return testPlayer;
             } else {
-                TestComputerPlayer8 t8 = new TestComputerPlayer8(name, RangeOfInfluence.ONE, getSkillLevel());
-                TestPlayer testPlayer = new TestPlayer(t8);
+                TestComputerPlayer7 t7 = new TestComputerPlayer7(name, RangeOfInfluence.ONE, getSkillLevel());
+                TestPlayer testPlayer = new TestPlayer(t7);
                 testPlayer.setAIPlayer(true); // enable full AI support (game simulations) for all turns by default
                 return testPlayer;
             }
@@ -111,7 +113,7 @@ public class MinimaxVectorExtractionTests extends CardTestPlayerBaseAI {
     }
     public void set_encoder() {
         ComputerPlayer8 c8 = (ComputerPlayer8)playerA.getComputerPlayer(); c8.setEncoder(encoder);
-        c8 = (ComputerPlayer8)playerB.getComputerPlayer(); c8.setEncoder(encoder);
+        //c8 = (ComputerPlayer8)playerB.getComputerPlayer(); c8.setEncoder(encoder);
         encoder.setAgent(playerA.getId());
         encoder.setOpponent(playerB.getId());
     }
@@ -129,8 +131,7 @@ public class MinimaxVectorExtractionTests extends CardTestPlayerBaseAI {
     public void reset_vectors() {
         encoder.macroStateVectors.clear();
         encoder.stateScores.clear();
-        encoder.activeStates.clear();
-        ActionEncoder.actionVectors.clear();
+        encoder.actionVectors.clear();
     }
 
     /**
@@ -144,7 +145,7 @@ public class MinimaxVectorExtractionTests extends CardTestPlayerBaseAI {
         labeledStateBatch.clear();
         for(int i = 0; i < N; i++) {
             Set<Integer> state = encoder.macroStateVectors.get(i);
-            double[] action = ActionEncoder.actionVectors.get(i);
+            double[] action = encoder.actionVectors.get(i);
             double normScore = encoder.stateScores.get(i);
 
             boolean win = playerA.hasWon();
@@ -160,7 +161,7 @@ public class MinimaxVectorExtractionTests extends CardTestPlayerBaseAI {
     public void print_labeled_states() {
         for (LabeledState ls : labeledStates) {
             StringBuilder sb1 = new StringBuilder();
-            for (int i = 0; i < 100; i++) {
+            for (int i = 0; i < min(100, ls.stateVector.length); i++) {
                 sb1.append(ls.stateVector[i]);
                 sb1.append(" ");
             }
@@ -202,13 +203,13 @@ public class MinimaxVectorExtractionTests extends CardTestPlayerBaseAI {
      */
     public void compress_labeled_states() {
         for (LabeledState ls : labeledStates) {
-            ls.compress(encoder);
+            ls.compress(encoder.getFeatures().ignoreList);
         }
     }
     @Test
     public void print_current_ignore_list() {
-        System.out.printf("IGNORE LIST SIZE: %d\n", encoder.ignoreList.size());
-        System.out.printf("REDUCED VECTOR SIZE: %d\n", StateEncoder.indexCount - encoder.ignoreList.size());
+        System.out.printf("IGNORE LIST SIZE: %d\n", encoder.getFeatures().ignoreList.size());
+        System.out.printf("REDUCED VECTOR SIZE: %d\n", encoder.getFeatures().localIndexCount.get() - encoder.getFeatures().ignoreList.size());
     }
     @Test
     public void make_ignore_X_50() {
@@ -221,15 +222,15 @@ public class MinimaxVectorExtractionTests extends CardTestPlayerBaseAI {
             reset_game();
             System.out.printf("GAME #%d RESET... NEW GAME STARTING\n", i+1);
         }
-        //assert(!encoder.ignoreList.isEmpty());
+        //assert(!encoder.getFeatures().ignoreList.isEmpty());
         Set<Integer> newIgnore = new HashSet<>(FeatureMerger.computeIgnoreList(encoder.macroStateVectors));
-        Set<Integer> oldIgnore = new HashSet<>(encoder.ignoreList);
-        encoder.ignoreList = combine_ignore_lists(oldIgnore, newIgnore);
+        Set<Integer> oldIgnore = new HashSet<>(encoder.getFeatures().ignoreList);
+        encoder.getFeatures().ignoreList = combine_ignore_lists(oldIgnore, newIgnore);
         //actions = new HashMap<>(ActionEncoder.actionMap);
         persistData();
-        System.out.printf("IGNORE LIST SIZE: %d\n", encoder.ignoreList.size());
-        System.out.printf("REDUCED VECTOR SIZE: %d\n", StateEncoder.indexCount - encoder.ignoreList.size());
-        //encoder.ignoreList = new HashSet<>(ignore);
+        System.out.printf("IGNORE LIST SIZE: %d\n", encoder.getFeatures().ignoreList.size());
+        System.out.printf("REDUCED VECTOR SIZE: %d\n", encoder.getFeatures().localIndexCount.get() - encoder.getFeatures().ignoreList.size());
+        //encoder.getFeatures().ignoreList = new HashSet<>(ignore);
 
     }
     /**
@@ -249,16 +250,15 @@ public class MinimaxVectorExtractionTests extends CardTestPlayerBaseAI {
             reset_game();
             System.out.printf("GAME #%d RESET... NEW GAME STARTING\n", i+1);
         }
-        Set<Integer> newIgnore = new HashSet<>(FeatureMerger.computeIgnoreListFromLS(labeledStates));
-        Set<Integer> oldIgnore = new HashSet<>(encoder.ignoreList);
-        encoder.ignoreList = combine_ignore_lists(oldIgnore, newIgnore);
+        //Set<Integer> oldIgnore = new HashSet<>(encoder.getFeatures().ignoreList);
+        encoder.getFeatures().ignoreList = new HashSet<>(FeatureMerger.computeIgnoreListFromLS(labeledStates, 0, encoder.getFeatures().localIndexCount.get()));
         compress_labeled_states();
 
         print_labeled_states();
         persistLabeledStates(TRAIN_OUT_FILE);
         persistData();
-        System.out.printf("IGNORE LIST SIZE: %d\n", encoder.ignoreList.size());
-        System.out.printf("REDUCED VECTOR SIZE: %d\n", StateEncoder.indexCount - encoder.ignoreList.size());
+        System.out.printf("IGNORE LIST SIZE: %d\n", encoder.getFeatures().ignoreList.size());
+        System.out.printf("REDUCED VECTOR SIZE: %d\n", encoder.getFeatures().localIndexCount.get() - encoder.getFeatures().ignoreList.size());
     }
 
     /**
@@ -273,26 +273,26 @@ public class MinimaxVectorExtractionTests extends CardTestPlayerBaseAI {
             setStopAt(maxTurn, PhaseStep.END_TURN);
             execute();
             create_labeled_states();
-            Collections.shuffle(labeledStateBatch);
-            labeledStates.addAll(labeledStateBatch.subList(0, 5));
+            //Collections.shuffle(labeledStateBatch);
+            labeledStates.addAll(labeledStateBatch);
             labeledStateBatch.clear();
             reset_game();
             System.out.printf("GAME #%d RESET... NEW GAME STARTING\n", i+1);
         }
-        Set<Integer> newIgnore = new HashSet<>(FeatureMerger.computeIgnoreListFromLS(labeledStates));
-        Set<Integer> oldIgnore = new HashSet<>(encoder.ignoreList);
-        encoder.ignoreList = combine_ignore_lists(oldIgnore, newIgnore);
+//        Set<Integer> newIgnore = new HashSet<>(FeatureMerger.computeIgnoreListFromLS(labeledStates));
+//        Set<Integer> oldIgnore = new HashSet<>(encoder.getFeatures().ignoreList);
+//        encoder.getFeatures().ignoreList = combine_ignore_lists(oldIgnore, newIgnore);
         compress_labeled_states();
 
         print_labeled_states();
         persistLabeledStates(TEST_OUT_FILE);
         persistData();
-        System.out.printf("IGNORE LIST SIZE: %d\n", encoder.ignoreList.size());
-        System.out.printf("REDUCED VECTOR SIZE: %d\n", StateEncoder.indexCount - encoder.ignoreList.size());
+        System.out.printf("IGNORE LIST SIZE: %d\n", encoder.getFeatures().ignoreList.size());
+        System.out.printf("REDUCED VECTOR SIZE: %d\n", encoder.getFeatures().localIndexCount.get() - encoder.getFeatures().ignoreList.size());
     }
     @After
     public void print_vector_size() {
-        System.out.printf("RAW VECTOR SIZE: %d\n", StateEncoder.indexCount);
+        System.out.printf("RAW VECTOR SIZE: %d\n", encoder.getFeatures().localIndexCount.get());
         System.out.printf("FINAL ACTION VECTOR SIZE: %d\n", ActionEncoder.indexCount);
         for(String s : ActionEncoder.actionMap.keySet()) {
             System.out.printf("[%s => %d] ", s, ActionEncoder.actionMap.get(s));
@@ -307,7 +307,7 @@ public class MinimaxVectorExtractionTests extends CardTestPlayerBaseAI {
 
             // 'S' now represents the TOTAL size of your global feature vocabulary.
             // The constant should be updated to reflect this.
-            int S = StateEncoder.indexCount;
+            int S = encoder.getFeatures().localIndexCount.get();
 
             // 'A' is still the size of the policy vector.
             int A = 128;
diff --git a/Mage.Tests/src/test/java/org/mage/test/AI/RL/ParallelDataGenerator.java b/Mage.Tests/src/test/java/org/mage/test/AI/RL/ParallelDataGenerator.java
index 378d5a393f..121f7a1fc7 100644
--- a/Mage.Tests/src/test/java/org/mage/test/AI/RL/ParallelDataGenerator.java
+++ b/Mage.Tests/src/test/java/org/mage/test/AI/RL/ParallelDataGenerator.java
@@ -11,8 +11,8 @@ import mage.game.mulligan.MulliganType;
 import mage.player.ai.*;
 import mage.util.RandomUtil;
 import org.junit.Test;
+import org.mage.test.player.TestComputerPlayer7;
 import org.mage.test.player.TestComputerPlayer8;
-import org.mage.test.player.TestComputerPlayerMonteCarlo2;
 import org.mage.test.player.TestPlayer;
 import org.mage.test.serverside.base.CardTestPlayerBaseAI;
 
@@ -25,14 +25,14 @@ import java.util.concurrent.*;
  * This version is fully compatible with Java 1.8 and uses the correct, thread-safe
  * game execution logic as defined by the test framework.
  */
-public class ParallelMinimaxDataGenerator extends CardTestPlayerBaseAI {
+public class ParallelDataGenerator extends CardTestPlayerBaseAI {
 
     //region Configuration
     // ============================ DATA GENERATION SETTINGS ============================
-    private static final int NUM_GAMES_TO_SIMULATE_TRAIN = 4;
-    private static final int NUM_GAMES_TO_SIMULATE_TEST = 80;
+    private static final int NUM_GAMES_TO_SIMULATE_TRAIN = 250;
+    private static final int NUM_GAMES_TO_SIMULATE_TEST = 50;
     private static final int MAX_GAME_TURNS = 50;
-    private static final int MAX_CONCURRENT_GAMES = 4;
+    private static final int MAX_CONCURRENT_GAMES = 8;
 
     // =============================== DECK AND AI SETTINGS ===============================
     private static final String DECK_A = "UWTempo.dck";
@@ -45,10 +45,12 @@ public class ParallelMinimaxDataGenerator extends CardTestPlayerBaseAI {
     private static final String ACTIONS_FILE = "actions_mapping.ser";
     private static final String TRAIN_OUT_FILE = "training.bin";
     private static final String TEST_OUT_FILE = "testing.bin";
-    // ================================== global fields ==================================
+    // ================================== GLOBAL FIELDS ==================================
     private Features finalFeatures;
     private int initialRawSize;
+    private int previousRawSize;
     //end region
+
     /**
      * A simple class to hold the results of a single game, compatible with Java 1.8.
      */
@@ -70,33 +72,64 @@ public class ParallelMinimaxDataGenerator extends CardTestPlayerBaseAI {
         }
     }
 
+    @Test
+    public void print_mappings() {
+        //load base mapping
+        try {
+            finalFeatures = Features.loadMapping(MAPPING_FILE);
+            ActionEncoder.actionMap = (Map<String, Integer>) loadObject(ACTIONS_FILE);
+        } catch (IOException | ClassNotFoundException e) {
+            System.err.println("failed to load persistent mappings.");
+        }
+        finalFeatures.printFeatureTree(false);
+        System.out.println("Ignore list size: " + finalFeatures.ignoreList.size());
+        System.out.println("Ignore list:");
+        System.out.println(finalFeatures.ignoreList.toString());
+        System.out.println("Action map:");
+        String[] aMap = new String[ActionEncoder.actionMap.size()];
+        for (String s : ActionEncoder.actionMap.keySet()) {
+            //System.out.printf("[%s => %d] ", s, ActionEncoder.actionMap.get(s));
+            aMap[ActionEncoder.actionMap.get(s)] = s;
+        }
+        for (int i = 0; i < aMap.length; i++) {
+            System.out.println(i + " => " + aMap[i]);
+        }
+    }
+
     @Test
     public void generateTrainingAndTestingData() {
-        System.out.println("=========================================");
-        System.out.println("   STARTING TRAINING DATA GENERATION     ");
-        System.out.println("=========================================");
-        Features.printOldFeatures = false;
-        //Features.printNewFeatures = false;
+
         //load original mapping as starting point
         finalFeatures = new Features();
         initialRawSize = 0;
+        previousRawSize = 0;
+        //load base mapping
         try {
             finalFeatures = Features.loadMapping(MAPPING_FILE);
             initialRawSize = finalFeatures.localIndexCount.get();
+            previousRawSize = finalFeatures.previousLocalIndexCount;
         } catch (IOException | ClassNotFoundException e) {
             System.err.println("failed to load persistent mappings.");
         }
+        Features.printOldFeatures = false;
+        //Features.printNewFeatures = false;
 
-        List<LabeledState> trainingStates = runSimulations(NUM_GAMES_TO_SIMULATE_TRAIN);
-        processAndSaveData(trainingStates, TRAIN_OUT_FILE);
-        //just train for now
-        /*
         System.out.println("\n=========================================");
         System.out.println("    STARTING TESTING DATA GENERATION     ");
         System.out.println("=========================================");
+
         List<LabeledState> testingStates = runSimulations(NUM_GAMES_TO_SIMULATE_TEST);
-        processAndSaveData(testingStates, TEST_OUT_FILE);
-        */
+
+        System.out.println("=========================================");
+        System.out.println("   STARTING TRAINING DATA GENERATION     ");
+        System.out.println("=========================================");
+
+
+        List<LabeledState> trainingStates = runSimulations(NUM_GAMES_TO_SIMULATE_TRAIN);
+
+        //save both data files at once
+        processAndSaveData(trainingStates, testingStates);
+
         System.out.println("\nData generation complete.");
     }
 
@@ -118,25 +151,42 @@ public class ParallelMinimaxDataGenerator extends CardTestPlayerBaseAI {
 
         List<LabeledState> allLabeledStates = new ArrayList<>();
         int wins = 0;
+        int successfulGames = 0;
+        int failedGames = 0;
         try {
             List<Future<GameResult>> futures = executor.invokeAll(tasks);
             executor.shutdown();
 
             for (Future<GameResult> future : futures) {
-                GameResult result = future.get();
-                allLabeledStates.addAll(result.getStates());
-                if (result.didPlayerAWin()) {
-                    wins++;
+                try {
+                    // future.get() will block until the task is complete.
+                    GameResult result = future.get();
+                    allLabeledStates.addAll(result.getStates());
+                    if (result.didPlayerAWin()) {
+                        wins++;
+                    }
+                    successfulGames++;
+
+                } catch (ExecutionException e) {
+                    failedGames++;
+                    System.err.println("A game simulation failed and its result will be ignored. Cause: " + e.getCause());
+                    e.getCause().printStackTrace();
                 }
+                // The loop continues to the next future, ignoring the failed one.
             }
-        } catch (InterruptedException | ExecutionException e) {
+        } catch (InterruptedException e) {
+            System.err.println("Main simulation thread was interrupted. Shutting down.");
             e.printStackTrace();
             Thread.currentThread().interrupt();
         }
-
-        System.out.printf("Simulation complete. Player A win rate: %.2f%% (%d/%d)\n", (100.0 * wins / numGames), wins, numGames);
+        System.out.printf("\n--- Simulation Summary ---\n");
+        System.out.printf("Total requested: %d games\n", numGames);
+        System.out.printf("Successful: %d\n", successfulGames);
+        System.out.printf("Failed: %d\n", failedGames);
+        System.out.printf("Player A win rate: %.2f%% (%d/%d)\n", (100.0 * wins / numGames), wins, numGames);
         return allLabeledStates;
     }
+
     public void print_labeled_states(List<LabeledState> labeledStates) {
         for (LabeledState ls : labeledStates) {
             StringBuilder sb1 = new StringBuilder();
@@ -149,111 +199,132 @@ public class ParallelMinimaxDataGenerator extends CardTestPlayerBaseAI {
 
         }
     }
-    private void processAndSaveData(List<LabeledState> allStates, String outputFilename) {
+
+    private void processAndSaveData(List<LabeledState> trainingStates, List<LabeledState> testingStates) {
+        List<LabeledState> allStates = new ArrayList<>(trainingStates);
+        allStates.addAll(testingStates);
         if (allStates.isEmpty()) {
-            System.out.println("No states were generated, skipping file save for " + outputFilename);
+            System.out.println("No states were generated, skipping file save for " + ParallelDataGenerator.TRAIN_OUT_FILE);
             return;
         }
-        print_labeled_states(allStates);
-        System.out.println("Processing " + allStates.size() + " states for " + outputFilename);
+        //print_labeled_states(trainingStates);
+        System.out.println("Processing " + allStates.size() + " states.");
+        System.out.println("Previous Index Count: " + previousRawSize);
         System.out.println("Initial Index Count: " + initialRawSize);
         System.out.println("Final Index Count: " + finalFeatures.localIndexCount.get());
         Set<Integer> oldIgnoreList = new HashSet<>(finalFeatures.ignoreList);
-        Set<Integer> newIgnoreList = new HashSet<>(FeatureMerger.computeIgnoreListFromLS(allStates, finalFeatures.localIndexCount.get()));
-        System.out.println("Computed " + newIgnoreList.size() + " features to ignore from this batch.");
-
-        finalFeatures.ignoreList = combine_ignore_lists(oldIgnoreList, newIgnoreList);
+        Set<Integer> newIgnoreListA = new HashSet<>(FeatureMerger.computeIgnoreListFromLS(allStates, 0, previousRawSize));
+        Set<Integer> newIgnoreListB = new HashSet<>(FeatureMerger.computeIgnoreListFromLS(allStates, previousRawSize, initialRawSize));
+        System.out.println("Computed " + newIgnoreListB.size() + " features to ignore from this batch.");
+        //intersect
+        newIgnoreListA.retainAll(oldIgnoreList);
+        //union
+        newIgnoreListA.addAll(newIgnoreListB);
+        finalFeatures.ignoreList = newIgnoreListA;
         System.out.println("Final combined ignore list size: " + finalFeatures.ignoreList.size());
 
         System.out.println("Compressing all states...");
         for (LabeledState ls : allStates) {
             ls.compress(finalFeatures.ignoreList);
         }
-
-        persistLabeledStates(allStates, outputFilename);
+        System.out.println("Final Compressed Feature Vector Size: " + (finalFeatures.localIndexCount.get() - finalFeatures.ignoreList.size()));
+        persistLabeledStates(trainingStates, ParallelDataGenerator.TRAIN_OUT_FILE);
+        persistLabeledStates(testingStates, ParallelDataGenerator.TEST_OUT_FILE);
         persistData();
-        System.out.println("Successfully saved data to " + outputFilename);
+        System.out.println("Successfully saved data to " + ParallelDataGenerator.TRAIN_OUT_FILE + " and " + ParallelDataGenerator.TEST_OUT_FILE);
     }
 
-    private GameResult runSingleGame() throws GameException, FileNotFoundException {
+    private GameResult runSingleGame() throws ExecutionException {
+        try {
 
-        Game game;
-        StateEncoder threadEncoder = new StateEncoder();
+            Game game;
+            StateEncoder threadEncoder = new StateEncoder();
 
-        // Use a thread-safe random number generator for the seed.
-        long gameSeed = ThreadLocalRandom.current().nextLong();
-        RandomUtil.setSeed(gameSeed);
+            // Use a thread-safe random number generator for the seed.
+            long gameSeed = ThreadLocalRandom.current().nextLong();
+            RandomUtil.setSeed(gameSeed);
 
 
-        // All game objects are local to this thread to prevent race conditions.
-        MatchOptions matchOptions = new MatchOptions("test match", "test game type", true, 4);
-        Match localMatch = new FreeForAllMatch(matchOptions);
-        game = new TwoPlayerDuel(MultiplayerAttackOption.LEFT, RangeOfInfluence.ONE, MulliganType.GAME_DEFAULT.getMulligan(0), 60, 20, 7);
-        TestPlayer playerA = createLocalPlayer(game, "PlayerA", DECK_A, localMatch);
-        TestPlayer playerB = createLocalPlayer(game, "PlayerB", DECK_B, localMatch);
+            // All game objects are local to this thread to prevent race conditions.
+            MatchOptions matchOptions = new MatchOptions("test match", "test game type", true, 4);
+            Match localMatch = new FreeForAllMatch(matchOptions);
+            game = new TwoPlayerDuel(MultiplayerAttackOption.LEFT, RangeOfInfluence.ONE, MulliganType.GAME_DEFAULT.getMulligan(0), 60, 20, 7);
+            TestPlayer playerA = createLocalPlayer(game, "PlayerA", DECK_A, localMatch);
+            TestPlayer playerB = createLocalPlayer(game, "PlayerB", DECK_B, localMatch);
 
-        try {
-            threadEncoder.loadMapping(finalFeatures);
-            ActionEncoder.actionMap = (Map<String, Integer>) loadObject(ACTIONS_FILE);
-            ActionEncoder.indexCount = ActionEncoder.actionMap.size();
-        } catch (IOException | ClassNotFoundException e) {
-            System.err.println("Worker thread failed to load persistent mappings.");
-        }
+            try {
+                threadEncoder.loadMapping(finalFeatures);
+                ActionEncoder.actionMap = (Map<String, Integer>) loadObject(ACTIONS_FILE);
+                ActionEncoder.indexCount = ActionEncoder.actionMap.size();
+            } catch (IOException | ClassNotFoundException e) {
+                System.err.println("Worker thread failed to load persistent mappings.");
+            }
 
-        configurePlayer(playerA, threadEncoder, playerB.getId());
-        configurePlayer(playerB, threadEncoder, playerA.getId());
-
-        // Based on CardTestPlayerAPIImpl.java, this is the correct thread-safe
-        // way to configure and run a game simulation.
-        GameOptions options = new GameOptions();
-        options.testMode = true;
-        options.stopOnTurn = MAX_GAME_TURNS;
-        options.stopAtStep = PhaseStep.END_TURN;
-        game.setGameOptions(options);
-
-        // Start the game simulation. This is a blocking call that will run the game to completion.
-        game.start(playerA.getId());
-
-        // The rest of the logic is safe as it uses the local player objects.
-        boolean playerAWon = playerA.hasWon();
-        //merge to the final features
-        finalFeatures.merge(threadEncoder.getFeatures());
-        return new GameResult(generateLabeledStatesForGame(threadEncoder, playerAWon), playerAWon);
+            configurePlayer(playerA, threadEncoder);
+            configurePlayer(playerB, threadEncoder);
+            threadEncoder.setAgent(playerA.getId());
+            threadEncoder.setOpponent(playerB.getId());
+
+            // Based on CardTestPlayerAPIImpl.java, this is the correct thread-safe
+            // way to configure and run a game simulation.
+            GameOptions options = new GameOptions();
+            options.testMode = true;
+            options.stopOnTurn = MAX_GAME_TURNS;
+            options.stopAtStep = PhaseStep.END_TURN;
+            game.setGameOptions(options);
+
+            // Start the game simulation. This is a blocking call that will run the game to completion.
+            game.start(playerA.getId());
+
+            // The rest of the logic is safe as it uses the local player objects.
+            boolean playerAWon = playerA.hasWon();
+            //merge to the final features
+            finalFeatures.merge(threadEncoder.getFeatures());
+            synchronized (finalFeatures) {
+                assert (finalFeatures.localIndexCount.get() >= threadEncoder.getFeatures().localIndexCount.get());
+            }
+            return new GameResult(generateLabeledStatesForGame(threadEncoder, playerAWon), playerAWon);
+        } catch (Exception e) {
+            System.err.println("Caught an internal AI/Game exception in a worker thread. Ignoring this game. Cause: " + e.getMessage());
+            throw new ExecutionException("Worker thread failed - ignoring", e);
+        }
     }
 
-    private void configurePlayer(TestPlayer player, StateEncoder encoder, UUID opponentId) {
+    private void configurePlayer(TestPlayer player, StateEncoder encoder) {
         if (player.getComputerPlayer() instanceof ComputerPlayerMCTS2) {
             ((ComputerPlayerMCTS2) player.getComputerPlayer()).setEncoder(encoder);
             ((ComputerPlayerMCTS2) player.getComputerPlayer()).initNN(MCTS_MODEL_PATH);
         } else if (player.getComputerPlayer() instanceof ComputerPlayer8) {
             ((ComputerPlayer8) player.getComputerPlayer()).setEncoder(encoder);
+        } else if (player.getComputerPlayer() instanceof ComputerPlayerPureMCTS) {
+            ((ComputerPlayerPureMCTS) player.getComputerPlayer()).setEncoder(encoder);
         }
-        encoder.setAgent(player.getId());
-        encoder.setOpponent(opponentId);
     }
 
     private List<LabeledState> generateLabeledStatesForGame(StateEncoder encoder, boolean didPlayerAWin) {
-        List<LabeledState> results = new ArrayList<>();
-        int N = encoder.macroStateVectors.size();
-        double gamma = 0.99;
-        double lambda = 0.5;
-
-        for (int i = 0; i < N; i++) {
-            Set<Integer> state = encoder.macroStateVectors.get(i);
-            double[] action = ActionEncoder.actionVectors.get(i);
-            double normScore = encoder.stateScores.get(i);
-            double terminal = didPlayerAWin ? +1.0 : -1.0;
-            double discount = Math.pow(gamma, N - i - 1);
-            double blended = lambda * normScore + (1.0 - lambda) * terminal * discount;
-            results.add(new LabeledState(state, action, blended));
+        synchronized (encoder) {
+            List<LabeledState> results = new ArrayList<>();
+            int N = encoder.macroStateVectors.size();
+            double gamma = 0.99;
+            double lambda = 0.5;
+
+            for (int i = 0; i < N; i++) {
+                Set<Integer> state = encoder.macroStateVectors.get(i);
+                double[] action = encoder.actionVectors.get(i);
+                double normScore = encoder.stateScores.get(i);
+                double terminal = didPlayerAWin ? +1.0 : -1.0;
+                double discount = Math.pow(gamma, N - i - 1);
+                double blended = lambda * normScore + (1.0 - lambda) * terminal * discount;
+                results.add(new LabeledState(state, action, blended));
+            }
+            return results;
         }
-        return results;
     }
 
     //region Helper Methods
     public Set<Integer> combine_ignore_lists(Set<Integer> oldList, Set<Integer> newList) {
         Set<Integer> updatedIgnoreList = new HashSet<>();
-        int boundaryForOldFeatures = initialRawSize;
+        int boundaryForOldFeatures = previousRawSize;
 
         for (int i = 0; i < boundaryForOldFeatures; i++) {
             if (oldList.contains(i) && newList.contains(i)) {
@@ -270,6 +341,8 @@ public class ParallelMinimaxDataGenerator extends CardTestPlayerBaseAI {
 
     public void persistData() {
         try {
+            finalFeatures.previousLocalIndexCount = initialRawSize;
+            finalFeatures.version++;
             finalFeatures.saveMapping(MAPPING_FILE);
             System.out.printf("Persisted feature mapping (and ignore list) to %s%n", MAPPING_FILE);
             saveObject(new HashMap<>(ActionEncoder.actionMap), ACTIONS_FILE);
@@ -286,7 +359,7 @@ public class ParallelMinimaxDataGenerator extends CardTestPlayerBaseAI {
             out.writeInt(128); // Assuming policy vector size is constant
 
             for (LabeledState ls : states) {
-                ls.persist(out);
+                ls.persist(out, finalFeatures.localIndexCount.get());
             }
         } catch (IOException e) {
             e.printStackTrace();
@@ -304,6 +377,7 @@ public class ParallelMinimaxDataGenerator extends CardTestPlayerBaseAI {
             return in.readObject();
         }
     }
+
     //endregion
     @Override
     public List<String> getFullSimulatedPlayers() {
@@ -339,10 +413,17 @@ public class ParallelMinimaxDataGenerator extends CardTestPlayerBaseAI {
     // This is the correct override to use for creating players within our self-contained games.
     @Override
     protected TestPlayer createPlayer(String name, RangeOfInfluence rangeOfInfluence) {
-        TestComputerPlayer8 t8 = new TestComputerPlayer8(name, RangeOfInfluence.ONE, getSkillLevel());
-        TestPlayer testPlayer = new TestPlayer(t8);
-        testPlayer.setAIPlayer(true);
-        return testPlayer;
+        if (name.equals("PlayerA")) {
+            TestComputerPlayer8 t8 = new TestComputerPlayer8(name, RangeOfInfluence.ONE, getSkillLevel());
+            TestPlayer testPlayer = new TestPlayer(t8);
+            testPlayer.setAIPlayer(true);
+            return testPlayer;
+        } else {
+            TestComputerPlayer7 t7 = new TestComputerPlayer7(name, RangeOfInfluence.ONE, getSkillLevel());
+            TestPlayer testPlayer = new TestPlayer(t7);
+            testPlayer.setAIPlayer(true);
+            return testPlayer;
+        }
     }
     //endregion
 }
\ No newline at end of file
diff --git a/Mage.Tests/src/test/java/org/mage/test/AI/RL/RLEncodingTests.java b/Mage.Tests/src/test/java/org/mage/test/AI/RL/RLEncodingTests.java
index 71b9ed5d82..a18e896895 100644
--- a/Mage.Tests/src/test/java/org/mage/test/AI/RL/RLEncodingTests.java
+++ b/Mage.Tests/src/test/java/org/mage/test/AI/RL/RLEncodingTests.java
@@ -1,6 +1,5 @@
 package org.mage.test.AI.RL;
 
-import com.j256.ormlite.stmt.query.In;
 import mage.constants.MultiplayerAttackOption;
 import mage.constants.PhaseStep;
 import mage.constants.RangeOfInfluence;
@@ -18,19 +17,22 @@ import org.mage.test.player.TestPlayer;
 import org.mage.test.serverside.base.CardTestPlayerBaseAI;
 
 import java.io.FileNotFoundException;
+import java.io.IOException;
 import java.util.Arrays;
-import java.util.BitSet;
+import java.util.HashMap;
 import java.util.List;
 import java.util.Set;
 
+import static org.mage.test.AI.RL.MinimaxVectorExtractionTests.MAPPING_FILE;
+
 /**
  * @author WillWroble
  */
 public class RLEncodingTests extends CardTestPlayerBaseAI {
     StateEncoder encoder;
-    private String deckNameA = "UWTempo.dck"; //simplegreen, UWTempo
-    private String deckNameB = "simplegreen.dck";
-
+    private String deckNameB = "UWTempo.dck"; //simplegreen, UWTempo
+    private String deckNameA = "simplegreen.dck";
+    Features old_features;
 
     @Override
     public List<String> getFullSimulatedPlayers() {
@@ -48,7 +50,7 @@ public class RLEncodingTests extends CardTestPlayerBaseAI {
     protected TestPlayer createPlayer(String name, RangeOfInfluence rangeOfInfluence) {
         if (getFullSimulatedPlayers().contains(name)) {
             if(name.equals("PlayerA")) {
-                TestComputerPlayer7 t8 = new TestComputerPlayer7(name, RangeOfInfluence.ONE, getSkillLevel());
+                TestComputerPlayer8 t8 = new TestComputerPlayer8(name, RangeOfInfluence.ONE, getSkillLevel());
                 TestPlayer testPlayer = new TestPlayer(t8);
                 testPlayer.setAIPlayer(true); // enable full AI support (game simulations) for all turns by default
                 return testPlayer;
@@ -68,11 +70,24 @@ public class RLEncodingTests extends CardTestPlayerBaseAI {
         set_encoder();
     }
     public void set_encoder() {
-        if(true) return;
+        //if(true) return;
         ComputerPlayer8 c8 = (ComputerPlayer8)playerA.getComputerPlayer();
         c8.setEncoder(encoder);
         encoder.setAgent(playerA.getId());
         encoder.setOpponent(playerB.getId());
+        //if(true) return;
+        try {
+            old_features = Features.loadMapping(MAPPING_FILE);
+        } catch (IOException | ClassNotFoundException e) {
+            throw new RuntimeException("failed to load persistent mappings.", e);
+        }
+        if(true) return;
+        try {
+            encoder.loadMapping(MAPPING_FILE);
+        } catch (IOException | ClassNotFoundException e) {
+            throw new RuntimeException("failed to load persistent mappings.", e);
+        }
+
     }
     public void reset_game() {
         try {
@@ -88,6 +103,7 @@ public class RLEncodingTests extends CardTestPlayerBaseAI {
     //5 turns across 1 game
     @Test
     public void test_encoding_5_1() {
+        Features.printOldFeatures = false;
         // simple test of 5 turns
         int maxTurn = 5;
         //addCard(Zone.HAND, playerA, "Fauna Shaman", 3);
@@ -95,6 +111,24 @@ public class RLEncodingTests extends CardTestPlayerBaseAI {
         setStopAt(maxTurn, PhaseStep.END_TURN);
         execute();
 
+//        try {
+//            encoder.getFeatures().saveMapping(MAPPING_FILE);
+//            System.out.printf("Persisted feature mapping (and ignore list) to %s%n", MAPPING_FILE);
+//        } catch (IOException e) {
+//            e.printStackTrace();
+//        }
+        //if(true) return;
+        logger.info(old_features.localIndexCount);
+        logger.info(encoder.getFeatures().localIndexCount);
+        old_features.merge(encoder.getFeatures());
+        logger.info(old_features.localIndexCount);
+
+        try {
+            old_features.saveMapping(MAPPING_FILE);
+            System.out.printf("Persisted feature mapping (and ignore list) to %s%n", MAPPING_FILE);
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
     }
     //20 turns across 1 game
     @Test
@@ -224,29 +258,7 @@ public class RLEncodingTests extends CardTestPlayerBaseAI {
         execute();
         System.out.println(ignore);
     }
-    @Test
-    public void test_state_consistency() {
-        int maxTurn = 10;
-        //removeAllCardsFromHand(playerA);
-        setStrictChooseMode(true);
-        setStopAt(maxTurn, PhaseStep.END_TURN);
-        execute();
-        //save state after 5 turns
-        int bookmarkedState = currentGame.bookmarkState();
-        Set<Integer> savedVec = StateEncoder.featureVector;
-        reset_game();
-        //simulate another 5 turns
-        setStrictChooseMode(true);
-        setStopAt(maxTurn, PhaseStep.END_TURN);
-        execute();
-        //reload state and read it
-        currentGame.restoreState(bookmarkedState, "rolling_back_for_testing");
-        encoder.processState(currentGame);
-        Set<Integer> newVec = StateEncoder.featureVector;
-        System.out.println(savedVec);
-        System.out.println(newVec);
-        assert (savedVec.equals(newVec));
-    }
+
     @After
     public void print_vector_size() {
         System.out.printf("FINAL (unreduced) VECTOR SIZE: %d\n", StateEncoder.indexCount);
diff --git a/Mage.Tests/src/test/java/org/mage/test/AI/RL/SimulateMCTS.java b/Mage.Tests/src/test/java/org/mage/test/AI/RL/SimulateMCTS.java
index 19df688418..ef94d9afbb 100644
--- a/Mage.Tests/src/test/java/org/mage/test/AI/RL/SimulateMCTS.java
+++ b/Mage.Tests/src/test/java/org/mage/test/AI/RL/SimulateMCTS.java
@@ -1,4 +1,30 @@
 package org.mage.test.AI.RL;
 
-public class SimulateMCTS {
+import mage.constants.RangeOfInfluence;
+import org.junit.Test;
+import org.mage.test.player.*;
+
+public class SimulateMCTS extends ParallelDataGenerator {
+
+
+    @Test
+    public void generateTrainingAndTestingData() {
+        super.generateTrainingAndTestingData();
+    }
+
+    // This is the correct override to use for creating players within our self-contained games.
+    @Override
+    protected TestPlayer createPlayer(String name, RangeOfInfluence rangeOfInfluence) {
+        if(name.equals("PlayerA")) {
+            TestComputerPlayerMonteCarlo2 mcts2 = new TestComputerPlayerMonteCarlo2(name, RangeOfInfluence.ONE, getSkillLevel());
+            TestPlayer testPlayer = new TestPlayer(mcts2);
+            testPlayer.setAIPlayer(true); // enable full AI support (game simulations) for all turns by default
+            return testPlayer;
+        } else {
+            TestComputerPlayer8 t8 = new TestComputerPlayer8(name, RangeOfInfluence.ONE, getSkillLevel());
+            TestPlayer testPlayer = new TestPlayer(t8);
+            testPlayer.setAIPlayer(true);
+            return testPlayer;
+        }
+    }
 }
diff --git a/Mage.Tests/src/test/java/org/mage/test/AI/RL/SimulatePureMCTS.java b/Mage.Tests/src/test/java/org/mage/test/AI/RL/SimulatePureMCTS.java
index 2d33951c30..18d6d36ecd 100644
--- a/Mage.Tests/src/test/java/org/mage/test/AI/RL/SimulatePureMCTS.java
+++ b/Mage.Tests/src/test/java/org/mage/test/AI/RL/SimulatePureMCTS.java
@@ -1,4 +1,31 @@
 package org.mage.test.AI.RL;
 
-public class SimulatePureMCTS {
+import mage.constants.RangeOfInfluence;
+import mage.player.ai.ComputerPlayerPureMCTS;
+import org.junit.Test;
+import org.mage.test.player.*;
+
+public class SimulatePureMCTS extends ParallelDataGenerator {
+
+
+    @Test
+    public void generateTrainingAndTestingData() {
+        super.generateTrainingAndTestingData();
+    }
+
+    // This is the correct override to use for creating players within our self-contained games.
+    @Override
+    protected TestPlayer createPlayer(String name, RangeOfInfluence rangeOfInfluence) {
+        if(name.equals("PlayerA")) {
+            TestComputerPlayerPureMonteCarlo pmcts = new TestComputerPlayerPureMonteCarlo(name, RangeOfInfluence.ONE, getSkillLevel());
+            TestPlayer testPlayer = new TestPlayer(pmcts);
+            testPlayer.setAIPlayer(true); // enable full AI support (game simulations) for all turns by default
+            return testPlayer;
+        } else {
+            TestComputerPlayer8 t8 = new TestComputerPlayer8(name, RangeOfInfluence.ONE, getSkillLevel());
+            TestPlayer testPlayer = new TestPlayer(t8);
+            testPlayer.setAIPlayer(true);
+            return testPlayer;
+        }
+    }
 }
diff --git a/Mage.Tests/testing.bin b/Mage.Tests/testing.bin
index ab27eacfbd..2be2d05df1 100644
Binary files a/Mage.Tests/testing.bin and b/Mage.Tests/testing.bin differ
diff --git a/Mage.Tests/training.bin b/Mage.Tests/training.bin
index f3a0f558bc..36182be290 100644
Binary files a/Mage.Tests/training.bin and b/Mage.Tests/training.bin differ
diff --git a/Mage/src/main/java/mage/abilities/mana/AnyColorPermanentTypesManaAbility.java b/Mage/src/main/java/mage/abilities/mana/AnyColorPermanentTypesManaAbility.java
index f6cd43bbfc..75d61936a7 100644
--- a/Mage/src/main/java/mage/abilities/mana/AnyColorPermanentTypesManaAbility.java
+++ b/Mage/src/main/java/mage/abilities/mana/AnyColorPermanentTypesManaAbility.java
@@ -58,7 +58,7 @@ class AnyColorPermanentTypesManaEffect extends ManaEffect {
 
     public AnyColorPermanentTypesManaEffect(TargetController targetController, FilterPermanent permanentTypes) {
         super();
-        filter = permanentTypes;
+        filter = permanentTypes.copy();
         filter.add(targetController.getControllerPredicate());
         staticText = "Add one mana of any color" +
                 " among " + permanentTypes.getMessage() + " " +
diff --git a/Mage/src/main/java/mage/constants/PhaseStep.java b/Mage/src/main/java/mage/constants/PhaseStep.java
index 5b71c6e09b..3d94af36cc 100644
--- a/Mage/src/main/java/mage/constants/PhaseStep.java
+++ b/Mage/src/main/java/mage/constants/PhaseStep.java
@@ -47,11 +47,11 @@ public enum PhaseStep {
     public int getIndex() {
         return index;
     }
-
-    @Override
-    public String toString() {
-        return text;
-    }
+//
+//    @Override
+//    public String toString() {
+//        return text;
+//    }
 
     public static PhaseStep fromString(String needText) {
         return Arrays.stream(values())
diff --git a/Mage/src/main/java/mage/game/GameImpl.java b/Mage/src/main/java/mage/game/GameImpl.java
index 30e4d8c0a3..6217062e15 100644
--- a/Mage/src/main/java/mage/game/GameImpl.java
+++ b/Mage/src/main/java/mage/game/GameImpl.java
@@ -1515,13 +1515,13 @@ public abstract class GameImpl implements Game {
             // This is not a real emblem. Just a fake source for the
             // inherent trigger ability related to Rad counters
             // Faking a source just to display something on the stack ability.
-            state.addHelperEmblem(new RadiationEmblem(), playerId);
+            //state.addHelperEmblem(new RadiationEmblem(), playerId);
         }
 
         // global card hints for better UX
         for (UUID playerId : state.getPlayerList(startingPlayerId)) {
-            state.addHelperEmblem(new XmageHelperEmblem().withCardHint("storm counter", StormAbility.getHint()), playerId);
-            state.addHelperEmblem(new XmageHelperEmblem().withCardHint("day or night", DayNightHint.instance), playerId);
+            //state.addHelperEmblem(new XmageHelperEmblem().withCardHint("storm counter", StormAbility.getHint()), playerId);
+            //state.addHelperEmblem(new XmageHelperEmblem().withCardHint("day or night", DayNightHint.instance), playerId);
         }
     }
 
diff --git a/my_changes.diff b/my_changes.diff
index 67b51a3702..8452a7a845 100644
--- a/my_changes.diff
+++ b/my_changes.diff
@@ -1,2316 +1,391 @@
-diff --git a/Mage.Server.Plugins/Mage.Player.AI.MA/src/mage/player/ai/ComputerPlayer6.java b/Mage.Server.Plugins/Mage.Player.AI.MA/src/mage/player/ai/ComputerPlayer6.java
-index d22e381cc8..98d36984fd 100644
---- a/Mage.Server.Plugins/Mage.Player.AI.MA/src/mage/player/ai/ComputerPlayer6.java
-+++ b/Mage.Server.Plugins/Mage.Player.AI.MA/src/mage/player/ai/ComputerPlayer6.java
-@@ -431,6 +431,7 @@ public class ComputerPlayer6 extends ComputerPlayer {
-      */
-     protected Integer addActionsTimed() {
-         // run new game simulation in parallel thread
-+        //assert (threadPoolSimulations != null);
-         FutureTask<Integer> task = new FutureTask<>(() -> addActions(root, maxDepth, Integer.MIN_VALUE, Integer.MAX_VALUE));
-         threadPoolSimulations.execute(task);
-         try {
-diff --git a/Mage.Server.Plugins/Mage.Player.AI.MA/src/mage/player/ai/GameStateEvaluator2.java b/Mage.Server.Plugins/Mage.Player.AI.MA/src/mage/player/ai/GameStateEvaluator2.java
-index 7adc1cb429..3ec0de6bf9 100644
---- a/Mage.Server.Plugins/Mage.Player.AI.MA/src/mage/player/ai/GameStateEvaluator2.java
-+++ b/Mage.Server.Plugins/Mage.Player.AI.MA/src/mage/player/ai/GameStateEvaluator2.java
-@@ -154,6 +154,12 @@ public final class GameStateEvaluator2 {
-                         + ":" + GameStateEvaluator2.evaluatePermanent(p, game, true))
-                 .collect(Collectors.joining("; "));
-         sb.append("-> Permanents: [").append(ownPermanentsInfo).append("]");
-+        // graveyard
-+        sb.setLength(0);
-+        String ownGraveInfo = player.getGraveyard().stream()
-+                .map(id -> game.getObject(id).getName())
-+                .collect(Collectors.joining("; "));
-+        sb.append("-> Graveyard: [").append(ownGraveInfo).append("]");
-         logger.info(sb.toString());
-     }
-     public static int evaluatePermanent(Permanent permanent, Game game, boolean useCombatPermanentScore) {
-diff --git a/Mage.Server.Plugins/Mage.Player.AI.RL/pom.xml b/Mage.Server.Plugins/Mage.Player.AI.RL/pom.xml
-index 3e9a7d0a90..caaa9161cb 100644
---- a/Mage.Server.Plugins/Mage.Player.AI.RL/pom.xml
-+++ b/Mage.Server.Plugins/Mage.Player.AI.RL/pom.xml
-@@ -39,7 +39,7 @@
-         <dependency>
-             <groupId>com.microsoft.onnxruntime</groupId>
-             <artifactId>onnxruntime</artifactId>
--            <version>1.15.1</version>
-+            <version>1.18.0</version>
-         </dependency>
-     </dependencies>
+diff --git a/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/Features.java b/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/Features.java
+index 3cc053f64a..59dc18cc24 100644
+--- a/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/Features.java
++++ b/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/Features.java
+@@ -4,20 +4,22 @@ import java.io.*;
+ import java.nio.file.Files;
+ import java.nio.file.Paths;
+ import java.util.*;
++import java.util.concurrent.atomic.AtomicInteger;
  
-diff --git a/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/ComputerPlayer8.java b/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/ComputerPlayer8.java
-index 3e1d9609d6..3e25bb645c 100644
---- a/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/ComputerPlayer8.java
-+++ b/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/ComputerPlayer8.java
-@@ -11,7 +11,8 @@ import mage.target.Target;
- import java.util.UUID;
+ /**
+- *this hierarchical structure represents the mapping of every possible relevant feature encountered from a game state to
+- * an index on a 200000 dimension binary vector. the reduced form of this vector (~6000) will be used as input for both a policy and
++ * This hierarchical structure represents the mapping of every possible relevant feature encountered from a game state to
++ * an index on a 200000 dimension binary vector. The reduced form of this vector (~5000) will be used as input for both a policy and
+  * value neural network. To see how game features are mapped look at StateEncoder.java this data structure only handles and stores the
+- * mappings
++ * mappings.
++ *
+  * @author willwroble
+  */
+-public class Features  implements Serializable {
+-    private static final long serialVersionUID = 1L;
+-    public int globalIndexCount;
+-    Set<Integer> ignoreList;
+-    Map<Integer, Integer> rawToReduced;
+-    int version;
++public class Features implements Serializable {
++    private static final long serialVersionUID = 2L; // Version updated for the structural change
++    public AtomicInteger localIndexCount; // a mutable, thread-safe counter
++    public int previousLocalIndexCount = 0;
++    public Set<Integer> ignoreList;
++    public int version = 0;
+ 
+     private final Map<String, Map<Integer, Features>> subFeatures;
+     private final Map<String, Map<Integer, Integer>> features;
+@@ -28,12 +30,13 @@ public class Features  implements Serializable {
+     private final Set<Features> categories; //resets every state represents temporary category features fall under
+     public boolean passToParent = true;
  
- public class ComputerPlayer8 extends ComputerPlayer7{
 -    private StateEncoder encoder;
-+    //public static boolean saveMinimaxScore = true;
 +    private transient StateEncoder encoder;
-     public ComputerPlayer8(ComputerPlayer7 player) {
-         super(player);
-     }
-diff --git a/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/ComputerPlayerMCTS2.java b/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/ComputerPlayerMCTS2.java
-index 54b89f5b82..70abdb3046 100644
---- a/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/ComputerPlayerMCTS2.java
-+++ b/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/ComputerPlayerMCTS2.java
-@@ -4,6 +4,7 @@ import ai.onnxruntime.OrtException;
- import mage.constants.PhaseStep;
- import mage.constants.RangeOfInfluence;
- import mage.game.Game;
-+import mage.game.GameState;
- import mage.player.ai.MCTSPlayer.NextAction;
- import mage.util.RandomUtil;
- import mage.util.ThreadUtils;
-@@ -21,31 +22,21 @@ public class ComputerPlayerMCTS2 extends ComputerPlayerMCTS {
- 
-     private static final Logger logger = Logger.getLogger(ComputerPlayerMCTS2.class);
- 
--    private StateEncoder encoder = null;
--    private static final int MAX_MCTS_CYCLES = 2;//number of additional cycles the search is allowed to run
--    private static final int BASE_THREAD_TIMEOUT = 3;//seconds
--    private static final int MIN_TREE_VISITS = 100;
--    private static final int MAX_TREE_VISITS = 200;
-+    private transient StateEncoder encoder = null;
-+    private transient ReplayBuffer buffer = null;
-+    private static final int MAX_MCTS_CYCLES = 6;//number of additional cycles the search is allowed to run
-+    private static final int BASE_THREAD_TIMEOUT = 1;//seconds
-+    private static final int MIN_TREE_VISITS = 50;//per child per thread
- 
-     public static boolean SHOW_THREAD_INFO = false;
--    //protected List<UUID> targets = new ArrayList<>();
--    //protected List<String> choices = new ArrayList<>();
--    public NeuralNetEvaluator nn;
-+    public transient NeuralNetEvaluator nn;
- 
--    public static String PATH_TO_NN = "null";
--    private final Object encoderLock = new Object();
--    private final Object executorLock = new Object();
- 
- 
- 
- 
-     public ComputerPlayerMCTS2(String name, RangeOfInfluence range, int skill) {
-         super(name, range, skill);
--        try {
--            nn = new NeuralNetEvaluator(PATH_TO_NN);
--        } catch (OrtException e) {
--            throw new RuntimeException(e);
--        }
-     }
- 
-     protected ComputerPlayerMCTS2(UUID id) {
-@@ -62,62 +53,49 @@ public class ComputerPlayerMCTS2 extends ComputerPlayerMCTS {
-         return new ComputerPlayerMCTS2(this);
-     }
- 
-+    /**
-+     * Evaluates a node's game state using the neural network.
-+     * This method encodes the state into sparse global indices, runs inference,
-+     * and updates the node's policy prior.
-+     *
-+     * @param node The MCTSNode to evaluate.
-+     * @return The value of the game state as predicted by the neural network's value head.
-+     */
-     protected double evaluateState(MCTSNode node) {
--        // 1) Get the active GLOBAL feature indices for the current state.
--        // This replaces the old way of getting a deck-local BitSet and converting it.
-+
-         int[] activeGlobalIndices;
--        synchronized(encoderLock) { // Keep synchronization if encoder access needs it
--            encoder.processState(node.getGame()); // This should prepare the raw features
--
--            // You need a method in your StateEncoder that returns the
--            // final list of active GLOBAL indices. This method would:
--            //   a. Get the raw features from the current game state.
--            //   b. Map them to global indices (using rawToReduced, assigning new ones if needed).
--            //   c. Apply the ignoreList.
--            // Let's assume such a method exists, e.g., encoder.getActiveGlobalIndices();
--            // For this example, I'll use a placeholder for how you get these.
--            // If encoder.getCompressedVector still returns a Set<Integer> of global indices:
--            Set<Integer> globalIndicesSet = encoder.getCompressedVector(StateEncoder.featureVector);
--            activeGlobalIndices = globalIndicesSet.stream().mapToInt(Integer::intValue).toArray();
--            // Or, if you have a more direct method:
--            // activeGlobalIndices = encoder.getFinalActiveGlobalIndicesArray();
--        }
- 
--        // 2) Prepare inputs for the ONNX model (expecting EmbeddingBag style input)
--        //    The exact format depends on how your ONNX runtime library takes tensor inputs.
--        //    Typically, for a single inference, you'd have:
--        //    - indices: A 1D array/tensor of the activeGlobalIndices.
--        //    - offsets: A 1D array/tensor like [0] indicating the start of the single sample.
-+        encoder.processState(node.getGame());
-+        activeGlobalIndices = encoder.getFinalActiveGlobalIndicesArray();
-+
  
--        //    Let's assume your nn.infer() is adapted to take these.
--        //    You might need to convert activeGlobalIndices to a long[] or specific tensor format
--        //    required by your Java ONNX runtime.
--        //    For example, if it needs long[] for indices:
-         long[] onnxIndices = new long[activeGlobalIndices.length];
+     private String featureName;
+-    private Features parent;
++    public Features parent;
+     public static boolean printOldFeatures = true;
+     public static boolean printNewFeatures = true;
 +
-         for (int i = 0; i < activeGlobalIndices.length; i++) {
-             onnxIndices[i] = activeGlobalIndices[i];
-         }
--        long[] onnxOffsets = new long[]{0}; // For a single sample batch
- 
--        NeuralNetEvaluator.InferenceResult out;
--        synchronized(encoderLock) { // If nn.infer() also needs sync with encoder or is not thread-safe
--            // 3) Run the ONNX model with the new sparse input format
--            //    The signature of nn.infer() would need to change.
--            out = nn.infer(onnxIndices);
--        }
--
--        // 4) Process outputs (this part remains the same)
-+        NeuralNetEvaluator.InferenceResult out = nn.infer(onnxIndices);
-         node.policy = out.policy;
-+
-         return out.value;
+     public Features() {
+         //constructor
+         subFeatures = new HashMap<>();
+@@ -43,58 +46,82 @@ public class Features  implements Serializable {
+         numericOccurrences = new HashMap<>();
+         categoriesForChildren = new HashMap<>();
+         categories = new HashSet<>();
++        ignoreList = new HashSet<>();
++        localIndexCount = new AtomicInteger(0);
+         parent = null;
+         featureName = "root";
      }
 +
-     public void setEncoder(StateEncoder enc) {
-         encoder = enc;
-     }
--
--    public StateEncoder getEncoder() {
--        return encoder;
-+    public void setBuffer(ReplayBuffer buf) {
-+        buffer = buf;
+     public Features(Features p, String name) {
+         this();
++        // Manually set fields instead of calling this(), to avoid creating a new AtomicInteger
+         parent = p;
+         featureName = name;
+         encoder = p.encoder;
++        localIndexCount = p.localIndexCount;
 +    }
-+    public void initNN(String path) {
-+        try {
-+            nn = new NeuralNetEvaluator(path);
-+        } catch (OrtException e) {
-+            throw new RuntimeException(e);
-+        }
-     }
--    public int diffVisits(List<Integer> children) {
 +
-+    public double diffVisits(List<Integer> children) {
-         int max = -1;
-         int max2 = -1;//second highest
-         for(int n : children) {
-@@ -128,7 +106,7 @@ public class ComputerPlayerMCTS2 extends ComputerPlayerMCTS {
-                 max2 = n;
-             }
-         }
--        return max-max2;
-+        return (max*1.0)/max2;
++    public Features(String name, StateEncoder e, AtomicInteger i) {
++        this();
++        featureName = name;
++        encoder = e;
++        localIndexCount = i;
+     }
+ 
+     public void setEncoder(StateEncoder encoder) {
+         this.encoder = encoder;
++        for (String n : subFeatures.keySet()) {
++            for (Integer i : subFeatures.get(n).keySet()) {
++                subFeatures.get(n).get(i).setEncoder(encoder);
++            }
++        }
++        for (String n : categoriesForChildren.keySet()) {
++            categoriesForChildren.get(n).setEncoder(encoder);
++        }
      }
-     public int averageVisits(List<Integer> children) {
-         int sum = 0;
-@@ -156,10 +134,11 @@ public class ComputerPlayerMCTS2 extends ComputerPlayerMCTS {
-         int initialVisits = root.getAverageVisits();
-         //if(initialVisits > MAX_TREE_VISITS) return;//just keep using tree
-         if(SHOW_THREAD_INFO) System.out.printf("STARTING ROOT VISITS: %d\n", initialVisits);
--        int thinkTime = BASE_THREAD_TIMEOUT;//calculateThinkTime(game, action);
-+        int thinkTime = BASE_THREAD_TIMEOUT;
- 
- 
-         if (this.threadPoolSimulations == null) {
-+            System.out.println(poolSize);
-             this.threadPoolSimulations = new ThreadPoolExecutor(
-                     poolSize,
-                     poolSize,
-@@ -174,6 +153,7 @@ public class ComputerPlayerMCTS2 extends ComputerPlayerMCTS {
-         for (int i = 0; i < poolSize; i++) {
-             Game sim = createMCTSGame(game);
-             MCTSPlayer player = (MCTSPlayer) sim.getPlayer(playerId);
-+            player.lastToAct = true;
-             player.chooseTargetOptions = chooseTargetOptions;
-             player.chooseTargetAction = new ArrayList<>(chosenChooseTargetActions);
-             player.setNextAction(action);
-@@ -193,9 +173,12 @@ public class ComputerPlayerMCTS2 extends ComputerPlayerMCTS {
-         int cycleCounter = 0;
-         int fullTime = 0;
- 
--        while (averageVisits(childVisits)+initialVisits < MIN_TREE_VISITS) {//use max visits of children as indicator
-+        while (averageVisits(childVisits)+initialVisits < MIN_TREE_VISITS*poolSize) {//use max visits of children as indicator
-+
-+            if (cycleCounter > MAX_MCTS_CYCLES) break; //early exit
-+
-+            if(diffVisits(childVisits) > 2.5 && averageVisits(childVisits) > MIN_TREE_VISITS*poolSize*0.5) break;
  
--            if (cycleCounter > MAX_MCTS_CYCLES) break;
-             cycleCounter++;
-             try {
-                 List<Future<Boolean>> runningTasks = threadPoolSimulations.invokeAll(tasks, thinkTime, TimeUnit.SECONDS);
-@@ -222,7 +205,6 @@ public class ComputerPlayerMCTS2 extends ComputerPlayerMCTS {
-                 System.out.printf("\nCOMPOSITE CHILDREN: %s\n", childVisits.toString());
-             }
-             fullTime += thinkTime;
--            thinkTime += 1;
-         }
-         int simCount = 0;
-         for (MCTSExecutor task : tasks) {
-@@ -272,7 +254,7 @@ public class ComputerPlayerMCTS2 extends ComputerPlayerMCTS {
-             Game sim = createMCTSGame(game);
-             MCTSPlayer player = (MCTSPlayer) sim.getPlayer(playerId);
-             player.setNextAction(action);
--            player.isRoot = true;
-+            player.lastToAct = true;
-             root = new MCTSNode(playerId, sim);
-             player.chooseTargetOptions = chooseTargetOptions;
-             player.chooseTargetAction = new ArrayList<>(chosenChooseTargetActions);
-@@ -282,19 +264,19 @@ public class ComputerPlayerMCTS2 extends ComputerPlayerMCTS {
-         if (root != null) {
-             MCTSNode best = root.bestChild();
-             if(best == null) return;
--            synchronized (encoderLock) {
--                encoder.processMacroState(game);
--                encoder.stateScores.add(root.score);
--                ActionEncoder.addAction(getActionVec());
--            }
--            macroState = root.macroState;
--            macroPlayerId = getId();
-+
-+            encoder.processMacroState(game);
-+            ActionEncoder.addAction(getActionVec());
-+            Game copiedState = game.copy();
-+            buffer.add(copiedState);
-+
-+            //macroState = root.macroState;
-             root = best;
--            lastAction = root.action;
-+            //game.setLastAction(root.action);
-             root.emancipate();
+     public Features getCategory(String name) {
+-
+-        if(categoriesForChildren.containsKey(name)) {//already contains category
++        if (categoriesForChildren.containsKey(name)) { //already contains category
+             return categoriesForChildren.get(name);
+-
+-        } else{//completely new
++        } else { //completely new
+             Features parentCategory = null;
+-            if(parent != null) parentCategory = parent.getCategory(name); //categories can have a parent
+-            Features newCat = new Features(parentCategory, name + "_" + featureName);
++            if (parent != null) parentCategory = parent.getCategory(name); //categories can have a parent
++            Features newCat;
++            if (parentCategory != null) {
++                newCat = new Features(parentCategory, name + "_" + featureName);
++            } else {
++                newCat = new Features(name + "_" + featureName, encoder, localIndexCount);
++            }
+             categoriesForChildren.put(name, newCat);
+             return newCat;
          }
+-
      }
--    private static List<Integer> getChildVisits(List<MCTSExecutor> tasks) {
-+    private List<Integer> getChildVisits(List<MCTSExecutor> tasks) {
-         List<Integer> childVisits = new ArrayList<>();
-         int min = Integer.MAX_VALUE;
-         for(MCTSExecutor task : tasks) {
-@@ -303,7 +285,7 @@ public class ComputerPlayerMCTS2 extends ComputerPlayerMCTS {
- 
-         for(int i = 0; i <  min; i++) {
-             int visitSum = 0;
--            for(int j = 0; j < 8; j++) {
-+            for(int j = 0; j < poolSize; j++) {
-                 visitSum += tasks.get(j).root.children.get(i).visits;
-             }
-             childVisits.add(visitSum);
-diff --git a/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/ComputerPlayerMinimaxOpponent.java b/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/ComputerPlayerMinimaxOpponent.java
-index 978c735ba5..d7c56d7862 100644
---- a/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/ComputerPlayerMinimaxOpponent.java
-+++ b/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/ComputerPlayerMinimaxOpponent.java
-@@ -129,9 +129,9 @@ public class ComputerPlayerMinimaxOpponent extends ComputerPlayer7{
-                         }
-                     }
-                 }
--                ComputerPlayerMCTS.macroState = ComputerPlayerMCTS.createCompleteMCTSGame(game);
--                ComputerPlayerMCTS.macroPlayerId = getId();
--                ComputerPlayerMCTS.lastAction = ability.copy();
-+                //ComputerPlayerMCTS.macroState = ComputerPlayerMCTS.createCompleteMCTSGame(game);
-+                //ComputerPlayerMCTS.macroPlayerId = getId();
-+                //ComputerPlayerMCTS.lastAction = ability.copy();
-                 this.activateAbility((ActivatedAbility) ability, game);
-                 if (ability.isUsesStack()) {
-                     usedStack = true;
-diff --git a/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/Features.java b/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/Features.java
-index fb4df63757..6e1bb42c50 100644
---- a/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/Features.java
-+++ b/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/Features.java
-@@ -7,7 +7,7 @@ import java.util.*;
  
- /**
-  *this hierarchical structure represents the mapping of every possible relevant feature encountered from a game state to
-- * an index on a 200000 dimension binary vector. the reduced form of this vector (4000) will be used as input for both a policy and
-+ * an index on a 200000 dimension binary vector. the reduced form of this vector (~6000) will be used as input for both a policy and
-  * value neural network. To see how game features are mapped look at StateEncoder.java this data structure only handles and stores the
-  * mappings
-  * @author willwroble
-@@ -75,7 +75,7 @@ public class Features  implements Serializable {
+     /**
+      * gets subfeatures at name or creates them if they dont exist
++     *
+      * @param name
+      * @return subfeature at name (never returns null)
+      */
+     public Features getSubFeatures(String name) {
          return getSubFeatures(name, true);
      }
++
      public Features getSubFeatures(String name, boolean passToParent) {
--        //first add as a normal binary feature
-+        //added as normal binary feature
+         //added as normal binary feature
          addFeature(name);
  
          int n = occurrences.get(name);
-@@ -149,19 +149,6 @@ public class Features  implements Serializable {
-         //usually add feature to parent/categories
-         if(parent != null && callParent && passToParent) {
-             parent.addNumericFeature(name, num);
--            //keep track of numerical sum for parents
--            /*
--            for(int i = 0; i < num; i++) {
--                parent.addFeature(name + "_SUM", false);
--            }
--            for(Features c : categories) {
--                c.addFeature(name);
--                //keep track of numerical sum for categories
--                for(int i = 0; i < num; i++) {
--                    c.addFeature(name + "_SUM", false);
--                }
--            }
--            */
-         }
- 
-         //also adds copy to number right below this one which will recursively increment the occurrences of each lesser feature
-diff --git a/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/NeuralNetEvaluator.java b/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/NeuralNetEvaluator.java
-index 317d4e93de..d9f0a8a722 100644
---- a/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/NeuralNetEvaluator.java
-+++ b/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/NeuralNetEvaluator.java
-@@ -108,7 +108,9 @@ public class NeuralNetEvaluator implements AutoCloseable {
-                 throw new RuntimeException("Missing '" + onnxValueOutputName + "' output from ONNX model");
+-        if(subFeatures.containsKey(name)) {//already contains feature
+-            if(subFeatures.get(name).containsKey(n)) {//contains count too
++        if (subFeatures.containsKey(name)) { //already contains feature
++            if (subFeatures.get(name).containsKey(n)) { //contains count too
+                 return subFeatures.get(name).get(n);
+-            } else {//new count
++            } else { //new count
+                 Map<Integer, Features> map = subFeatures.get(name);
+                 Features newSub = new Features(this, name + "_" + Integer.toString(n));
+                 map.put(n, newSub);
+                 return newSub;
              }
-             OnnxTensor valueTensor = (OnnxTensor) optV.get();
--            float value = ((float[][]) valueTensor.getValue())[0][0]; // Assumes value output shape [1, 1]
-+            float[] valueArray = (float[]) valueTensor.getValue();
-+            // Access the first (and only) element of the 1D array.
-+            float value = valueArray[0];
- 
-             return new InferenceResult(policy, value);
-         } catch (OrtException e) {
-diff --git a/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/ReplayBuffer.java b/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/ReplayBuffer.java
-index 903c6ad879..1b7b322fa7 100644
---- a/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/ReplayBuffer.java
-+++ b/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/ReplayBuffer.java
-@@ -1,6 +1,8 @@
--package org.mage.test.AI.RL;
-+package mage.player.ai;
- 
-+import mage.game.Game;
- import mage.game.GameState;
-+import mage.util.RandomUtil;
- 
- import java.io.Serializable;
- import java.util.*;
-@@ -13,7 +15,7 @@ import java.util.concurrent.ConcurrentLinkedDeque;
-  */
- public class ReplayBuffer implements Serializable {
-     private static final long serialVersionUID = 1L; // For serialization
--    private final Deque<GameState> buffer;
-+    private final Deque<Game> buffer;
-     private final int capacity;
-     private final Random random = new Random();
- 
-@@ -29,7 +31,7 @@ public class ReplayBuffer implements Serializable {
-      *
-      * @param state The GameState to add.
-      */
--    public synchronized void add(GameState state) {
-+    public synchronized void add(Game state) {
-         if (buffer.size() >= capacity) {
-             buffer.pollFirst(); // Remove the oldest element
-         }
-@@ -41,8 +43,8 @@ public class ReplayBuffer implements Serializable {
-      *
-      * @param states The collection of states from a completed game.
-      */
--    public void addAll(Collection<GameState> states) {
--        for (GameState state : states) {
-+    public void addAll(Collection<Game> states) {
-+        for (Game state : states) {
-             add(state); // Use the synchronized add method
+-        } else{//completely new
++        } else { //completely new
+             Map<Integer, Features> newMap = new HashMap<>();
+             Features newSub = new Features(this, name + "_1");
+             newMap.put(1, newSub);
+@@ -103,6 +130,7 @@ public class Features  implements Serializable {
+             return newSub;
          }
      }
-@@ -53,16 +55,16 @@ public class ReplayBuffer implements Serializable {
-      * @param batchSize The number of states to sample.
-      * @return A list containing the sampled GameStates. Returns an empty list if the buffer is empty.
++
+     /**
+      * similar to a subfeature a category will pool features within itself. however
+      * unlike subfeatures a feature can inherit multiple categories(ie card type and color).
+@@ -110,6 +138,7 @@ public class Features  implements Serializable {
+      * this function creates/finds the category with the given name and adds it as a
+      * category for this feature to pass up to, similar to the parent
+      * Categories should always be added before features
++     *
+      * @param name
       */
--    public List<GameState> sample(int batchSize) {
-+    public List<Game> sample(int batchSize) {
-         // Create a temporary list for random access, as Deque doesn't support get(index)
--        List<GameState> tempList = new ArrayList<>(buffer);
-+        List<Game> tempList = new ArrayList<>(buffer);
-         if (tempList.isEmpty()) {
-             return new ArrayList<>();
-         }
- 
--        List<GameState> sampleBatch = new ArrayList<>();
-+        List<Game> sampleBatch = new ArrayList<>();
-         for (int i = 0; i < batchSize; i++) {
--            int randomIndex = random.nextInt(tempList.size());
-+            int randomIndex = RandomUtil.nextInt(tempList.size());
-             sampleBatch.add(tempList.get(randomIndex));
-         }
-         return sampleBatch;
-diff --git a/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/StateEncoder.java b/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/StateEncoder.java
-index 1446d7f5d0..d96351032d 100644
---- a/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/StateEncoder.java
-+++ b/Mage.Server.Plugins/Mage.Player.AI.RL/src/mage/player/ai/StateEncoder.java
-@@ -36,7 +36,6 @@ import java.util.*;
- public class StateEncoder {
-     public static int indexCount;
-     public static int reducedIndexCount;
--    private int originalVectorSize;
-     private Features features;
-     public static Set<Integer> featureVector = new HashSet<>();
-     public UUID opponentID;
-@@ -47,9 +46,6 @@ public class StateEncoder {
-     public List<Boolean> activeStates = new ArrayList<>();
- 
-     public List<Double> stateScores = new ArrayList<>();
--    public static final int COMPRESSED_VECTOR_SIZE = 4000;
--    public static final int GLOBAL_FEATURE_COUNT = 100000;
--    public int initialSize = 0;
-     public int initialRawSize = 0;//original max index
-     public int mappingVersion = 0;
- 
-@@ -58,8 +54,7 @@ public class StateEncoder {
-     public StateEncoder() {
-         //using statics for convenience for now
-         indexCount = 0;
--        reducedIndexCount = 1; //pending features map to zero
--        originalVectorSize = 0;
-+        reducedIndexCount = 1;
-         features = new Features();
-         ignoreList = new HashSet<>();
+     public void addCategory(String name) {
+@@ -117,94 +146,105 @@ public class Features  implements Serializable {
+         Features categoryFeature = parent.getCategory(name);
+         categories.add(categoryFeature);
      }
-@@ -300,8 +295,14 @@ public class StateEncoder {
- 
-         //now do hand (cards are face down so only keep count of number of cards
-         // TODO: keep track of face up cards and exile
--        Cards hand = myPlayer.getHand();
--        features.addNumericFeature("OpponentCardsInHand", hand.size());
-+        if(opponentID==game.getPriorityPlayerId()) { //invert perspective
-+            Cards hand = myPlayer.getHand();
-+            Features handFeatures = features.getSubFeatures("Hand");
-+            processHand(hand, game, handFeatures);
-+        } else {
-+            Cards hand = myPlayer.getHand();
-+            features.addNumericFeature("OpponentCardsInHand", hand.size());
-+        }
- 
-     }
-     public void processManaPool(ManaPool mp, Game game,  Features f) {
-@@ -313,7 +314,35 @@ public class StateEncoder {
-         f.addNumericFeature("ColorlessMana", mp.getColorless());
-         //TODO: deal with conditional mana
-     }
--    public void processState(Game game) {
-+    public void processPhase(Game game) {
-+        switch (game.getTurnStepType()) {
-+            case UPKEEP:
-+                features.addFeature("Upkeep");
-+            case DRAW:
-+                features.addFeature("Draw");
-+            case PRECOMBAT_MAIN:
-+                features.addFeature("PreCombatMain");
-+            case BEGIN_COMBAT:
-+                features.addFeature("BeginCombat");
-+            case DECLARE_ATTACKERS:
-+                features.addFeature("DeclareAttackers");
-+            case DECLARE_BLOCKERS:
-+                features.addFeature("DeclareBlockers");
-+            case FIRST_COMBAT_DAMAGE:
-+                features.addFeature("FirstCombatDamage");
-+            case COMBAT_DAMAGE:
-+                features.addFeature("CombatDamage");
-+            case END_COMBAT:
-+                features.addFeature("EndCombat");
-+            case POSTCOMBAT_MAIN:
-+                features.addFeature("PostCombatMain");
-+            case END_TURN:
-+                features.addFeature("EndTurn");
-+            case CLEANUP:
-+               features.addFeature("Cleanup");
-+        }
-+    }
-+    public synchronized void processState(Game game) {
-         features.stateRefresh();
-         featureVector.clear();
- 
-@@ -323,6 +352,8 @@ public class StateEncoder {
-         features.addFeature(game.getPhase().getType().name());
-         if(game.isActivePlayer(myPlayerID)) features.addFeature("IsActivePlayer");
-         if(game.getPriorityPlayerId()==myPlayerID) features.addFeature("IsPriorityPlayer");
-+        //TODO: *IMPORTANT* ADD PHASE INFO
-+        processPhase(game);
-         features.addNumericFeature("LifeTotal", myPlayer.getLife());
-         if(myPlayer.canPlayLand()) features.addFeature("CanPlayLand"); //use features.addFeature(myPlayer.canPlayLand())
- 
-@@ -345,10 +376,14 @@ public class StateEncoder {
-         processGraveyard(gy, game, gyFeatures);
- 
-         //now do hand
--        Cards hand = myPlayer.getHand();
--        Features handFeatures = features.getSubFeatures("Hand");
--        processHand(hand, game, handFeatures);
--
-+        if(opponentID==game.getPriorityPlayerId()) { //invert perspective
-+            Cards hand = myPlayer.getHand();
-+            features.addNumericFeature("OpponentCardsInHand", hand.size());
-+        } else {
-+            Cards hand = myPlayer.getHand();
-+            Features handFeatures = features.getSubFeatures("Hand");
-+            processHand(hand, game, handFeatures);
-+        }
-         //TODO: add exile
- 
-         //lastly do opponent
-@@ -370,56 +405,6 @@ public class StateEncoder {
-         macroStateVectors.add(new HashSet<>(featureVector));
-         //activeStates.add(game.getActivePlayerId() == myPlayerID);
++
+     public void addFeature(String name) {
+         addFeature(name, true);
      }
--
--    /*
--    public void updateReducedVector() {
--        //map normal features
--        for(int i = 0; i < originalVectorSize; i++) {
--            if(!featureVector[i]) continue;
--            int reducedIndex = rawToReduced[i]; //pending features map to zero
--            reducedFeatureVector[reducedIndex] = true;
--        }
--        //update matrix for each pending feature
--        for (int f : pendingFeatures.keySet()) {
--            boolean[][] m = pendingFeatures.get(f);
--            boolean allIndependent = true;
--            for(int i = 1; i < m.length; i++) {
--                if(rawToReduced[i+f] != 0) continue;//only care to check un finalized features
--                boolean isIndependent = true;
--                for(int j = 0; j < m.length; j++) {
--                    m[i][j] = (featureVector[i+f] != featureVector[j+f]) || m[i][j]; //don't change if true
--                    if(rawToReduced[j+f] != 0 && !m[i][j]) {//compared to feature is finalized and they aren't independent
--                        isIndependent = false;
--                    }
--                }
--                if(isIndependent) {
--                    //finalize feature if independent (and hasn't been finalized)
--                    System.out.printf("pending feature at raw index %d has been finalized at reduced index %d\n", i+f, reducedIndexCount);
--                    rawToReduced[i+f] = reducedIndexCount;
--                    reducedFeatureVector[reducedIndexCount++] = featureVector[i+f]; //can be added silently (feature itself didn't fire)
--                } else {
--                    allIndependent = false;
--                }
--            }
--            if(allIndependent) {
--                pendingFeatures.remove(f);
--                System.out.printf("entire pending batch from %d has been successfully finalized\n", f);
--            }
--        }
--        //matrix for batch of new features
--        int batchSize = indexCount - originalVectorSize;
--        boolean[][] occurrenceMatrix = new boolean[batchSize][batchSize]; //maps if 2 features occurred independently for each pair
--        if(batchSize > 0) {
--            //add first new feature to reduced vector
--            System.out.printf("new reduced feature at raw index %d has been finalized at reduced index %d representing a batch of %d new features\n", originalVectorSize, reducedIndexCount, batchSize);
--            rawToReduced[originalVectorSize] = reducedIndexCount;
--            reducedFeatureVector[reducedIndexCount++] = true;
--            pendingFeatures.put(originalVectorSize, occurrenceMatrix); //pending features are stored in by their first feature in batch
--
--        }
--        //lastly update original size
--        originalVectorSize = indexCount;
--    }
-     /**
-      * Takes an array of raw indices, filters out those present in the ignoreList,
-      * and returns a new array of the remaining indices.
-@@ -452,7 +437,11 @@ public class StateEncoder {
++
+     public void addFeature(String name, boolean callParent) {
+         //usually add feature to parent/categories
+-        if(parent != null && callParent && passToParent) {
++        if (parent != null && callParent && passToParent) {
+             parent.addFeature(name);
+-            for(Features c : categories) {
++            for (Features c : categories) {
+                 c.addFeature(name);
+             }
          }
-         return filteredIndicesSet;
-     }
-+    public synchronized int[] getFinalActiveGlobalIndicesArray() {
-+        Set<Integer> out1 = getCompressedVector(featureVector);
-+        return out1.stream().mapToInt(Integer::intValue).toArray();
- 
-+    }
-     // Persist the persistent feature mapping
-     public void persistMapping(String filename) throws IOException {
-         features.globalIndexCount = indexCount;
-@@ -469,7 +458,6 @@ public class StateEncoder {
-         ignoreList = new HashSet<>(features.ignoreList);
-         rawToReduced = new HashMap<>(features.rawToReduced);
-         mappingVersion = features.version+1;
--        initialSize = indexCount - ignoreList.size();
-         initialRawSize = indexCount;
-     }
- }
-diff --git a/Mage.Server.Plugins/Mage.Player.AI/src/main/java/mage/player/ai/ComputerPlayer.java b/Mage.Server.Plugins/Mage.Player.AI/src/main/java/mage/player/ai/ComputerPlayer.java
-index 7c8b9e0e33..0ed2eac0a1 100644
---- a/Mage.Server.Plugins/Mage.Player.AI/src/main/java/mage/player/ai/ComputerPlayer.java
-+++ b/Mage.Server.Plugins/Mage.Player.AI/src/main/java/mage/player/ai/ComputerPlayer.java
-@@ -143,7 +143,7 @@ public class ComputerPlayer extends PlayerImpl {
  
-     @Override
-     public boolean choose(Outcome outcome, Target target, Ability source, Game game, Map<String, Serializable> options) {
--        if(PRINT_DECISION_FALLBACKS && name.equals("PlayerA")) System.out.println("choose: " + source.toString());
-+        if(PRINT_DECISION_FALLBACKS && name.equals("PlayerA")) System.out.println("choose: ");
-         if (log.isDebugEnabled()) {
-             log.debug("choose: " + outcome.toString() + ':' + target.toString());
-         }
-@@ -2156,15 +2156,18 @@ public class ComputerPlayer extends PlayerImpl {
-         // spell modes simulated by AI, see addModeOptions
-         // trigger modes chooses here
-         // TODO: add AI support to select best modes, current code uses first valid mode
-+        List<Mode> allModes = modes.getAvailableModes(source, game);
-+        //Collections.shuffle(allModes);
-         AvailableMode:
--        for (Mode mode : modes.getAvailableModes(source, game)) {
-+        for (Mode mode : allModes) {
-             for (UUID selectedModeId : modes.getSelectedModes()) {
-                 Mode selectedMode = modes.get(selectedModeId);
-                 if (selectedMode.getId().equals(mode.getId())) {
-                     continue AvailableMode;
-                 }
+-        if(features.containsKey(name)) {//has feature
+-            int count = occurrences.get(name)+1;
++        if (features.containsKey(name)) { //has feature
++            int count = occurrences.get(name) + 1;
+             occurrences.put(name, count);
+-            if(features.get(name).containsKey(count)) {//already contains feature at this count
+-                if(printOldFeatures) System.out.printf("Index %d is already reserved for feature %s at %d times in %s\n", features.get(name).get(count), name, count, featureName);
+-            } else {//contains feature but different count
+-                features.get(name).put(count, StateEncoder.indexCount++);
+-                if(printNewFeatures) System.out.printf("Feature %s exists but has not occurred %d times, reserving index %d for the %d occurrence of this feature in %s\n",
+-                        name, count, StateEncoder.indexCount-1, count, featureName);
++            if (features.get(name).containsKey(count)) { //already contains feature at this count
++                if (printOldFeatures)
++                    System.out.printf("Index %d is already reserved for feature %s at %d times in %s\n", features.get(name).get(count), name, count, featureName);
++            } else { //contains feature but different count
++                features.get(name).put(count, localIndexCount.getAndIncrement()); //  FIXED: Use atomic increment
++                if (printNewFeatures)
++                    System.out.printf("Feature %s exists but has not occurred %d times, reserving index %d for the %d occurrence of this feature in %s\n",
++                            name, count, localIndexCount.get() - 1, count, featureName);
              }
--            if (mode.getTargets().canChoose(source.getControllerId(), source, game)) { // and where targets are available
-+            if (mode.getTargets().canChoose(source.getControllerId(), source, game)) {
-+                // and where targets are available
-                 return mode;
-             }
-         }
-diff --git a/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/ChooseTargetNextAction.java b/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/ChooseTargetNextAction.java
-index dcc2fbcf0b..8a38280322 100644
---- a/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/ChooseTargetNextAction.java
-+++ b/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/ChooseTargetNextAction.java
-@@ -12,23 +12,26 @@ public class ChooseTargetNextAction implements MCTSNodeNextAction {
-     @Override
-     public List<MCTSNode> performNextAction(MCTSNode node, MCTSPlayer player, Game game, String fullStateValue) {
-         List<MCTSNode> children = new ArrayList<>();
--
-         // Get targets for the current ability
-         for (Set<UUID> targets: player.chooseTargetOptions) {
-             //create node to add option to
--            Game sim = node.macroState.createSimulationForAI();
-+            Game sim = game.getLastPriority().createSimulationForAI();
-             MCTSPlayer simPlayer2 = (MCTSPlayer) sim.getPlayer(player.getId());
--            MCTSPlayer simPlayer1 = (MCTSPlayer) sim.getPlayer(node.macroPlayerId);
--            simPlayer2.chooseTargetAction = new ArrayList<>(node.chooseTargetAction);
-+            MCTSPlayer simPlayer1 = (MCTSPlayer) sim.getPlayer(game.getLastPriorityPlayerId());
-+            simPlayer2.copyDialogues(player); //copy previous micro decisions
-             simPlayer2.chooseTargetAction.add(targets);
--            simPlayer1.activateAbility((ActivatedAbility) node.getAction(), sim);
-+            simPlayer1.activateAbility((ActivatedAbility) node.getAction().copy(), sim);
-             sim.resume();
--            MCTSNode newNode = new MCTSNode(node, sim, node.getAction());
--            newNode.combat = node.combat;
-+            MCTSNode newNode = new MCTSNode(node, sim, node.getAction().copy());
-             newNode.chooseTargetAction = new ArrayList<>(node.chooseTargetAction);
-             newNode.chooseTargetAction.add(targets);
-             children.add(newNode);
-         }
-         return children;
+-        } else {//completely new feature
++        } else { //completely new feature
+             occurrences.put(name, 1);
+             Map<Integer, Integer> n = new HashMap<>();
+-            n.put(1, StateEncoder.indexCount++);
++            n.put(1, localIndexCount.getAndIncrement());
+             features.put(name, n);
+-            if(printNewFeatures) System.out.printf("New feature %s discovered in %s, reserving index %d for this feature\n", name, featureName, n.get(1));
++            if (printNewFeatures)
++                System.out.printf("New feature %s discovered in %s, reserving index %d for this feature\n", name, featureName, n.get(1));
+         }
+-        StateEncoder.featureVector.add(features.get(name).get(occurrences.get(name)));
++        encoder.featureVector.add(features.get(name).get(occurrences.get(name)));
      }
 +
-+    @Override
-+    public void applyAction(MCTSNode node, MCTSPlayer player, Game game) {
-+        //do nothing for now
-+    }
- }
-diff --git a/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/ChooseTriggeredAbilityNextAction.java b/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/ChooseTriggeredAbilityNextAction.java
-index 7ce7689978..e873388c6c 100644
---- a/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/ChooseTriggeredAbilityNextAction.java
-+++ b/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/ChooseTriggeredAbilityNextAction.java
-@@ -1,32 +1,32 @@
- package mage.player.ai;
- 
--import mage.abilities.Ability;
- import mage.abilities.ActivatedAbility;
- import mage.game.Game;
--import mage.target.Target;
- 
--import java.util.*;
-+import java.util.ArrayList;
-+import java.util.List;
-+import java.util.Set;
-+import java.util.UUID;
- 
--public class ChooseTargetNextAction implements MCTSNodeNextAction {
-+public class ChooseTriggeredAbilityNextAction implements MCTSNodeNextAction {
- 
-     @Override
-     public List<MCTSNode> performNextAction(MCTSNode node, MCTSPlayer player, Game game, String fullStateValue) {
-         List<MCTSNode> children = new ArrayList<>();
-         // Get targets for the current ability
--        for (Set<UUID> targets: player.chooseTargetOptions) {
-+        for (Set<UUID> targets: player.chooseTriggeredOptions) {
-             //create node to add option to
--            Game sim = node.macroState.createSimulationForAI();
-+            Game sim = game.getLastPriority().createSimulationForAI();
-             MCTSPlayer simPlayer2 = (MCTSPlayer) sim.getPlayer(player.getId());
--            MCTSPlayer simPlayer1 = (MCTSPlayer) sim.getPlayer(node.macroPlayerId);
--            simPlayer2.chooseTargetAction = new ArrayList<>(node.chooseTargetAction);
--            simPlayer2.chooseTargetAction.add(targets);
-+            MCTSPlayer simPlayer1 = (MCTSPlayer) sim.getPlayer(game.getLastPriorityPlayerId());
-+            simPlayer2.copyDialogues(player);
-+            simPlayer2.chooseTriggeredAction.add(targets);
-             simPlayer1.activateAbility((ActivatedAbility) node.getAction().copy(), sim);
--            //MCTSNextActionFactory.strategyMap.get(simPlayer1.getNextAction()).applyAction(node,  simPlayer1, sim);
-             sim.resume();
-             MCTSNode newNode = new MCTSNode(node, sim, node.getAction().copy());
-             newNode.combat = node.combat;
--            newNode.chooseTargetAction = new ArrayList<>(node.chooseTargetAction);
--            newNode.chooseTargetAction.add(targets);
-+            newNode.chooseTriggeredAction = new ArrayList<>(node.chooseTriggeredAction);
-+            newNode.chooseTriggeredAction.add(targets);
-             children.add(newNode);
-         }
-         return children;
-diff --git a/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/ComputerPlayerMCTS.java b/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/ComputerPlayerMCTS.java
-index 5e697d29f4..10d439bfc4 100644
---- a/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/ComputerPlayerMCTS.java
-+++ b/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/ComputerPlayerMCTS.java
-@@ -18,6 +18,7 @@ import mage.util.ThreadUtils;
- import mage.util.XmageThreadFactory;
- import org.apache.log4j.Logger;
- 
-+import java.io.Serializable;
- import java.util.*;
- import java.util.concurrent.*;
- 
-@@ -31,21 +32,21 @@ public class ComputerPlayerMCTS extends ComputerPlayer {
-     protected static final double THINK_TIME_MULTIPLIER = 1.0;
-     protected static final boolean USE_MULTIPLE_THREADS = true;
- 
--    protected transient MCTSNode root;
-+    public transient MCTSNode root;
-     protected int maxThinkTime;
-     protected static final Logger logger = Logger.getLogger(ComputerPlayerMCTS.class);
--    protected int poolSize;
-+    public int poolSize = 8;
-     public Set<Set<UUID>> chooseTargetOptions = new HashSet<>();
-     public ArrayList<Set<UUID>> chosenChooseTargetActions = new ArrayList<>();
--    protected ExecutorService threadPoolSimulations = null;
--    public static Game macroState;
--    public static UUID macroPlayerId;
--    public static Ability lastAction;
-+    protected transient ExecutorService threadPoolSimulations = null;
-+    //public static Game macroState;
-+    //public static UUID macroPlayerId;
-+    //public static Ability lastAction;
-     public ComputerPlayerMCTS(String name, RangeOfInfluence range, int skill) {
-         super(name, range);
-         human = false;
-         maxThinkTime = (int) (skill * THINK_TIME_MULTIPLIER);
--        poolSize = Runtime.getRuntime().availableProcessors();
-+        //poolSize = 64;//Runtime.getRuntime().availableProcessors();
-     }
- 
-     protected ComputerPlayerMCTS(UUID id) {
-@@ -88,8 +89,6 @@ public class ComputerPlayerMCTS extends ComputerPlayer {
-             return false;
-         logLife(game);
-         logger.info(game.getTurn().getValue(game.getTurnNum())+"choose action:" + root.getAction() + " success ratio: " + root.getWinRatio());
--        macroState = createCompleteMCTSGame(game);
--        macroPlayerId = getId();
-         return true;
-     }
- 
-@@ -98,7 +97,6 @@ public class ComputerPlayerMCTS extends ComputerPlayer {
-             Game sim = createMCTSGame(game);
-             MCTSPlayer player = (MCTSPlayer) sim.getPlayer(playerId);
-             player.setNextAction(action);
--            player.isRoot = true;
-             root = new MCTSNode(playerId, sim);
-             player.chooseTargetOptions = chooseTargetOptions;
-             player.chooseTargetAction = new ArrayList<>(chosenChooseTargetActions);
-@@ -108,7 +106,6 @@ public class ComputerPlayerMCTS extends ComputerPlayer {
-         applyMCTS(game, action);
-         if (root != null && root.bestChild() != null) {
-             root = root.bestChild();
--            lastAction = root.action;
-             root.emancipate();
-         }
-     }
-@@ -172,11 +169,6 @@ public class ComputerPlayerMCTS extends ComputerPlayer {
+     public void addNumericFeature(String name, int num) {
+         addNumericFeature(name, num, true);
      }
-     @Override
-     public boolean chooseTarget(Outcome outcome, Target target, Ability source, Game game) {
--        if(false) return super.chooseTarget(outcome, target, source, game);
--//        if(root == null || root.children.isEmpty()) {
--//            System.out.println("chooseTarget: falling back");
--//            return super.chooseTarget(outcome, target, source, game);
--//        }
-         Set<UUID> possible = target.possibleTargets(getId(), game);
-         chooseTargetOptions.clear();
-         MCTSPlayer.getAllPossible(chooseTargetOptions, possible, target.copy(), source, game, getId());
-@@ -193,7 +185,16 @@ public class ComputerPlayerMCTS extends ComputerPlayer {
++
+     public void addNumericFeature(String name, int num, boolean callParent) {
+         //usually add feature to parent/categories
+-        if(parent != null && callParent && passToParent) {
++        if (parent != null && callParent && passToParent) {
+             parent.addNumericFeature(name, num);
          }
-         return target.isChosen(game);
-     }
--
-+    @Override
-+    public boolean choose(Outcome outcome, Target target, Ability source, Game game, Map<String, Serializable> options) {
-+        if(game.getTurnNum() > 1) {
-+            //reroute to mcts simulator
-+            return chooseTarget(outcome, target, source, game);
-+        } else {
-+            //reroute to default
-+            return super.choose(outcome, target, source, game, options);
-+        }
-+    }
-     protected long totalThinkTime = 0;
-     protected long totalSimulations = 0;
  
-@@ -356,6 +357,8 @@ public class ComputerPlayerMCTS extends ComputerPlayer {
-                 newPlayer.getLibrary().shuffle();
-                 for (int i = 0; i < handSize; i++) {
-                     Card card = newPlayer.getLibrary().drawFromTop(mcts);
-+                    assert (newPlayer.getLibrary().size() != 0);
-+                    assert (card != null);
-                     card.setZone(Zone.HAND, mcts);
-                     newPlayer.getHand().add(card);
+         //also adds copy to number right below this one which will recursively increment the occurrences of each lesser feature
+         //Integer nextHighest = numericFeatures.get(name).floorKey(num-1);
+-        if(num > 0) addNumericFeature(name, num-1, false);
++        if (num > 0) addNumericFeature(name, num - 1, false);
+ 
+-        if(numericFeatures.containsKey(name)) {
+-
+-            if(numericFeatures.get(name).containsKey(num)) {
+-                int count = numericOccurrences.get(name).get(num)+1;
++        if (numericFeatures.containsKey(name)) {
++            if (numericFeatures.get(name).containsKey(num)) {
++                int count = numericOccurrences.get(name).get(num) + 1;
+                 numericOccurrences.get(name).put(num, count);
+ 
+-                if(numericFeatures.get(name).get(num).containsKey(count)) {//already contains feature at this count
+-                    if(printOldFeatures) System.out.printf("Index %d is already reserved for numeric feature %s with %d at %d times in %s\n", numericFeatures.get(name).get(num).get(count), name, num, count, featureName);
+-                } else {//contains feature and num but different count
+-                    numericFeatures.get(name).get(num).put(count, StateEncoder.indexCount++);
+-                    if(printNewFeatures) System.out.printf("Numeric feature %s with %d exists but has not occurred %d times, reserving index %d for the %d occurrence of this feature in %s\n",
+-                            name, num, count, StateEncoder.indexCount-1, count, featureName);
++                if (numericFeatures.get(name).get(num).containsKey(count)) { //already contains feature at this count
++                    if (printOldFeatures)
++                        System.out.printf("Index %d is already reserved for numeric feature %s with %d at %d times in %s\n", numericFeatures.get(name).get(num).get(count), name, num, count, featureName);
++                } else { //contains feature and num but different count
++                    numericFeatures.get(name).get(num).put(count, localIndexCount.getAndIncrement());
++                    if (printNewFeatures)
++                        System.out.printf("Numeric feature %s with %d exists but has not occurred %d times, reserving index %d for the %d occurrence of this feature in %s\n",
++                                name, num, count, localIndexCount.get() - 1, count, featureName);
                  }
-@@ -364,6 +367,7 @@ public class ComputerPlayerMCTS extends ComputerPlayer {
+             } else { //contains category but not this number
+                 Map<Integer, Map<Integer, Integer>> map = numericFeatures.get(name);
+                 Map<Integer, Integer> subMap = new HashMap<>();
+-                subMap.put(1, StateEncoder.indexCount++);
++                subMap.put(1, localIndexCount.getAndIncrement());
+                 map.put(num, subMap);
+                 numericOccurrences.get(name).put(num, 1);
+-                if(printNewFeatures) System.out.printf("Numeric feature %s exists but has not occurred with %d, reserving index %d for this feature at %d in %s\n",
+-                        name, num, StateEncoder.indexCount-1, num, featureName);
++                if (printNewFeatures)
++                    System.out.printf("Numeric feature %s exists but has not occurred with %d, reserving index %d for this feature at %d in %s\n",
++                            name, num, localIndexCount.get() - 1, num, featureName);
              }
-             mcts.getState().getPlayers().put(copyPlayer.getId(), newPlayer);
-         }
-+        //mcts.setLastPriority(createCompleteMCTSGame(game.getLastPriority()));
-         mcts.resume();
-         return mcts;
-     }
-diff --git a/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/MCTSNextActionFactory.java b/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/MCTSNextActionFactory.java
-index be0730154d..db4c83c8b3 100644
---- a/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/MCTSNextActionFactory.java
-+++ b/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/MCTSNextActionFactory.java
-@@ -3,13 +3,14 @@ package mage.player.ai;
- import java.util.HashMap;
- 
- public class MCTSNextActionFactory {
--    private static final HashMap<MCTSPlayer.NextAction, MCTSNodeNextAction> strategyMap = new HashMap<>();
-+    public static final HashMap<MCTSPlayer.NextAction, MCTSNodeNextAction> strategyMap = new HashMap<>();
- 
-     static {
-         strategyMap.put(MCTSPlayer.NextAction.PRIORITY, new PriorityNextAction());
-         strategyMap.put(MCTSPlayer.NextAction.SELECT_BLOCKERS, new SelectBlockersNextAction());
-         strategyMap.put(MCTSPlayer.NextAction.SELECT_ATTACKERS, new SelectAttackersNextAction());
-         strategyMap.put(MCTSPlayer.NextAction.CHOOSE_TARGET, new ChooseTargetNextAction());
-+        strategyMap.put(MCTSPlayer.NextAction.CHOOSE_TRIGGERED_ABILITY, new ChooseTriggeredAbilityNextAction());
+-        } else {//completely new feature category
++        } else { //completely new feature category
+             TreeMap<Integer, Map<Integer, Integer>> newMap = new TreeMap<>();
+             Map<Integer, Integer> subMap = new HashMap<>();
+-            subMap.put(1, StateEncoder.indexCount++);
++            subMap.put(1, localIndexCount.getAndIncrement());
+             newMap.put(num, subMap);
+             numericFeatures.put(name, newMap);
+             TreeMap<Integer, Integer> newTreeMap = new TreeMap<>();
+             newTreeMap.put(num, 1);
+             numericOccurrences.put(name, newTreeMap);
+-            if(printNewFeatures) System.out.printf("New numeric feature %s discovered with %d in %s, reserving index %d for this feature at %d\n", name,
+-                    num, featureName, StateEncoder.indexCount-1, num);
++            if (printNewFeatures)
++                System.out.printf("New numeric feature %s discovered with %d in %s, reserving index %d for this feature at %d\n", name,
++                        num, featureName, localIndexCount.get() - 1, num);
+         }
+-        StateEncoder.featureVector.add(numericFeatures.get(name).get(num).get(numericOccurrences.get(name).get(num)));
++        encoder.featureVector.add(numericFeatures.get(name).get(num).get(numericOccurrences.get(name).get(num)));
      }
- 
-     public static MCTSNodeNextAction createNextAction(MCTSPlayer.NextAction nextAction) {
-diff --git a/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/MCTSNode.java b/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/MCTSNode.java
-index aa4f867d67..78c22e965b 100644
---- a/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/MCTSNode.java
-+++ b/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/MCTSNode.java
-@@ -12,6 +12,7 @@ import mage.abilities.PlayLandAbility;
- import mage.abilities.common.PassAbility;
- import mage.cards.Card;
- import mage.game.Game;
-+import mage.game.GameState;
- import mage.game.combat.Combat;
- import mage.game.turn.Step.StepPart;
- import mage.players.Player;
-@@ -45,13 +46,13 @@ public class MCTSNode {
-     public final List<MCTSNode> children = new ArrayList<>();
-     public Ability action;
-     public List<Set<UUID>> chooseTargetAction = new ArrayList<>();
--    private Game game;
--    public Game macroState;
-+    public List<Set<UUID>> chooseTriggeredAction = new ArrayList<>();
-+    private Game game;//only contains shared game
 +
-     public Combat combat;
-     private final String stateValue;
-     private final String fullStateValue;
-     public UUID playerId;
--    public UUID macroPlayerId;
-     private boolean terminal = false;
-     public UUID targetPlayer;
-     public int depth = 1;
-@@ -67,9 +68,7 @@ public class MCTSNode {
-         this.fullStateValue = game.getState().getValue(true, game);
-         this.stackIsEmpty = game.getStack().isEmpty();
-         this.terminal = game.checkIfGameIsOver();
--        this.macroState = ComputerPlayerMCTS.macroState;
--        this.macroPlayerId = ComputerPlayerMCTS.macroPlayerId;
--        this.action = ComputerPlayerMCTS.lastAction;
-+        this.action = game.getLastPriorityAction();
-         setPlayer();
-         nodeCount = 1;
- //        logger.info(this.stateValue);
-@@ -84,8 +83,6 @@ public class MCTSNode {
-         this.terminal = game.checkIfGameIsOver();
-         this.parent = parent;
-         this.action = action;
--        this.macroState = parent.macroState;
--        this.macroPlayerId = parent.playerId;
- 
-         setPlayer();
-         nodeCount++;
-@@ -95,19 +92,19 @@ public class MCTSNode {
-     protected MCTSNode(MCTSNode parent, Game game, Combat combat) {
-         this.targetPlayer = parent.targetPlayer;
-         this.game = game;
-+        //this.gameState = game.getState().copy();
-         this.combat = combat;
-         this.stateValue = game.getState().getValue(game, targetPlayer);
-         this.fullStateValue = game.getState().getValue(true, game);
-         this.stackIsEmpty = game.getStack().isEmpty();
-         this.terminal = game.checkIfGameIsOver();
-         this.parent = parent;
--        this.macroState = parent.macroState;
--        this.macroPlayerId = parent.playerId;
- 
-         setPlayer();
-         nodeCount++;
- //        logger.info(this.stateValue);
-     }
-+    //dont use
-     protected MCTSNode(MCTSNode node) {
-         combat = null; action = null; game = null;
-         if(node.combat != null) combat = node.combat.copy();
-@@ -135,15 +132,22 @@ public class MCTSNode {
- 
-     }
-     private void setPlayer() {
--        if (game.getStep().getStepPart() == StepPart.PRIORITY) {
--            playerId = game.getPriorityPlayerId();
--        } else {
--            if (game.getTurnStepType() == PhaseStep.DECLARE_BLOCKERS) {
--                playerId = game.getCombat().getDefenders().iterator().next();
--            } else {
--                playerId = game.getActivePlayerId();
--            }
-+        //System.out.println("this happening");
-+        for (Player p : game.getPlayers().values()) {
-+            MCTSPlayer mctsP = (MCTSPlayer) p;
-+            if(mctsP.lastToAct) playerId = p.getId();
-+            return;
-         }
-+        assert (false);
-+//        if (game.getStep().getStepPart() == StepPart.PRIORITY) {
-+//            playerId = game.getPriorityPlayerId();
-+//        } else {
-+//            if (game.getTurnStepType() == PhaseStep.DECLARE_BLOCKERS) {
-+//                playerId = game.getCombat().getDefenders().iterator().next();
-+//            } else {
-+//                playerId = game.getActivePlayerId();
-+//            }
-+//        }
-     }
-     public MCTSNode select(UUID targetPlayerId) {
-         // Singlechild shortcut
-@@ -247,7 +251,6 @@ public class MCTSNode {
-             }
-             if (!children.isEmpty()) {
-                 game = null;
--                macroState = null;
+     public void stateRefresh() {
+         categories.clear();
+         occurrences.replaceAll((k, v) -> 0);
+-        for(String c : numericOccurrences.keySet()) {
++        for (String c : numericOccurrences.keySet()) {
+             numericOccurrences.get(c).replaceAll((k, v) -> 0);
+         }
+-        for(String n : subFeatures.keySet()) {
+-            for(int i : subFeatures.get(n).keySet()) {
++        for (String n : subFeatures.keySet()) {
++            for (int i : subFeatures.get(n).keySet()) {
+                 subFeatures.get(n).get(i).stateRefresh();
              }
          }
-     }
-@@ -436,6 +439,7 @@ public class MCTSNode {
-             MCTSNode current = queue.remove();
-             if (current.stateValue.equals(state) && current.chooseTargetAction.equals(chosen))
-                 return current;
-+            //System.out.printf("MISMATCH: %s\n %s\n",current.stateValue, state);
-             for (MCTSNode child: current.children) {
-                 queue.add(child);
-             }
-@@ -474,7 +478,7 @@ public class MCTSNode {
-                 for (MCTSNode child : tempChildren) {
-                     if (mergeChild.action != null && child.action != null) {
-                         if (mergeChild.action.toString().equals(child.action.toString())) {
--                            if (!mergeChild.stateValue.equals(child.stateValue) || !merge.chooseTargetAction.equals(chooseTargetAction)) {
-+                            if (!mergeChild.stateValue.equals(child.stateValue) || !mergeChild.chooseTargetAction.equals(child.chooseTargetAction)) {
-                                 // Record mismatch if needed; skip merge.
-                             } else {
-                                 // Recursively merge the matching child.
-@@ -485,8 +489,9 @@ public class MCTSNode {
-                         }
-                     } else if (mergeChild.combat != null && child.combat != null &&
-                             mergeChild.combat.getValue().equals(child.combat.getValue())) {
--                        if (!mergeChild.stateValue.equals(child.stateValue) || !merge.chooseTargetAction.equals(chooseTargetAction)) {
-+                        if (!mergeChild.stateValue.equals(child.stateValue) || !mergeChild.chooseTargetAction.equals(child.chooseTargetAction)) {
-                             // Record mismatch if needed.
-+
-                         } else {
-                             child.merge(mergeChild);
-                             merged = true;
-@@ -625,32 +630,10 @@ public class MCTSNode {
-         if(children.isEmpty()) return 0;
-         return visits/children.size();
-     }
--    public int maxVisits() {
--        int max = -1;
--        for(MCTSNode n : children) {
--            if(n.visits > max) {
--                max = n.visits;
--            }
--        }
--        return max;
--    }
--    public int diffVisits() {
--        int max = -1;
--        int max2 = -1;//second highest
--        for(MCTSNode n : children) {
--            if(n.visits > max) {
--                max2 = max;
--                max = n.visits;
--            } else if(n.visits > max2) {
--                max2 = n.visits;
--            }
--        }
--        return max-max2;
--    }
-     public Game getGame() {
-+        //game.getState().restore(gameState);
-         return game;
-     }
--
-     public static void logHitMiss() {
-         if (USE_ACTION_CACHE) {
-             StringBuilder sb = new StringBuilder();
-diff --git a/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/MCTSNodeNextAction.java b/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/MCTSNodeNextAction.java
-index befa16c515..494912df8a 100644
---- a/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/MCTSNodeNextAction.java
-+++ b/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/MCTSNodeNextAction.java
-@@ -6,4 +6,5 @@ import java.util.List;
- 
- public interface MCTSNodeNextAction {
-     List<MCTSNode> performNextAction(MCTSNode node, MCTSPlayer player, Game game, String fullStateValue);
-+    void applyAction(MCTSNode node, MCTSPlayer player, Game game);
- }
-diff --git a/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/MCTSPlayer.java b/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/MCTSPlayer.java
-index 8d3f1dc232..a2a7bce9aa 100644
---- a/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/MCTSPlayer.java
-+++ b/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/MCTSPlayer.java
-@@ -6,6 +6,7 @@ import mage.Mana;
- import mage.abilities.Ability;
- import mage.abilities.ActivatedAbility;
- import mage.abilities.SpellAbility;
-+import mage.abilities.TriggeredAbility;
- import mage.abilities.common.PassAbility;
- import mage.abilities.costs.Costs;
- import mage.abilities.costs.mana.GenericManaCost;
-@@ -24,6 +25,7 @@ import mage.target.Target;
- import mage.target.TargetCard;
- import org.apache.log4j.Logger;
- 
-+import java.io.Serializable;
- import java.util.*;
- import java.util.concurrent.ConcurrentLinkedQueue;
- 
-@@ -37,19 +39,20 @@ import java.util.concurrent.ConcurrentLinkedQueue;
-  */
- public class MCTSPlayer extends ComputerPlayer {
- 
--
-+    public boolean lastToAct =  false;
-     private NextAction nextAction;
--    public boolean isRoot = false;
-     public long dirichletSeed = 0;
-     public Set<Set<UUID>> chooseTargetOptions = new HashSet<>();
-     public List<Set<UUID>> chooseTargetAction = new ArrayList<>();
-+    public Set<Set<UUID>> chooseTriggeredOptions = new HashSet<>();
-+    public List<Set<UUID>> chooseTriggeredAction = new ArrayList<>();
- 
-     private int chooseTargetCount = 0;
- 
- 
- 
-     public enum NextAction {
--                PRIORITY, SELECT_ATTACKERS, SELECT_BLOCKERS, CHOOSE_TARGET
-+                PRIORITY, SELECT_ATTACKERS, SELECT_BLOCKERS, CHOOSE_TARGET, CHOOSE_TRIGGERED_ABILITY
-     }
- 
-     public MCTSPlayer(UUID id) {
-@@ -59,6 +62,7 @@ public class MCTSPlayer extends ComputerPlayer {
-     public MCTSPlayer(final MCTSPlayer player) {
-         super(player);
-         this.nextAction = player.nextAction;
-+        this.lastToAct = player.lastToAct;
-     }
- 
-     @Override
-@@ -66,6 +70,11 @@ public class MCTSPlayer extends ComputerPlayer {
-         return new MCTSPlayer(this);
-     }
- 
-+    public void copyDialogues(MCTSPlayer player) {
-+        this.chooseTargetAction = new ArrayList<>(player.chooseTargetAction);
-+        this.chooseTriggeredAction = new ArrayList<>(player.chooseTriggeredAction);
-+    }
-+
-     protected List<ActivatedAbility> getPlayableAbilities(Game game) {
-         List<ActivatedAbility> playables = getPlayable(game, true);
-         ManaOptions availableMana = getManaAvailable(game);
-@@ -208,6 +217,11 @@ public class MCTSPlayer extends ComputerPlayer {
-     @Override
-     public boolean priority(Game game) {
-         game.pause();
-+        for(Player p : game.getPlayers().values()) {//if either player already acted, respect that.
-+            MCTSPlayer mctsP = (MCTSPlayer) p;
-+            if(mctsP.lastToAct) return false;
-+        }
-+        lastToAct = true;
-         nextAction = NextAction.PRIORITY;
-         return false;
-     }
-@@ -215,12 +229,14 @@ public class MCTSPlayer extends ComputerPlayer {
-     @Override
-     public void selectAttackers(Game game, UUID attackingPlayerId) {
-         game.pause();
-+        lastToAct = true;
-         nextAction = NextAction.SELECT_ATTACKERS;
-     }
- 
-     @Override
-     public void selectBlockers(Ability source, Game game, UUID defendingPlayerId) {
-         game.pause();
-+        lastToAct = true;
-         nextAction = NextAction.SELECT_BLOCKERS;
-     }
-     public static void getAllPossible(Set<Set<UUID>> out, Set<UUID> possible, Target target, Ability source, Game game, UUID myID) {
-@@ -240,10 +256,9 @@ public class MCTSPlayer extends ComputerPlayer {
-     }
-     @Override
-     public boolean chooseTarget(Outcome outcome, Target target, Ability source, Game game) {
--        if(false) return super.chooseTarget(outcome, target, source, game);
--        System.out.println("CALLING CHOOSE TARGET");
-+        //System.out.println("chooseTarget: " + source.toString());
-+        System.out.println("CALLING CHOOSE TARGET: " + (source == null ? "null" : source.toString()));
-         if(chooseTargetCount < chooseTargetAction.size()) {
--            System.out.println("is this happening");
-             for(UUID id : chooseTargetAction.get(chooseTargetCount)) {
-                 if(!target.canTarget(getId(), id, source, game)) continue;
-                 target.addTarget(id, source, game);
-@@ -256,7 +271,17 @@ public class MCTSPlayer extends ComputerPlayer {
-         Set<UUID> possible = target.possibleTargets(getId(), game);
-         getAllPossible(chooseTargetOptions, possible, target.copy(), source, game, getId());
-         game.pause();
-+        for(Player p : game.getPlayers().values()) {//if either player already acted, respect that.
-+            MCTSPlayer mctsP = (MCTSPlayer) p;
-+            if(mctsP.lastToAct) return super.chooseTarget(outcome, target, source, game);
-+        }
-+        lastToAct = true;
-         nextAction = NextAction.CHOOSE_TARGET;
--        return false;
-+        return super.chooseTarget(outcome, target, source, game);
-+    }
-+    @Override
-+    public boolean choose(Outcome outcome, Target target, Ability source, Game game, Map<String, Serializable> options) {
-+        //reroute to chooseTarget
-+        return chooseTarget(outcome, target, source, game);
-     }
- }
-diff --git a/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/PriorityNextAction.java b/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/PriorityNextAction.java
-index 076a23aa2b..0861c0d9bb 100644
---- a/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/PriorityNextAction.java
-+++ b/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/PriorityNextAction.java
-@@ -3,6 +3,7 @@ package mage.player.ai;
- import mage.abilities.Ability;
- import mage.abilities.ActivatedAbility;
- import mage.game.Game;
-+import mage.game.GameState;
- 
- import java.util.ArrayList;
- import java.util.List;
-@@ -11,7 +12,6 @@ public class PriorityNextAction implements MCTSNodeNextAction{
- 
-     @Override
-     public List<MCTSNode> performNextAction(MCTSNode node, MCTSPlayer player, Game game, String fullStateValue) {
--        node.macroState = game;
-         List<MCTSNode> children = new ArrayList<>();
-         List<Ability> abilities;
-         if (!MCTSNode.USE_ACTION_CACHE)
-@@ -21,12 +21,20 @@ public class PriorityNextAction implements MCTSNodeNextAction{
-         for (Ability ability: abilities) {
-             Game sim = game.createSimulationForAI();
-             MCTSPlayer simPlayer = (MCTSPlayer) sim.getPlayer(player.getId());
--            boolean success = simPlayer.activateAbility((ActivatedAbility)ability, sim);
--            if(!success) continue;//failsafe
-+            boolean success = simPlayer.activateAbility((ActivatedAbility)ability.copy(), sim);
-+            if(!success) {
-+                System.out.println("PRIORITY FAILSAFE TRIGGERED: " + ability.toString());
-+                continue;//failsafe
-+            }
-             sim.resume();
--            children.add(new MCTSNode(node, sim, ability));
-+            children.add(new MCTSNode(node, sim, ability.copy()));
+@@ -213,6 +253,78 @@ public class Features  implements Serializable {
          }
- 
-         return children;
      }
-+
-+    @Override
-+    public void applyAction(MCTSNode node, MCTSPlayer player, Game game) {
-+        player.activateAbility((ActivatedAbility) node.getAction(), game);
-+    }
- }
-diff --git a/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/SelectAttackersNextAction.java b/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/SelectAttackersNextAction.java
-index b5f7fcc439..bb1aba9393 100644
---- a/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/SelectAttackersNextAction.java
-+++ b/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/SelectAttackersNextAction.java
-@@ -4,6 +4,7 @@ import mage.game.Game;
- 
- import java.util.ArrayList;
- import java.util.List;
-+import java.util.Set;
- import java.util.UUID;
- 
- import static mage.player.ai.MCTSNode.getAttacks;
-@@ -11,7 +12,6 @@ import static mage.player.ai.MCTSNode.getAttacks;
- public class SelectAttackersNextAction implements MCTSNodeNextAction{
-     @Override
-     public List<MCTSNode> performNextAction(MCTSNode node, MCTSPlayer player, Game game, String fullStateValue) {
--        node.macroState = game;
-         List<MCTSNode> children = new ArrayList<>();
-         List<List<UUID>> attacks;
-         if (!MCTSNode.USE_ACTION_CACHE)
-@@ -31,4 +31,13 @@ public class SelectAttackersNextAction implements MCTSNodeNextAction{
  
-         return children;
-     }
++    /**
++     * always discard f after merging
++     *
++     * @param f object to merge with
++     */
++    public synchronized void merge(Features f) {
++        if (this == f) return;
 +
-+    @Override
-+    public void applyAction(MCTSNode node, MCTSPlayer player, Game game) {
-+        UUID defenderId = game.getOpponents(player.getId()).iterator().next();
-+        Set<UUID> attack = node.combat.getAttackers();
-+        for (UUID attackerId: attack) {
-+            player.declareAttacker(attackerId, defenderId, game, false);
++        // Normal features
++        for (String n : f.features.keySet()) {
++            Map<Integer, Integer> thisOccurrenceMap = this.features.computeIfAbsent(n, k -> new HashMap<>());
++            this.occurrences.putIfAbsent(n, 0);
++            for (int i : f.features.get(n).keySet()) {
++                if (!thisOccurrenceMap.containsKey(i)) {
++                    thisOccurrenceMap.put(i, this.localIndexCount.getAndIncrement());
++                }
++            }
 +        }
-+    }
- }
-diff --git a/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/SelectBlockersNextAction.java b/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/SelectBlockersNextAction.java
-index a92c7a6f14..a524d92397 100644
---- a/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/SelectBlockersNextAction.java
-+++ b/Mage.Server.Plugins/Mage.Player.AIMCTS/src/mage/player/ai/SelectBlockersNextAction.java
-@@ -12,7 +12,6 @@ import static mage.player.ai.MCTSNode.getBlocks;
- public class SelectBlockersNextAction implements MCTSNodeNextAction{
-     @Override
-     public List<MCTSNode> performNextAction(MCTSNode node, MCTSPlayer player, Game game, String fullStateValue) {
--        node.macroState = game;
-         List<MCTSNode> children = new ArrayList<>();
-         List<List<List<UUID>>> blocks;
-         if (!MCTSNode.USE_ACTION_CACHE)
-@@ -24,6 +23,7 @@ public class SelectBlockersNextAction implements MCTSNodeNextAction{
-             MCTSPlayer simPlayer = (MCTSPlayer) sim.getPlayer(player.getId());
-             List<CombatGroup> groups = sim.getCombat().getGroups();
-             for (int i = 0; i < groups.size(); i++) {
-+                if(groups.get(i).getAttackers().isEmpty()) continue;//failsafe
-                 if (i < block.size()) {
-                     for (UUID blockerId : block.get(i)) {
-                         simPlayer.declareBlocker(simPlayer.getId(), blockerId, groups.get(i).getAttackers().get(0), sim);
-@@ -36,4 +36,18 @@ public class SelectBlockersNextAction implements MCTSNodeNextAction{
- 
-         return children;
-     }
 +
-+    @Override
-+    public void applyAction(MCTSNode node, MCTSPlayer player, Game game) {
-+        List<CombatGroup> groups = game.getCombat().getGroups();
-+        List<CombatGroup> block = node.combat.getGroups();
-+        for (int i = 0; i < groups.size(); i++) {
-+            if(groups.get(i).getAttackers().isEmpty()) continue;//failsafe
-+            if (i < block.size()) {
-+                for (UUID blockerId : block.get(i).getBlockers()) {
-+                    player.declareBlocker(player.getId(), blockerId, groups.get(i).getAttackers().get(0), game);
++        // Numeric features
++        for (String n : f.numericFeatures.keySet()) {
++            TreeMap<Integer, Map<Integer, Integer>> thisNumericMap = this.numericFeatures.computeIfAbsent(n, k -> new TreeMap<>());
++            this.numericOccurrences.putIfAbsent(n, new TreeMap<>());
++            for (int num : f.numericFeatures.get(n).keySet()) {
++                Map<Integer, Integer> thisOccurrenceMap = thisNumericMap.computeIfAbsent(num, k -> new HashMap<>());
++                this.numericOccurrences.get(n).putIfAbsent(num, 0);
++                for (int i  : f.numericFeatures.get(n).get(num).keySet()) {
++                    if (!thisOccurrenceMap.containsKey(i)) {
++                        thisOccurrenceMap.put(i, this.localIndexCount.getAndIncrement());
++                    }
 +                }
 +            }
 +        }
-+    }
- }
-diff --git a/Mage.Tests/features_mapping.ser b/Mage.Tests/features_mapping.ser
-index 3f3d2b16ed..c99685f0f0 100644
-Binary files a/Mage.Tests/features_mapping.ser and b/Mage.Tests/features_mapping.ser differ
-diff --git a/Mage.Tests/src/test/java/org/mage/test/AI/RL/GenerateMappings.java b/Mage.Tests/src/test/java/org/mage/test/AI/RL/GenerateMappings.java
-index 1dde5c0a0f..9b7131649e 100644
---- a/Mage.Tests/src/test/java/org/mage/test/AI/RL/GenerateMappings.java
-+++ b/Mage.Tests/src/test/java/org/mage/test/AI/RL/GenerateMappings.java
-@@ -23,29 +23,8 @@ import java.nio.file.Paths;
- import java.util.*;
- 
- public class GenerateMappings extends MinimaxVectorExtractionTests {
--    private String deckNameA = "UWTempo.dck"; //simplegreen, UWTempo
--    private String deckNameB = "simplegreen.dck";
--    //private StateEncoder encoder;
--    private int seed;
--    //private Set<Integer> ignore;
--    //private Map<String, Integer> actions;
--    // File where the persistent mapping is stored
--    private static final String MAPPING_FILE = "features_mapping.ser";
--    private static final String ACTIONS_FILE = "actions_mapping.ser";
- 
- 
--    @Override
--    public List<String> getFullSimulatedPlayers() {
--        return Arrays.asList("PlayerA", "PlayerB");
--    }
--
--    @Override
--    protected Game createNewGameAndPlayers() throws GameException, FileNotFoundException {
--        Game game = new TwoPlayerDuel(MultiplayerAttackOption.LEFT, RangeOfInfluence.ONE, MulliganType.GAME_DEFAULT.getMulligan(0), 60, 20, 7);
--        playerA = createPlayer(game, "PlayerA", "C:\\Users\\WillWroble\\Documents\\" + deckNameA);
--        playerB = createPlayer(game, "PlayerB", "C:\\Users\\WillWroble\\Documents\\" + deckNameB);
--        return game;
--    }
-     @Override
-     protected TestPlayer createPlayer(String name, RangeOfInfluence rangeOfInfluence) {
-         if (getFullSimulatedPlayers().contains(name)) {
-@@ -63,6 +42,7 @@ public class GenerateMappings extends MinimaxVectorExtractionTests {
-         }
-         return super.createPlayer(name, rangeOfInfluence);
-     }
-+    @Override
-     public void init_seed() {
-         seed = RandomUtil.nextInt();
-         //seed = -1421792887;
-@@ -70,57 +50,13 @@ public class GenerateMappings extends MinimaxVectorExtractionTests {
-         System.out.printf("USING SEED: %d\n", seed);
-         RandomUtil.setSeed(seed);
-     }
--    @Before
--    public void init_encoder() {
--        init_seed();
--        System.out.println("Setting up encoder");
--        encoder = new StateEncoder();
--
--        // Try to load the persistent mapping from file
--        File mappingFile = new File(MAPPING_FILE);
--        if (mappingFile.exists()) {
--            try {
--                encoder.loadMapping(MAPPING_FILE);
--                System.out.println("Loaded persistent mapping from " + MAPPING_FILE);
--            } catch (IOException | ClassNotFoundException e) {
--                System.out.println("Failed to load mapping. Starting with a fresh mapping.");
--            }
--        } else {
--            System.out.println("No persistent mapping found. Starting fresh.");
--        }
--        //try to load persistent action mappings from file
--        File actionsFile = new File(ACTIONS_FILE);
--        if (actionsFile.exists()) {
--            try {
--                ActionEncoder.actionMap = (Map<String, Integer>) loadObject(ACTIONS_FILE);
--                ActionEncoder.indexCount = ActionEncoder.actionMap.size();
--                System.out.println("Loaded persistent mapping from " + ACTIONS_FILE);
--            } catch (IOException | ClassNotFoundException e) {
--                System.out.println("Failed to load mapping. Starting with a fresh mapping.");
--            }
--        } else {
--            System.out.println("No persistent mapping found. Starting fresh.");
--        }
--
--        set_encoder();
--    }
-+    @Override
-     public void set_encoder() {
-         ComputerPlayerPureMCTS pmc = (ComputerPlayerPureMCTS)playerA.getComputerPlayer();
-         pmc.setEncoder(encoder);
-         encoder.setAgent(playerA.getId());
-         encoder.setOpponent(playerB.getId());
-     }
--    public void reset_game() {
--        try {
--            reset();
--        } catch (FileNotFoundException e) {
--            throw new RuntimeException(e);
--        } catch (GameException e) {
--            throw new RuntimeException(e);
--        }
--        set_encoder();
--
--    }
-     @Test
-     public void print_current_ignore_list() {
-         System.out.printf("IGNORE LIST SIZE: %d\n", encoder.ignoreList.size());
-@@ -170,30 +106,4 @@ public class GenerateMappings extends MinimaxVectorExtractionTests {
-         }
-         System.out.println();
-     }
--    public void persistData() {
--        try {
--            encoder.persistMapping(MAPPING_FILE);
--            System.out.printf("Persisted feature mapping to %s\n", MAPPING_FILE);
--            //saveObject(ignore, IGNORE_FILE);
--            //System.out.printf("Persisted ignore list to %s\n", IGNORE_FILE);
--            saveObject(new HashMap<>(ActionEncoder.actionMap), ACTIONS_FILE);
--            System.out.printf("Persisted action mapping to %s\n", ACTIONS_FILE);
--        } catch (IOException e) {
--            e.printStackTrace();
--        }
--    }
--
--    // Method to save a Serializable object to a file
--    public static void saveObject(Object obj, String fileName) throws IOException {
--        try (ObjectOutputStream out = new ObjectOutputStream(Files.newOutputStream(Paths.get(fileName)))) {
--            out.writeObject(obj);
--        }
--    }
--
--    // Method to load a Serializable object from a file
--    public static Object loadObject(String fileName) throws IOException, ClassNotFoundException {
--        try (ObjectInputStream in = new ObjectInputStream(Files.newInputStream(Paths.get(fileName)))) {
--            return in.readObject();
--        }
--    }
- }
-diff --git a/Mage.Tests/src/test/java/org/mage/test/AI/RL/MCTS2Tests.java b/Mage.Tests/src/test/java/org/mage/test/AI/RL/MCTS2Tests.java
-index 7c941506cc..b9d287b47c 100644
---- a/Mage.Tests/src/test/java/org/mage/test/AI/RL/MCTS2Tests.java
-+++ b/Mage.Tests/src/test/java/org/mage/test/AI/RL/MCTS2Tests.java
-@@ -38,8 +38,8 @@ public class MCTS2Tests extends CardTestPlayerBaseAI {
-     @Override
-     protected Game createNewGameAndPlayers() throws GameException, FileNotFoundException {
-         Game game = new TwoPlayerDuel(MultiplayerAttackOption.LEFT, RangeOfInfluence.ONE, MulliganType.GAME_DEFAULT.getMulligan(0), 60, 20, 7);
--        playerA = createPlayer(game, "PlayerA", "C:\\Users\\WillWroble\\Documents\\" + deckNameA);
--        playerB = createPlayer(game, "PlayerB", "C:\\Users\\WillWroble\\Documents\\" + deckNameB);
-+        playerA = createPlayer(game, "PlayerA", "C:\\Users\\owner\\Documents\\" + deckNameA);
-+        playerB = createPlayer(game, "PlayerB", "C:\\Users\\owner\\Documents\\" + deckNameB);
-         return game;
-     }
-     @Override
-diff --git a/Mage.Tests/src/test/java/org/mage/test/AI/RL/MCTS2WithNNTests.java b/Mage.Tests/src/test/java/org/mage/test/AI/RL/MCTS2WithNNTests.java
-index f910217717..c8f383299a 100644
---- a/Mage.Tests/src/test/java/org/mage/test/AI/RL/MCTS2WithNNTests.java
-+++ b/Mage.Tests/src/test/java/org/mage/test/AI/RL/MCTS2WithNNTests.java
-@@ -1,60 +1,26 @@
- package org.mage.test.AI.RL;
- 
--import ai.onnxruntime.OrtException;
--import mage.constants.MultiplayerAttackOption;
- import mage.constants.PhaseStep;
- import mage.constants.RangeOfInfluence;
--import mage.game.Game;
--import mage.game.GameException;
--import mage.game.TwoPlayerDuel;
--import mage.game.mulligan.MulliganType;
-+import mage.constants.Zone;
- import mage.player.ai.*;
- import mage.util.RandomUtil;
- import org.junit.After;
- import org.junit.Before;
- import org.junit.Test;
--import org.mage.test.player.TestComputerPlayer7;
--import org.mage.test.player.TestComputerPlayer8;
--import org.mage.test.player.TestComputerPlayerMonteCarlo2;
--import org.mage.test.player.TestPlayer;
--import org.mage.test.serverside.base.CardTestPlayerBaseAI;
-+import org.mage.test.player.*;
- 
- import java.io.*;
--import java.nio.file.Files;
--import java.nio.file.Paths;
- import java.util.*;
- 
- public class MCTS2WithNNTests extends MinimaxVectorExtractionTests {
--    private String deckNameA = "UWTempo.dck"; //simplegreen, UWTempo
--    private String deckNameB = "simplegreen.dck";
--    private List<LabeledState> labeledStates = new ArrayList<>();
--    private List<LabeledState> labeledStateBatch = new ArrayList<>();
--    //private StateEncoder encoder;
--    //private Set<Integer> ignore;
--    //private Map<String, Integer> actions;
--    // File where the persistent mapping is stored
--    private static final String MAPPING_FILE = "features_mapping.ser";
--    private static final String ACTIONS_FILE = "actions_mapping.ser";
--    private static final String TRAIN_OUT_FILE = "training.bin";
--    private static final String TEST_OUT_FILE = "testing.bin";
--    private int seed;
- 
--
--
--    @Override
--    public List<String> getFullSimulatedPlayers() {
--        return Arrays.asList("PlayerA", "PlayerB");
--    }
-+    public static final String REPLAY_BUFFER_FILE = "replay_buffer.ser";
-+    public static final int REPLAY_BUFFER_CAPACITY = 10000; // e.g., holds states from ~200-300 games
-+    public ReplayBuffer replayBuffer;
-+    public int wins = 0;
-+    public int total = 0;
- 
--    @Override
--    protected Game createNewGameAndPlayers() throws GameException, FileNotFoundException {
--        ComputerPlayerMCTS2.PATH_TO_NN = "C:\\Users\\WillWroble\\Documents\\GitHub\\MageZero\\exports\\UWTempo\\ver2\\Model.onnx";
--
--        Game game = new TwoPlayerDuel(MultiplayerAttackOption.LEFT, RangeOfInfluence.ONE, MulliganType.GAME_DEFAULT.getMulligan(0), 60, 20, 7);
--        playerA = createPlayer(game, "PlayerA", "C:\\Users\\WillWroble\\Documents\\" + deckNameA);
--        playerB = createPlayer(game, "PlayerB", "C:\\Users\\WillWroble\\Documents\\" + deckNameB);
--        return game;
--    }
-     @Override
-     protected TestPlayer createPlayer(String name, RangeOfInfluence rangeOfInfluence) {
-         if (getFullSimulatedPlayers().contains(name)) {
-@@ -64,27 +30,14 @@ public class MCTS2WithNNTests extends MinimaxVectorExtractionTests {
-                 testPlayer.setAIPlayer(true); // enable full AI support (game simulations) for all turns by default
-                 return testPlayer;
-             } else {
--                TestComputerPlayer7 t7 = new TestComputerPlayer7(name, RangeOfInfluence.ONE, getSkillLevel());
--                TestPlayer testPlayer = new TestPlayer(t7);
-+                TestComputerPlayer8 t8 = new TestComputerPlayer8(name, RangeOfInfluence.ONE, getSkillLevel());
-+                TestPlayer testPlayer = new TestPlayer(t8);
-                 testPlayer.setAIPlayer(true); // enable full AI support (game simulations) for all turns by default
-                 return testPlayer;
-             }
-         }
-         return super.createPlayer(name, rangeOfInfluence);
-     }
--    public void init_seed() {
--        seed = RandomUtil.nextInt();
--        //seed = -1421792887;
--        //seed = 233400479;
--        //seed = 1603827803;
--        //seed = -99205609;
--
--        //seed = 144516733;
--        //seed = 197732112;
--        seed = -781685651;
--        System.out.printf("USING SEED: %d\n", seed);
--        RandomUtil.setSeed(seed);
--    }
-     @Before
-     public void init_encoder() {
-         init_seed();
-@@ -117,102 +70,136 @@ public class MCTS2WithNNTests extends MinimaxVectorExtractionTests {
-         } else {
-             System.out.println("No persistent mapping found. Starting fresh.");
-         }
-+        //also set up buffer
-+        File bufferFile = new File(REPLAY_BUFFER_FILE);
-+        if (bufferFile.exists()) {
-+            try {
-+                replayBuffer = (ReplayBuffer) loadObject(REPLAY_BUFFER_FILE);
-+                System.out.printf("Loaded Replay Buffer with %d states from %s%n", replayBuffer.size(), REPLAY_BUFFER_FILE);
-+            } catch (IOException | ClassNotFoundException e) {
-+                System.out.println("Failed to load Replay Buffer. Starting with a fresh one.");
-+                replayBuffer = new ReplayBuffer(REPLAY_BUFFER_CAPACITY);
++        //subfeatures
++        for (String n : f.subFeatures.keySet()) {
++            Map<Integer, Features> thisSubMap = this.subFeatures.computeIfAbsent(n, k -> new HashMap<>());
++            for (int i : f.subFeatures.get(n).keySet()) {
++                Features thisSubFeature = thisSubMap.computeIfAbsent(i, k -> new Features(this, n + "_" + i));
++                thisSubFeature.merge(f.subFeatures.get(n).get(i));
 +            }
-+        } else {
-+            System.out.println("No Replay Buffer found. Starting fresh.");
-+            replayBuffer = new ReplayBuffer(REPLAY_BUFFER_CAPACITY);
-+        }
- 
-         set_encoder();
-         labeledStates = new ArrayList<>();
-     }
-+    @Override
-+    public void init_seed() {
-+        seed = RandomUtil.nextInt();
-+        //seed = -1421792887;
-+        //seed = 233400479;
-+        //seed = 1603827803;
-+        //seed = -99205609;
-+
-+        //seed = 144516733;
-+        //seed = 197732112;
-+        //seed = -781685651;
-+        //seed = 2036403658;
-+        //seed = -1702733670;
-+        //seed = 1617973009;
-+        //seed = 1735298645;
-+        seed = -1943293127;
-+        System.out.printf("USING SEED: %d\n", seed);
-+        RandomUtil.setSeed(seed);
-+    }
-+    @Override
-     public void set_encoder() {
-         ComputerPlayerMCTS2 mcts2 = (ComputerPlayerMCTS2) playerA.getComputerPlayer();
-+        mcts2.clearTree();
-+        MCTSNode.clearCaches();
-+        ComputerPlayer8 c8 = (ComputerPlayer8)playerB.getComputerPlayer();
-+        c8.setEncoder(encoder);
-         mcts2.setEncoder(encoder);
-+        mcts2.setBuffer(replayBuffer);
-+        mcts2.initNN("models/Model1.onnx");
-         encoder.setAgent(playerA.getId());
-         encoder.setOpponent(playerB.getId());
-     }
--    public void reset_game() {
--        try {
--            ((ComputerPlayerMCTS2)playerA.getComputerPlayer()).nn.close();
--        } catch (OrtException oe) {
--            oe.printStackTrace();
--        }
--        try {
--            reset();
--        } catch (FileNotFoundException e) {
--            throw new RuntimeException(e);
--        } catch (GameException e) {
--            throw new RuntimeException(e);
--        }
--        set_encoder();
--
--    }
--    public void reset_vectors() {
--        encoder.macroStateVectors.clear();
--        encoder.stateScores.clear();
--        ActionEncoder.actionVectors.clear();
--    }
--
--    /**
--     * uses saved list of actions and states to make a labeled vector batch for training
--     */
-+    @Override
-     public void create_labeled_states() {
-+        total++;
-+        if(playerA.hasWon()) wins++;
-         int N = encoder.macroStateVectors.size();
-         double  = 0.99;          // discount factor
--        double  = 0;           // how much weight to give the minimax estimate vs. terminal
- 
-         labeledStateBatch.clear();
-         for(int i = 0; i < N; i++) {
--            // 1) decompress your raw state and action bits (you already have this)
--            Set<Integer> state = encoder.getCompressedVector(encoder.macroStateVectors.get(i));
-+            Set<Integer> state = encoder.macroStateVectors.get(i);
-             double[] action = ActionEncoder.actionVectors.get(i);
- 
--            // 2) get your raw minimax score and normalize into [-1,+1]
--            double normScore = encoder.stateScores.get(i);
--            //double normScore = rawScore / (double)Math.abs(GameStateEvaluator2.LOSE_GAME_SCORE);
--
--            //double scale = 20000.0;              // or better yet: maxAbs(stateScores)
--            //double normScore = Math.tanh(rawScore/scale);
--
--
--            // 3) build your discounted terminal label in [-1,+1]
-             boolean win = playerA.hasWon();
-             double terminal = win ? +1.0 : -1.0;
-             double discount = Math.pow(, N - i - 1);
- 
--            // 4) blend them
--            double blended =  * normScore + (1.0 - ) * terminal * discount;
-+            double score = terminal * discount;
- 
--            // 5) store a single LabeledState with that double label
--            labeledStateBatch.add(new LabeledState(state, action, blended));
-+            labeledStateBatch.add(new LabeledState(state, action, score));
-         }
--
--        // shuffle before writing out / persisting
--        //Collections.shuffle(labeledStateBatch);
--
-         reset_vectors();
-     }
--    public void print_labeled_states() {
--        for (LabeledState ls : labeledStates) {
--            StringBuilder sb1 = new StringBuilder();
--            for (int i = 0; i < 100; i++) {
--                sb1.append(ls.stateVector[i]);
--                //sb1.append(", ");
--            }
--
--            System.out.printf("State: %s, Action: %s, Result: %s\n", sb1.toString(), Arrays.toString(ls.actionVector), ls.resultLabel);
-+    public void loadGame() {
-+        if (replayBuffer.size() == 0) {
-+            System.out.println("Replay buffer is empty, skipping state load.");
-+            reset_game();
-+            return;
-         }
-+        currentGame = replayBuffer.sample(1).get(0).copy();
-+        TestPlayer newPlayerA = (TestPlayer) currentGame.getPlayer(playerA.getId());
-+        TestPlayer newPlayerB = (TestPlayer) currentGame.getPlayer(playerB.getId());
-+        newPlayerA.setMatchPlayer(playerA.getMatchPlayer());
-+        newPlayerB.setMatchPlayer(playerB.getMatchPlayer());
-+
-+        //ComputerPlayerMCTS2 mcts2 = (ComputerPlayerMCTS2) newPlayerA.getComputerPlayer();
-+        //mcts2.root = null;
-+        //ComputerPlayerMCTS.macroState = ComputerPlayerMCTS.createCompleteMCTSGame(currentGame);
-+
-+        playerA.restore(newPlayerA);
-+        playerB.restore(newPlayerB);
-+        currentGame.getState().getPlayers().put(playerA.getId(), playerA);
-+        currentGame.getState().getPlayers().put(playerB.getId(), playerB);
-+        currentGame.setGameOptions(gameOptions);
-+        set_encoder();
-     }
-     @Test
-     public void test_1_game() {
-+        int maxTurn = 50;
-+        Features.printOldFeatures = false;
-+        //ComputerPlayer.PRINT_DECISION_FALLBACKS = true;
-+        ComputerPlayerMCTS2.SHOW_THREAD_INFO = true;
-+        setStrictChooseMode(false);
-+        setStopAt(maxTurn, PhaseStep.END_TURN);
-+        execute();
-+    }
-+    @Test
-+    public void test_save_1_game_to_buffer() {
-         int maxTurn = 50;
-         Features.printOldFeatures = false;
-         ComputerPlayerMCTS2.SHOW_THREAD_INFO = true;
-         setStrictChooseMode(true);
-         setStopAt(maxTurn, PhaseStep.END_TURN);
-         execute();
--
-+        save_buffer();
-     }
-     @Test
--    public void print_current_ignore_list() {
-+    public void test_1_game_from_buffer() {
-+        loadGame();
-+        int maxTurn = 50;
-+        Features.printOldFeatures = false;
-+        ComputerPlayerMCTS2.SHOW_THREAD_INFO = true;
-+        setStrictChooseMode(true);
-+        setStopAt(maxTurn, PhaseStep.END_TURN);
-+        currentGame.resume();
-+    }
-+    @Test
-+    public void print_data() {
-         System.out.printf("IGNORE LIST SIZE: %d\n", encoder.ignoreList.size());
-         System.out.printf("REDUCED VECTOR SIZE: %d\n", StateEncoder.indexCount - encoder.ignoreList.size());
-+        System.out.printf("REPLAY BUFFER SIZE: %d\n", replayBuffer.size());
-     }
-     /**
-      * make a training set of 50 games
-@@ -222,7 +209,10 @@ public class MCTS2WithNNTests extends MinimaxVectorExtractionTests {
-         int maxTurn = 50;
-         Features.printOldFeatures = false;
-         ComputerPlayerMCTS2.SHOW_THREAD_INFO = true;
-+        ComputerPlayer.PRINT_DECISION_FALLBACKS = true;
-         for(int i = 0; i < 5; i++) {
-+            addCard(Zone.HAND, playerA, "Lost Jitte", 1);
-+            removeAllCardsFromHand(playerB);
-             setStrictChooseMode(true);
-             setStopAt(maxTurn, PhaseStep.END_TURN);
-             execute();
-@@ -240,10 +230,40 @@ public class MCTS2WithNNTests extends MinimaxVectorExtractionTests {
-         print_labeled_states();
-         persistLabeledStates(TRAIN_OUT_FILE);
-         persistData();
-+        save_buffer();
-         System.out.printf("IGNORE LIST SIZE: %d\n", encoder.ignoreList.size());
-         System.out.printf("REDUCED VECTOR SIZE: %d\n", StateEncoder.indexCount - encoder.ignoreList.size());
-+        System.out.printf("WINRATE: %f\n", wins*1.0/total);
-     }
-+    @Test
-+    public void make_train_ds_50_from_buffer() {
-+        int maxTurn = 50;
-+        Features.printOldFeatures = false;
-+        ComputerPlayerMCTS2.SHOW_THREAD_INFO = true;
-+        for(int i = 0; i < 5; i++) {
-+            loadGame();
-+            setStrictChooseMode(true);
-+            setStopAt(maxTurn, PhaseStep.END_TURN);
-+            currentGame.resume();
-+            create_labeled_states();
-+            labeledStates.addAll(labeledStateBatch);
-+            labeledStateBatch.clear();
-+            reset_game();
-+            System.out.printf("GAME #%d RESET... NEW GAME STARTING\n", i+1);
 +        }
-+        Set<Integer> newIgnore = new HashSet<>(FeatureMerger.computeIgnoreListFromLS(labeledStates));
-+        Set<Integer> oldIgnore = new HashSet<>(encoder.ignoreList);
-+        encoder.ignoreList = combine_ignore_lists(oldIgnore, newIgnore);
-+        compress_labeled_states();
- 
-+        print_labeled_states();
-+        //persistLabeledStates(TRAIN_OUT_FILE);
-+        //persistData();
-+        //save_buffer();
-+        System.out.printf("IGNORE LIST SIZE: %d\n", encoder.ignoreList.size());
-+        System.out.printf("REDUCED VECTOR SIZE: %d\n", StateEncoder.indexCount - encoder.ignoreList.size());
-+        System.out.printf("WINRATE: %f\n", wins*1.0/total);
-+    }
-     /**
-      * make a testing/validation set of 5 random states from each of 50 games
-      */
-@@ -265,63 +285,22 @@ public class MCTS2WithNNTests extends MinimaxVectorExtractionTests {
-         persistLabeledStates(TEST_OUT_FILE);
-         persistData();
-     }
-+    public void save_buffer() {
-+        try {
-+            saveObject(replayBuffer, REPLAY_BUFFER_FILE);
-+            System.out.printf("Persisted replay buffer to %s%n", REPLAY_BUFFER_FILE);
-+        } catch (IOException e) {
-+            e.printStackTrace();
++        //category labels
++        for (String n : f.categoriesForChildren.keySet()) {
++            if (!this.categoriesForChildren.containsKey(n)) {
++                this.categoriesForChildren.put(n, this.getCategory(n));
++            }
++            this.categoriesForChildren.get(n).merge(f.categoriesForChildren.get(n));
 +        }
 +    }
-     @After
-     public void print_vector_size() {
-         System.out.printf("FINAL (unreduced) VECTOR SIZE: %d\n", StateEncoder.indexCount);
-         System.out.printf("FINAL ACTION VECTOR SIZE: %d\n", ActionEncoder.indexCount);
-+        System.out.printf("REPLAY BUFFER SIZE: %d\n", replayBuffer.size());
-         for(String s : ActionEncoder.actionMap.keySet()) {
-             System.out.printf("[%s => %d] ", s, ActionEncoder.actionMap.get(s));
-         }
-         System.out.println();
-     }
--    private void persistLabeledStates(String filename) {
--        try (DataOutputStream out = new DataOutputStream(
--                new BufferedOutputStream(new FileOutputStream(filename)))) {
--
--            // 1) Header
--            int n = labeledStates.size();
--            int S = StateEncoder.COMPRESSED_VECTOR_SIZE;         // total feature count
--            int wordsPerState = (S + 63) >>> 6;       // S/64 longs per state
--            int A = 128;
--
--            out.writeInt(n);
--            out.writeInt(S);
--            out.writeInt(wordsPerState);
--            out.writeInt(A);
--
--            // 2) Body
--            for (LabeledState ls : labeledStates) {
--                ls.persist(out);
--            }
--        } catch (IOException e) {
--            e.printStackTrace();
--        }
--    }
--
--    public void persistData() {
--        try {
--            encoder.persistMapping(MAPPING_FILE);
--            System.out.printf("Persisted feature mapping to %s\n", MAPPING_FILE);
--            //saveObject(ignore, IGNORE_FILE);
--            //System.out.printf("Persisted ignore list to %s\n", IGNORE_FILE);
--            saveObject(new HashMap<>(ActionEncoder.actionMap), ACTIONS_FILE);
--            System.out.printf("Persisted action mapping to %s\n", ACTIONS_FILE);
--        } catch (IOException e) {
--            e.printStackTrace();
--        }
--    }
--
--    // Method to save a Serializable object to a file
--    public static void saveObject(Object obj, String fileName) throws IOException {
--        try (ObjectOutputStream out = new ObjectOutputStream(Files.newOutputStream(Paths.get(fileName)))) {
--            out.writeObject(obj);
--        }
--    }
--
--    // Method to load a Serializable object from a file
--    public static Object loadObject(String fileName) throws IOException, ClassNotFoundException {
--        try (ObjectInputStream in = new ObjectInputStream(Files.newInputStream(Paths.get(fileName)))) {
--            return in.readObject();
--        }
--    }
- }
-diff --git a/Mage.Tests/src/test/java/org/mage/test/AI/RL/MCTSEncoderTests.java b/Mage.Tests/src/test/java/org/mage/test/AI/RL/MCTSEncoderTests.java
-index e41b4b39a4..f6b4018cda 100644
---- a/Mage.Tests/src/test/java/org/mage/test/AI/RL/MCTSEncoderTests.java
-+++ b/Mage.Tests/src/test/java/org/mage/test/AI/RL/MCTSEncoderTests.java
-@@ -39,8 +39,8 @@ public class MCTSEncoderTests extends CardTestPlayerBaseAI {
-                 RangeOfInfluence.ONE,
-                 MulliganType.GAME_DEFAULT.getMulligan(0),
-                 60, 20, 7);
--        playerA = createPlayer(game, "PlayerA", "C:\\Users\\WillWroble\\Documents\\" + deckNameA);
--        playerB = createPlayer(game, "PlayerB", "C:\\Users\\WillWroble\\Documents\\" + deckNameB);
-+        playerA = createPlayer(game, "PlayerA", "C:\\Users\\owner\\Documents\\" + deckNameA);
-+        playerB = createPlayer(game, "PlayerB", "C:\\Users\\owner\\Documents\\" + deckNameB);
-         return game;
-     }
- 
-diff --git a/Mage.Tests/src/test/java/org/mage/test/AI/RL/MinimaxVectorExtractionTests.java b/Mage.Tests/src/test/java/org/mage/test/AI/RL/MinimaxVectorExtractionTests.java
-index 5f06b17ade..0e4b2a6deb 100644
---- a/Mage.Tests/src/test/java/org/mage/test/AI/RL/MinimaxVectorExtractionTests.java
-+++ b/Mage.Tests/src/test/java/org/mage/test/AI/RL/MinimaxVectorExtractionTests.java
-@@ -8,6 +8,7 @@ import mage.game.GameException;
- import mage.game.TwoPlayerDuel;
- import mage.game.mulligan.MulliganType;
- import mage.player.ai.*;
-+import mage.util.RandomUtil;
- import org.junit.After;
- import org.junit.Before;
- import org.junit.Test;
-@@ -24,17 +25,18 @@ import java.util.*;
- public class MinimaxVectorExtractionTests extends CardTestPlayerBaseAI {
-     private String deckNameA = "UWTempo.dck"; //simplegreen, UWTempo
-     private String deckNameB = "simplegreen.dck";
--    private List<LabeledState> labeledStates = new ArrayList<>();
--    private List<LabeledState> labeledStateBatch = new ArrayList<>();
-+    public List<LabeledState> labeledStates = new ArrayList<>();
-+    public List<LabeledState> labeledStateBatch = new ArrayList<>();
-     public StateEncoder encoder;
-+    public int seed;
- 
-     //private Set<Integer> ignore;
-     //private Map<String, Integer> actions;
-     // File where the persistent mapping is stored
--    private static final String MAPPING_FILE = "features_mapping.ser";
--    private static final String ACTIONS_FILE = "actions_mapping.ser";
--    private static final String TRAIN_OUT_FILE = "training.bin";
--    private static final String TEST_OUT_FILE = "testing.bin";
-+    public static final String MAPPING_FILE = "features_mapping.ser";
-+    public static final String ACTIONS_FILE = "actions_mapping.ser";
-+    public static final String TRAIN_OUT_FILE = "training.bin";
-+    public static final String TEST_OUT_FILE = "testing.bin";
- 
- 
-     @Override
-@@ -45,8 +47,8 @@ public class MinimaxVectorExtractionTests extends CardTestPlayerBaseAI {
-     @Override
-     protected Game createNewGameAndPlayers() throws GameException, FileNotFoundException {
-         Game game = new TwoPlayerDuel(MultiplayerAttackOption.LEFT, RangeOfInfluence.ONE, MulliganType.GAME_DEFAULT.getMulligan(0), 60, 20, 7);
--        playerA = createPlayer(game, "PlayerA", "C:\\Users\\WillWroble\\Documents\\" + deckNameA);
--        playerB = createPlayer(game, "PlayerB", "C:\\Users\\WillWroble\\Documents\\" + deckNameB);
-+        playerA = createPlayer(game, "PlayerA",  deckNameA);
-+        playerB = createPlayer(game, "PlayerB",  deckNameB);
-         return game;
-     }
-     @Override
-@@ -66,8 +68,14 @@ public class MinimaxVectorExtractionTests extends CardTestPlayerBaseAI {
-         }
-         return super.createPlayer(name, rangeOfInfluence);
-     }
-+    public void init_seed() {
-+        seed = RandomUtil.nextInt();
-+        System.out.printf("USING SEED: %d\n", seed);
-+        RandomUtil.setSeed(seed);
-+    }
-     @Before
-     public void init_encoder() {
-+        init_seed();
-         System.out.println("Setting up encoder");
-         encoder = new StateEncoder();
-         //ignore = new HashSet<>();
-@@ -202,33 +210,6 @@ public class MinimaxVectorExtractionTests extends CardTestPlayerBaseAI {
-         return updatedIgnoreList;
-     }
- 
--    /**
--     * can only grow ignore list
--     * @param oldList
--     * @param newList
--     * @return
--     */
--    public Set<Integer> union_ignore_lists(Set<Integer> oldList, Set<Integer> newList) {
--        Set<Integer> updatedIgnoreList = new HashSet<>();
--
--        int boundaryForOldFeatures = this.encoder.initialRawSize;
--
--
--        for (int i = 0; i < boundaryForOldFeatures; i++) {
--            if (oldList.contains(i)) {
--                updatedIgnoreList.add(i);
--            }
--        }
--
--        for (Integer featureIndexInNewList : newList) {
--            if (featureIndexInNewList >= boundaryForOldFeatures) {
--                updatedIgnoreList.add(featureIndexInNewList);
--            }
--        }
--
--        return updatedIgnoreList;
--    }
--
-     /**
-      * use the current encoder's compression at the end so it can use the new ignore list
-      */
-@@ -238,6 +219,11 @@ public class MinimaxVectorExtractionTests extends CardTestPlayerBaseAI {
-         }
-     }
-     @Test
-+    public void print_current_ignore_list() {
-+        System.out.printf("IGNORE LIST SIZE: %d\n", encoder.ignoreList.size());
-+        System.out.printf("REDUCED VECTOR SIZE: %d\n", StateEncoder.indexCount - encoder.ignoreList.size());
-+    }
-+    @Test
-     public void make_ignore_X_50() {
-         int maxTurn = 50;
-         Features.printOldFeatures = false;
-@@ -266,7 +252,7 @@ public class MinimaxVectorExtractionTests extends CardTestPlayerBaseAI {
-     public void make_train_ds_X_250() {
-         int maxTurn = 50;
-         Features.printOldFeatures = false;
--        for(int i = 0; i < 5; i++) {
-+        for(int i = 0; i < 250; i++) {
-             setStrictChooseMode(true);
-             setStopAt(maxTurn, PhaseStep.END_TURN);
-             execute();
-@@ -319,14 +305,14 @@ public class MinimaxVectorExtractionTests extends CardTestPlayerBaseAI {
-     }
-     @After
-     public void print_vector_size() {
--        System.out.printf("FINAL (unreduced) VECTOR SIZE: %d\n", StateEncoder.indexCount);
-+        System.out.printf("RAW VECTOR SIZE: %d\n", StateEncoder.indexCount);
-         System.out.printf("FINAL ACTION VECTOR SIZE: %d\n", ActionEncoder.indexCount);
-         for(String s : ActionEncoder.actionMap.keySet()) {
-             System.out.printf("[%s => %d] ", s, ActionEncoder.actionMap.get(s));
-         }
-         System.out.println();
-     }
--    private void persistLabeledStates(String filename) {
-+    public void persistLabeledStates(String filename) {
-         try (DataOutputStream out = new DataOutputStream(new BufferedOutputStream(Files.newOutputStream(Paths.get(filename))))) {
- 
-             // 1) Header
-@@ -334,7 +320,7 @@ public class MinimaxVectorExtractionTests extends CardTestPlayerBaseAI {
- 
-             // 'S' now represents the TOTAL size of your global feature vocabulary.
-             // The constant should be updated to reflect this.
--            int S = StateEncoder.GLOBAL_FEATURE_COUNT;
-+            int S = StateEncoder.indexCount;
- 
-             // 'A' is still the size of the policy vector.
-             int A = 128;
-diff --git a/Mage.Tests/src/test/java/org/mage/test/AI/RL/PureMCTSTests.java b/Mage.Tests/src/test/java/org/mage/test/AI/RL/PureMCTSTests.java
-index 24027cfe92..edd4d4bbc8 100644
---- a/Mage.Tests/src/test/java/org/mage/test/AI/RL/PureMCTSTests.java
-+++ b/Mage.Tests/src/test/java/org/mage/test/AI/RL/PureMCTSTests.java
-@@ -44,8 +44,8 @@ public class PureMCTSTests extends CardTestPlayerBaseAI {
-     @Override
-     protected Game createNewGameAndPlayers() throws GameException, FileNotFoundException {
-         Game game = new TwoPlayerDuel(MultiplayerAttackOption.LEFT, RangeOfInfluence.ONE, MulliganType.GAME_DEFAULT.getMulligan(0), 60, 20, 7);
--        playerA = createPlayer(game, "PlayerA", "C:\\Users\\WillWroble\\Documents\\" + deckNameA);
--        playerB = createPlayer(game, "PlayerB", "C:\\Users\\WillWroble\\Documents\\" + deckNameB);
-+        playerA = createPlayer(game, "PlayerA", "C:\\Users\\owner\\Documents\\" + deckNameA);
-+        playerB = createPlayer(game, "PlayerB", "C:\\Users\\owner\\Documents\\" + deckNameB);
-         return game;
-     }
-     @Override
-diff --git a/Mage.Tests/src/test/java/org/mage/test/AI/RL/RLEncodingTests.java b/Mage.Tests/src/test/java/org/mage/test/AI/RL/RLEncodingTests.java
-index 0297f37e2e..71b9ed5d82 100644
---- a/Mage.Tests/src/test/java/org/mage/test/AI/RL/RLEncodingTests.java
-+++ b/Mage.Tests/src/test/java/org/mage/test/AI/RL/RLEncodingTests.java
-@@ -40,8 +40,8 @@ public class RLEncodingTests extends CardTestPlayerBaseAI {
-     @Override
-     protected Game createNewGameAndPlayers() throws GameException, FileNotFoundException {
-         Game game = new TwoPlayerDuel(MultiplayerAttackOption.LEFT, RangeOfInfluence.ONE, MulliganType.GAME_DEFAULT.getMulligan(0), 60, 20, 7);
--        playerA = createPlayer(game, "PlayerA", "C:\\Users\\WillWroble\\Documents\\" + deckNameA);
--        playerB = createPlayer(game, "PlayerB", "C:\\Users\\WillWroble\\Documents\\" + deckNameB);
-+        playerA = createPlayer(game, "PlayerA", "C:\\Users\\owner\\Documents\\" + deckNameA);
-+        playerB = createPlayer(game, "PlayerB", "C:\\Users\\owner\\Documents\\" + deckNameB);
-         return game;
-     }
-     @Override
-diff --git a/Mage.Tests/src/test/java/org/mage/test/player/TestPlayer.java b/Mage.Tests/src/test/java/org/mage/test/player/TestPlayer.java
-index e82d12ad8a..5232de9ac2 100644
---- a/Mage.Tests/src/test/java/org/mage/test/player/TestPlayer.java
-+++ b/Mage.Tests/src/test/java/org/mage/test/player/TestPlayer.java
-@@ -169,6 +169,11 @@ public class TestPlayer implements Player {
-         this.strictChooseMode = testPlayer.strictChooseMode;
-     }
- 
-+    @Override
-+    public Ability getLastActivated() {
-+        return computerPlayer.getLastActivated();
-+    }
-+
-     public void addChoice(String choice) {
-         // prepare face down
-         // how-to fix:
-diff --git a/Mage.Tests/testing.bin b/Mage.Tests/testing.bin
-index ab27eacfbd..3d931d5819 100644
-Binary files a/Mage.Tests/testing.bin and b/Mage.Tests/testing.bin differ
-diff --git a/Mage.Tests/training.bin b/Mage.Tests/training.bin
-index f3a0f558bc..7aff576c27 100644
-Binary files a/Mage.Tests/training.bin and b/Mage.Tests/training.bin differ
-diff --git a/Mage/src/main/java/mage/cards/decks/DeckCardLayout.java b/Mage/src/main/java/mage/cards/decks/DeckCardLayout.java
-index b12e9b7cee..966a8dceb8 100644
---- a/Mage/src/main/java/mage/cards/decks/DeckCardLayout.java
-+++ b/Mage/src/main/java/mage/cards/decks/DeckCardLayout.java
-@@ -2,13 +2,14 @@ package mage.cards.decks;
- 
- import mage.util.Copyable;
- 
-+import java.io.Serializable;
- import java.util.ArrayList;
- import java.util.List;
- 
- /**
-  * Created by stravant@gmail.com on 2016-10-03.
-  */
--public class DeckCardLayout implements Copyable<DeckCardLayout> {
-+public class DeckCardLayout implements Copyable<DeckCardLayout>, Serializable {
- 
-     private final List<List<List<DeckCardInfo>>> cards;
-     private final String settings;
-diff --git a/Mage/src/main/java/mage/game/Exile.java b/Mage/src/main/java/mage/game/Exile.java
-index 7d8b7bd566..813342e32f 100644
---- a/Mage/src/main/java/mage/game/Exile.java
-+++ b/Mage/src/main/java/mage/game/Exile.java
-@@ -14,7 +14,7 @@ import java.util.stream.Collectors;
-  */
- public class Exile implements Serializable, Copyable<Exile> {
- 
--    private static final UUID PERMANENT = UUID.randomUUID();
-+    private final UUID PERMANENT = UUID.nameUUIDFromBytes("Permanent".getBytes());
- 
-     private final Map<UUID, ExileZone> exileZones = new HashMap<>();
- 
-diff --git a/Mage/src/main/java/mage/game/Game.java b/Mage/src/main/java/mage/game/Game.java
-index 2df39b9016..4fabcbdb5a 100644
---- a/Mage/src/main/java/mage/game/Game.java
-+++ b/Mage/src/main/java/mage/game/Game.java
-@@ -46,6 +46,14 @@ import java.util.*;
- import java.util.stream.Collectors;
- 
- public interface Game extends MageItem, Serializable, Copyable<Game> {
-+//    void setMacroState(Game game);
-+//    void setMacroPlayerId(UUID id);
-+//    void setLastAction(Ability ability);
-+    Game getLastPriority();
-+    UUID getLastPriorityPlayerId();
-+    Ability getLastPriorityAction();
-+
-+    void setLastPriority(Game game);
- 
-     MatchType getGameType();
- 
-@@ -640,6 +648,9 @@ public interface Game extends MageItem, Serializable, Copyable<Game> {
- 
-     boolean executingRollback();
- 
-+    void addCard(UUID cardId, Card card);
-+
-+
-     /**
-      * Add counters to permanent before ETB. Use it before put real permanent to battlefield.
-      */
-diff --git a/Mage/src/main/java/mage/game/GameImpl.java b/Mage/src/main/java/mage/game/GameImpl.java
-index fcacee29f7..20aae6d13a 100644
---- a/Mage/src/main/java/mage/game/GameImpl.java
-+++ b/Mage/src/main/java/mage/game/GameImpl.java
-@@ -93,6 +93,10 @@ import java.util.stream.Collectors;
-  * If it's a temporary/auto-generated data then mark that field as transient and comment in copy constructor.
-  */
- public abstract class GameImpl implements Game {
-+    //shallow game history for AI
-+    private Game lastPriority = this;
-+    private UUID lastPriorityPlayerId;
-+    public Ability lastPriorityAction;
- 
-     private static final int ROLLBACK_TURNS_MAX = 4;
-     private static final String UNIT_TESTS_ERROR_TEXT = "Error in unit tests";
-@@ -182,6 +186,8 @@ public abstract class GameImpl implements Game {
-     }
- 
-     protected GameImpl(final GameImpl game) {
-+        this.lastPriorityAction = game.lastPriorityAction;
-+        this.lastPriorityPlayerId = game.lastPriorityPlayerId;
-         //this.customData = game.customData; // temporary data, no need on game copy
-         //this.losingPlayer = game.losingPlayer; // temporary data, no need on game copy
-         this.aiGame = game.aiGame;
-@@ -247,6 +253,48 @@ public abstract class GameImpl implements Game {
-          */
-     }
- 
 +    /**
-+     * @return the game object from right before the last priority
++     * Creates a synchronized, deep copy of this Features object.
++     * By being synchronized, it ensures we get a clean snapshot and never
++     * copy the object while another thread is in the middle of merging.
++     * @return A new, completely independent deep copy of this object.
 +     */
-+    @Override
-+    public Game getLastPriority() {
-+        return lastPriority;
-+    }
++    public synchronized Features createDeepCopy() {
++        try {
++            ByteArrayOutputStream byteOutput = new ByteArrayOutputStream();
++            ObjectOutputStream objectOutput = new ObjectOutputStream(byteOutput);
++            objectOutput.writeObject(this);
++            objectOutput.close();
 +
-+    /**
-+     * @return the id of the player who last had priority
-+     */
-+    @Override
-+    public UUID getLastPriorityPlayerId() {
-+        return lastPriorityPlayerId;
-+    }
++            ByteArrayInputStream byteInput = new ByteArrayInputStream(byteOutput.toByteArray());
++            ObjectInputStream objectInput = new ObjectInputStream(byteInput);
++            Features copy = (Features) objectInput.readObject();
++            objectInput.close();
 +
-+    /**
-+     * @return the action made during the last priority
-+     */
-+    @Override
-+    public Ability getLastPriorityAction() {
-+        return lastPriorityAction;
-+    }
-+    /**
-+     * @return the action made during the last priority
-+     */
-+    @Override
-+    public void setLastPriority(Game game) {
-+        lastPriority = game;
-+    }
-+//    @Override
-+//    public void setMacroState(Game game) {
-+//        macroState = game;
-+//    }
-+//    @Override
-+//    public void setMacroPlayerId(UUID id) {
-+//        macroPlayerId = id;
-+//    }
-+//    @Override
-+//    public void setLastAction(Ability ability) {
-+//        lastAction = ability;
-+//    }
-     @Override
-     public boolean isSimulation() {
-         return simulation;
-@@ -255,6 +303,7 @@ public abstract class GameImpl implements Game {
-     @Override
-     public Game createSimulationForAI() {
-         Game res = this.copy();
-+        ((GameImpl) res).lastPriority = lastPriority;
-         ((GameImpl) res).simulation = true;
-         ((GameImpl) res).aiGame = true;
-         return res;
-@@ -948,7 +997,14 @@ public abstract class GameImpl implements Game {
-         }
-         return savedStates.size();
-     }
--
-+    // In mage.game.GameImpl.java
-+    @Override
-+    public void addCard(UUID cardId, Card card) {
-+        // This public method allows our reconstructor to populate the master card map.
-+        if (cardId != null && card != null) {
-+            this.gameCards.put(cardId, card);
++            return copy;
++        } catch (IOException | ClassNotFoundException e) {
++            throw new RuntimeException("Failed to create a deep copy of the Features object.", e);
 +        }
 +    }
-     /**
-      * Warning, for inner usage only, use player.restoreState as much as possible instead
-      *
-@@ -1713,8 +1769,11 @@ public abstract class GameImpl implements Game {
-                                 if (isPaused() || checkIfGameIsOver()) {
-                                     return;
-                                 }
-+                                lastPriority = this.copy();
-+                                lastPriorityPlayerId = player.getId();
-                                 // resetPassed should be called if player performs any action
-                                 if (player.priority(this)) {
-+                                    lastPriorityAction = player.getLastActivated();
-                                     if (executingRollback()) {
-                                         return;
-                                     }
-diff --git a/Mage/src/main/java/mage/players/Player.java b/Mage/src/main/java/mage/players/Player.java
-index aed45f3a4a..c64a877e80 100644
---- a/Mage/src/main/java/mage/players/Player.java
-+++ b/Mage/src/main/java/mage/players/Player.java
-@@ -70,7 +70,7 @@ public interface Player extends MageItem, Copyable<Player> {
-     enum PayLifeCostLevel {
-         allAbilities, nonSpellnonActivatedAbilities, onlyManaAbilities, none
-     }
--
-+    Ability getLastActivated();
-     /**
-      * Current player is real life player (human). Try to use in GUI and network engine only.
-      * <p>
-diff --git a/Mage/src/main/java/mage/players/PlayerImpl.java b/Mage/src/main/java/mage/players/PlayerImpl.java
-index 432b0917f0..35f60235f8 100644
---- a/Mage/src/main/java/mage/players/PlayerImpl.java
-+++ b/Mage/src/main/java/mage/players/PlayerImpl.java
-@@ -83,6 +83,7 @@ public abstract class PlayerImpl implements Player, Serializable {
-     static final Map<PhaseStep, Step.StepPart> SILENT_PHASES_STEPS = ImmutableMap.<PhaseStep, Step.StepPart>builder().
-             put(PhaseStep.DECLARE_ATTACKERS, Step.StepPart.PRE).build();
- 
-+    private Ability lastActivated;
-     /**
-      * Used to cancel waiting requests send to the player
-      */
-@@ -200,7 +201,7 @@ public abstract class PlayerImpl implements Player, Serializable {
-     protected final List<List<Mana>> availableTriggeredManaList = new ArrayList<>();
- 
-     protected PlayerImpl(String name, RangeOfInfluence range) {
--        this(UUID.randomUUID());
-+        this(UUID.nameUUIDFromBytes(name.getBytes()));
-         this.name = name;
-         this.range = range;
-         hand = new CardsImpl();
-@@ -218,6 +219,9 @@ public abstract class PlayerImpl implements Player, Serializable {
-     }
- 
-     protected PlayerImpl(final PlayerImpl player) {
-+
-+        this.lastActivated = player.lastActivated;
-+
-         this.abort = player.abort;
-         this.playerId = player.playerId;
- 
-@@ -301,7 +305,9 @@ public abstract class PlayerImpl implements Player, Serializable {
-         this.phyrexianColors = player.getPhyrexianColors() != null ? player.phyrexianColors.copy() : null;
-         this.designations = CardUtil.deepCopyObject(player.designations);
-     }
--
-+    public Ability getLastActivated() {
-+        return lastActivated;
-+    }
-     /**
-      * Restore on rollback
-      *
-@@ -1599,6 +1605,7 @@ public abstract class PlayerImpl implements Player, Serializable {
-         if (ability == null) {
-             return false;
+     // Helper method to persist the Features mapping to a file
+     public void saveMapping(String filename) throws IOException {
+         try (ObjectOutputStream oos = new ObjectOutputStream(Files.newOutputStream(Paths.get(filename)))) {
+@@ -226,4 +338,4 @@ public class Features  implements Serializable {
+             return (Features) ois.readObject();
          }
-+        lastActivated = ability.copy();
-         boolean result;
-         if (ability instanceof PassAbility) {
-             pass(game);
+     }
+-}
++}
+\ No newline at end of file
